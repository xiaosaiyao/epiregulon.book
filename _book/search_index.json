[["multiome---archr-workflow.html", "2 Multiome - ArchR workflow 2.1 Data preparation 2.2 Quick start 2.3 Session Info", " 2 Multiome - ArchR workflow In this chapter we are going to walk through the same dataset used in the “multiome tutorial - archR workflow”. This is a dataset generated by infecting LNCaP cells with NKX2-1 and GATA6 to examine the effects of these TFs on AR activity. 2.1 Data preparation Single cell preprocessing needs to performed by user’s favorite methods prior to using Epiregulon. The following components are required: 1. Peak matrix from scATAC-seq 2. Gene expression matrix from either paired or unpaired scRNA-seq. RNA-seq integration needs to be performed for unpaired dataset. 3. Dimensionality reduction matrix from with either single modalities or joint scRNA-seq and scATAC-seq Multiome data can now be conveniently processed by initiate.archr and then gp.sa.archr to obtain peak matrices. Finally, the archR project can be uploaded into DatasetDB as a MultiAssayExperiment object using maw.archr::importArchr or maw.archr::create.mae.with.multiple.sces.from.archr # load the MAE object library(scMultiome) mae &lt;- scMultiome::reprogramSeq() ## snapshotDate(): 2023-10-24 ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache # peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name assay(GeneExpressionMatrix) &lt;- as(log2(assay(GeneExpressionMatrix)+1), &quot;CsparseMatrix&quot;) # dimensional reduction matrix reducedDimMatrix &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;LSI_ATAC&quot;) Visualize singleCellExperiment by UMAP # transfer UMAP_combined from TileMatrix to GeneExpressionMatrix reducedDim(GeneExpressionMatrix, &quot;UMAP_Combined&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;UMAP_Combined&quot;) scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_Combined&quot;, text_by = &quot;Clusters&quot;, colour_by = &quot;Clusters&quot;) 2.2 Quick start 2.2.1 Retrieve bulk TF ChIP-seq binding sites First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq, which are hosted on Genomitory. Currently, human genomes HG19 and HG38 and mouse mm10 are available. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) ## snapshotDate(): 2023-10-24 ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache head(grl) ## GRangesList object of length 6: ## $`5-hmC` ## GRanges object with 24048 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 10000-10685 * ## [2] chr1 13362-13694 * ## [3] chr1 29631-29989 * ## [4] chr1 40454-40754 * ## [5] chr1 135395-135871 * ## ... ... ... ... ## [24044] chrY 56864377-56864627 * ## [24045] chrY 56876124-56876182 * ## [24046] chrM 84-2450 * ## [24047] chrM 13613-14955 * ## [24048] chrM 15134-16490 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;5 more elements&gt; 2.2.2 Link ATAC-seq peaks to target genes Next, we compute peak to gene correlations using a custom algorithm that has similar performance to ArchR’s P2G function. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, reducedDim = reducedDimMatrix, exp_assay = &quot;normalizedCounts&quot;) ## Using epiregulon to compute peak to gene links... ## performing k means clustering to form metacells ## Computing correlation p2g ## DataFrame with 30181 rows and 8 columns ## idxATAC chr start end idxRNA target Correlation distance ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;integer&gt; ## 1 2 chr1 818831 819331 14 AL669831.2 0.521484 57721 ## 2 5 chr1 858735 859235 17 LINC01128 0.649037 30938 ## 3 5 chr1 858735 859235 22 AL645608.4 0.559331 52934 ## 4 10 chr1 920987 921487 28 PERM1 0.528659 57540 ## 5 17 chr1 942448 942948 28 PERM1 0.689034 36079 ## ... ... ... ... ... ... ... ... ... ## 30177 126568 chrX 154534816 154535316 36407 IKBKG 0.622140 4926 ## 30178 126570 chrX 154541878 154542378 36406 G6PD 0.560829 2466 ## 30179 126571 chrX 154542392 154542892 36407 IKBKG 0.556282 0 ## 30180 126590 chrX 155228844 155229344 36426 CLIC2 0.627319 103268 ## 30181 126590 chrX 155228844 155229344 36427 AC234781.1 0.613156 120580 2.2.3 Add TF motif binding to peaks The next step is to add the TF binding information by overlapping regions of the peak matrix with the bulk chip-seq database loaded in 2. The user can supply either an archR project path and this function will retrieve the peak matrix, or a peakMatrix in the form of a Granges object or RangedSummarizedExperiment. overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) ## Computing overlap... ## Success! head(overlap) ## idxATAC idxTF tf ## 145 2 2 5-mC ## 146 2 25 AR ## 147 2 260 Epitope tags ## 148 2 710 NFYB ## 149 2 743 NR3C1 ## 150 2 798 PGR 2.2.4 Generate regulons A long format dataframe, representing the inferred regulons, is then generated. The dataframe consists of three columns: tf (transcription factor) target gene peak to gene correlation between tf and target gene regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 4402893 rows and 10 columns ## idxATAC chr start end idxRNA target distance idxTF tf ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 2 chr1 818831 819331 14 AL669831.2 57721 2 5-mC ## 2 2 chr1 818831 819331 14 AL669831.2 57721 25 AR ## 3 2 chr1 818831 819331 14 AL669831.2 57721 260 Epitope tags ## 4 2 chr1 818831 819331 14 AL669831.2 57721 710 NFYB ## 5 2 chr1 818831 819331 14 AL669831.2 57721 743 NR3C1 ## ... ... ... ... ... ... ... ... ... ... ## 4402889 126590 chrX 155228844 155229344 36426 CLIC2 103268 329 GATA2 ## 4402890 126590 chrX 155228844 155229344 36426 CLIC2 103268 1044 SUMO2 ## 4402891 126590 chrX 155228844 155229344 36427 AC234781.1 120580 296 FOXA1 ## 4402892 126590 chrX 155228844 155229344 36427 AC234781.1 120580 329 GATA2 ## 4402893 126590 chrX 155228844 155229344 36427 AC234781.1 120580 1044 SUMO2 ## corr ## &lt;matrix&gt; ## 1 0.521484 ## 2 0.521484 ## 3 0.521484 ## 4 0.521484 ## 5 0.521484 ## ... ... ## 4402889 0.627319 ## 4402890 0.627319 ## 4402891 0.613156 ## 4402892 0.613156 ## 4402893 0.613156 2.2.5 Network pruning (highly recommended) Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the active category is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section on differential networks. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon, clusters = GeneExpressionMatrix$Clusters, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05 ) pruned.regulon 2.2.6 Add Weights While the `pruneRegulon’ function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the four measures: 1) correlation between TF and target gene expression, 2) mutual information between the TF and target gene expression, 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not, or 4) log 2 fold difference of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Three measures (correlation, Wilcoxon statistics and log 2 fold difference) give both the magnitude and directionality of changes whereas mutational information is always positive. The correlation and mutual information statistics are computed on the grouped pseudobulks by user-supplied cluster labels, whereas the Wilcoxon and log fold change group cells based on the joint expression of TF, RE and TG in each single cell. regulon.w &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$Clusters, block_factor = NULL, tf_re.merge = TRUE, method = &quot;corr&quot;) regulon.w 2.2.7 (Optional) Annotate with TF motifs So far the gene regulatory network was constructed from TF ChIP-seq exclusively. Some users would prefer to further annotate the regulatory elements with the presence of motifs. We provide an option to annotate peaks with motifs from the Cisbp database. If no motifs are present for this particular factor (as in the case of co-factors or chromatin modifiers), we return NA. If motifs are available for a factor and the RE contains a motif, we return 1. If motifs are available and the RE does not contain a motif, we return 0. If the user has already performed motif annotation with ArchR, we could also retrieve the results directly. See ?addMotifScore regulon.w.motif &lt;- addMotifScore(regulon = regulon.w, peaks = rowRanges(PeakMatrix), species = &quot;human&quot;, genome = &quot;hg38&quot;) ## annotating peaks with motifs # if desired, set weight to 0 if no motif is found regulon.w.motif$weight[regulon.w.motif$motif == 0] &lt;- 0 2.2.8 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging expressions of target genes linked to the TF weighted by the test statistics of choice, chosen from either correlation, mutual information, Wilcoxon test statistics or log fold change. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weights_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,…,n} \\(weights_i\\) is the weight of TF and target i score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;, exp_assay = &quot;normalizedCounts&quot;, normalize = FALSE) ## calculating TF activity from regulon using weightedmean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by the number of targets... 2.2.9 Perform differential activity markers &lt;- findDifferentialActivity(activity_matrix = score.combine, groups = GeneExpressionMatrix$hash_assignment, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) Take the top TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) ## Using a logFC cutoff of 0.1 for class HTO10_GATA6_UTR ## Using a logFC cutoff of 0 for class HTO1_FOXA2_v2 ## Using a logFC cutoff of 0.1 for class HTO2_GATA6_v2 ## Using a logFC cutoff of 0 for class HTO3_NKX2.1_v2 ## Using a logFC cutoff of 0 for class HTO4_mFOXA1_v2 ## Using a logFC cutoff of 0 for class HTO5_NeonG_v2 ## Using a logFC cutoff of 0 for class HTO6_hFOXA1_UTR ## Using a logFC cutoff of 0 for class HTO8_NKX2.1_UTR 2.2.10 Visualize the results First visualize the known differential TFs by bubble plot plotBubble(activity_matrix = score.combine, tf = c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;), clusters = GeneExpressionMatrix$hash_assignment) Then visualize the most differential TFs by clusters plotBubble(activity_matrix = score.combine, tf = markers.sig$tf, clusters = GeneExpressionMatrix$hash_assignment) Visualize the known differential TFs by violin plot. Note there is no activity calculated for SOX2 because the expression of SOX2 is 0 in all cells. plotActivityViolin(activity_matrix = score.combine, tf = c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;), clusters = GeneExpressionMatrix$hash_assignment) Visualize the known differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine, tf = c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;Clusters&quot;, point_size = 1, ncol = 3) In contrast, the gene expression of the TFs is very sparse plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = counts(GeneExpressionMatrix), tf = c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;Clusters&quot;, point_size = 1, ncol = 3, limit = c(0,2), colors = c(&quot;grey&quot;,&quot;blue&quot;), legend.label = &quot;GEX&quot;) Visualize the gene expression of the regulons by heatmap plotHeatmapRegulon(sce=GeneExpressionMatrix, tfs=c(&quot;GATA6&quot;,&quot;NKX2-1&quot;), regulon=regulon.w, regulon_cutoff=0.1, downsample=1000, cell_attributes=&quot;Clusters&quot;, col_gap=&quot;Clusters&quot;, exprs_values=&quot;counts&quot;, name=&quot;regulon heatmap&quot;) plotHeatmapActivity(activity=score.combine, sce=GeneExpressionMatrix, tfs=rownames(score.combine), downsample=5000, cell_attributes=&quot;Clusters&quot;, col_gap=&quot;Clusters&quot;, name = &quot;Activity&quot;) ### Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot; ) ## Using cached version from 2023-11-16 13:19:17 C2 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C2&quot;, gene.id.type = &quot;SYMBOL&quot; ) ## Using cached version from 2023-11-12 20:06:04 C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot; ) ## Using cached version from 2023-11-16 13:19:24 #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H, C2, C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = c(&quot;GATA6&quot;,&quot;NKX2-1&quot;), regulon = regulon.w, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## GATA6 ## NKX2-1 #plot results enrichPlot(results = enrichresults ) ### Network analysis We can visualize the genesets as a network plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) 2.2.11 Differential networks We are interested in understanding the differential networks between two conditions and determining which transcription factors account for the differences in the topology of networks. The pruned regulons with cluster-specific test statistics computed by pruneRegulon can be used to generate cluster-specific networks based on user-defined cutoffs and to visualize differential networks for transcription factors of interest. In this dataset, the GATA6 gene was only expressed in cluster 1 (C1) and NKX2-1 was only expressed in cluster 3 (C3). If we visualize the target genes of GATA6, we can see that C1 has many more target genes of GATA6 compared to C5, a cluster that does not express GATA6. Similarly, NKX2-1 target genes are confined to C3 which is the only cluster that exogenously expresses NKX2-1. plotDiffNetwork(pruned.regulon, cutoff = 1, tf = c(&quot;GATA6&quot;), weight = &quot;stats&quot;, clusters = c(&quot;C1&quot;,&quot;C5&quot;), layout = &quot;stress&quot;) ## Building graph using weight as edge weights plotDiffNetwork(pruned.regulon, cutoff = 1, tf = c(&quot;NKX2-1&quot;), weight = &quot;stats&quot;, clusters = c(&quot;C3&quot;,&quot;C5&quot;), layout = &quot;stress&quot;) ## Building graph using weight as edge weights We can also visualize how transcription factors relate to other transcription factors in each cluster. selected &lt;- which(pruned.regulon$stats[,&quot;C1&quot;]&gt; 1 &amp; pruned.regulon$tf %in% c(&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;AR&quot;)) C1_network &lt;- buildGraph(pruned.regulon[selected,], weights = &quot;stats&quot;, cluster = &quot;C1&quot;) ## Building graph using stats as edge weights selected &lt;- which(pruned.regulon$stats[,&quot;C5&quot;]&gt; 1 &amp; pruned.regulon$tf %in% c(&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;AR&quot;)) C5_network &lt;- buildGraph(pruned.regulon[selected,], weights = &quot;stats&quot;, cluster = &quot;C5&quot;) ## Building graph using stats as edge weights plotEpiregulonNetwork(C1_network, layout = &quot;sugiyama&quot;, tfs_to_highlight = c(&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;AR&quot;)) + ggplot2::ggtitle (&quot;C1&quot;) plotEpiregulonNetwork(C5_network, layout = &quot;sugiyama&quot;, tfs_to_highlight = c(&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;AR&quot;)) + ggplot2::ggtitle (&quot;C5&quot;) To systematically examine the differential network topology between two clusters, we perform an edge subtraction between two graphs, using weights computed by pruneRegulon. We then calculate the degree centrality of the weighted differential graphs and if desired, normalize the differential centrality against the total number of edges. The default normalization function is sqrt as it preserves both the difference in the number of edges (but scaled by sqrt) and the differences in the weights. If the user only wants to examine the differences in the averaged weights, the FUN argument can be changed to identity. Finally, we rank the transcription factors by (normalized) differential centrality. # rank by differential centrality C1_network &lt;- buildGraph(pruned.regulon, weights = &quot;stats&quot;, cluster=&quot;C1&quot;) ## Building graph using stats as edge weights C5_network &lt;- buildGraph(pruned.regulon, weights = &quot;stats&quot;, cluster=&quot;C5&quot;) ## Building graph using stats as edge weights diff_graph &lt;- buildDiffGraph(C1_network, C5_network) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = head(rank_table, 5), aes(label = tf)) + theme_classic() 2.3 Session Info sessionInfo() ## R version 4.3.0 (2023-04-21) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/local/lib/R/lib/libRblas.so ## LAPACK: /usr/local/lib/R/lib/libRlapack.so; LAPACK version 3.11.0 ## ## Random number generation: ## RNG: L&#39;Ecuyer-CMRG ## Normal: Inversion ## Sample: Rejection ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=C LC_COLLATE=C LC_MONETARY=C ## [6] LC_MESSAGES=C LC_PAPER=C LC_NAME=C LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=C LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] parallel grid stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] igraph_1.5.1 org.Hs.eg.db_3.18.0 nabor_0.5.0 ## [4] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.69.1 rtracklayer_1.61.2 ## [7] BiocIO_1.11.0 Biostrings_2.69.2 XVector_0.41.2 ## [10] DelayedArray_0.27.10 HDF5Array_1.29.3 scMultiome_1.1.2 ## [13] MultiAssayExperiment_1.27.5 ExperimentHub_2.9.1 AnnotationHub_3.9.2 ## [16] BiocFileCache_2.9.1 dbplyr_2.3.4 rhdf5_2.45.1 ## [19] RcppArmadillo_0.12.6.4.0 Rcpp_1.0.11 sparseMatrixStats_1.13.4 ## [22] data.table_1.14.8 stringr_1.5.0 plyr_1.8.9 ## [25] magrittr_2.0.3 gtable_0.3.4 gtools_3.9.4 ## [28] gridExtra_2.3 devtools_2.4.5 usethis_2.1.6 ## [31] ArchR_1.0.3 org.Mm.eg.db_3.18.0 AnnotationDbi_1.63.2 ## [34] msigdbr_7.5.1 epiregulon_1.0.34 scater_1.29.4 ## [37] ggplot2_3.4.4 scuttle_1.11.3 scRNAseq_2.15.0 ## [40] SingleCellExperiment_1.23.0 SummarizedExperiment_1.31.1 Biobase_2.61.0 ## [43] GenomicRanges_1.53.3 GenomeInfoDb_1.37.7 IRanges_2.35.3 ## [46] S4Vectors_0.39.3 BiocGenerics_0.47.1 MatrixGenerics_1.13.2 ## [49] matrixStats_1.0.0 dorothea_1.13.0 bookdown_0.36 ## [52] rmarkdown_2.25 Matrix_1.6-0 ## ## loaded via a namespace (and not attached): ## [1] R.methodsS3_1.8.2 GSEABase_1.63.0 ## [3] progress_1.2.2 urlchecker_1.0.1 ## [5] poweRlaw_0.70.6 vctrs_0.6.3 ## [7] digest_0.6.31 png_0.1-8 ## [9] shape_1.4.6 ggrepel_0.9.4 ## [11] magick_2.8.1 bcellViper_1.37.0 ## [13] MASS_7.3-60 reshape2_1.4.4 ## [15] httpuv_1.6.11 foreach_1.5.2 ## [17] qvalue_2.33.0 withr_2.5.0 ## [19] ggrastr_1.0.2 xfun_0.39 ## [21] ggfun_0.1.3 ellipsis_0.3.2 ## [23] memoise_2.0.1 ggbeeswarm_0.7.2 ## [25] gson_0.1.0 clusterProfiler_4.9.5 ## [27] profvis_0.3.8 tidytree_0.4.5 ## [29] GlobalOptions_0.1.2 KEGGgraph_1.61.0 ## [31] R.oo_1.25.0 prettyunits_1.1.1 ## [33] KEGGREST_1.41.4 promises_1.2.0.1 ## [35] httr_1.4.6 restfulr_0.0.15 ## [37] pak_0.6.0 rhdf5filters_1.13.5 ## [39] ps_1.7.5 rstudioapi_0.15.0 ## [41] miniUI_0.1.1.1 generics_0.1.3 ## [43] DOSE_3.27.3 processx_3.8.1 ## [45] babelgene_22.9 curl_5.0.0 ## [47] zlibbioc_1.47.0 ScaledMatrix_1.9.1 ## [49] ggraph_2.1.0 polyclip_1.10-6 ## [51] GenomeInfoDbData_1.2.11 SparseArray_1.1.12 ## [53] interactiveDisplayBase_1.39.0 pracma_2.4.2 ## [55] xtable_1.8-4 doParallel_1.0.17 ## [57] evaluate_0.21 S4Arrays_1.1.6 ## [59] hms_1.1.3 irlba_2.3.5.1 ## [61] colorspace_2.1-0 filelock_1.0.2 ## [63] reticulate_1.34.0 readr_2.1.4 ## [65] Rgraphviz_2.45.0 later_1.3.1 ## [67] viridis_0.6.4 ggtree_3.9.1 ## [69] lattice_0.22-5 shadowtext_0.1.2 ## [71] XML_3.99-0.14 cowplot_1.1.1 ## [73] pillar_1.9.0 nlme_3.1-163 ## [75] iterators_1.0.14 caTools_1.18.2 ## [77] compiler_4.3.0 beachmat_2.17.17 ## [79] stringi_1.7.12 GenomicAlignments_1.37.0 ## [81] MPO.db_0.99.7 crayon_1.5.2 ## [83] abind_1.4-5 gridGraphics_0.5-1 ## [85] locfit_1.5-9.8 graphlayouts_1.0.1 ## [87] bit_4.0.5 dplyr_1.1.3 ## [89] fastmatch_1.1-4 codetools_0.2-19 ## [91] BiocSingular_1.17.1 bslib_0.5.1 ## [93] GetoptLong_1.0.5 mime_0.12 ## [95] splines_4.3.0 circlize_0.4.15 ## [97] HDO.db_0.99.1 EnrichmentBrowser_2.31.5 ## [99] knitr_1.44 blob_1.2.4 ## [101] utf8_1.2.3 seqLogo_1.67.0 ## [103] clue_0.3-65 BiocVersion_3.18.0 ## [105] AnnotationFilter_1.25.0 fs_1.6.2 ## [107] checkmate_2.2.0 DelayedMatrixStats_1.23.9 ## [109] pkgbuild_1.4.0 GSVA_1.49.8 ## [111] ggplotify_0.1.2 tibble_3.2.1 ## [113] callr_3.7.3 statmod_1.5.0 ## [115] tzdb_0.4.0 tweenr_2.0.2 ## [117] pkgconfig_2.0.3 BSgenome.Hsapiens.UCSC.hg19_1.4.3 ## [119] tools_4.3.0 cachem_1.0.8 ## [121] BSgenome.Mmusculus.UCSC.mm10_1.4.3 RSQLite_2.3.1 ## [123] viridisLite_0.4.2 DBI_1.1.3 ## [125] fastmap_1.1.1 scales_1.2.1 ## [127] Rsamtools_2.17.0 sass_0.4.6 ## [129] patchwork_1.1.3 FNN_1.1.3.2 ## [131] BiocManager_1.30.22 graph_1.79.4 ## [133] farver_2.1.1 scatterpie_0.2.1 ## [135] tidygraph_1.2.3 yaml_2.3.7 ## [137] cli_3.6.1 purrr_1.0.2 ## [139] motifmatchr_1.23.0 lifecycle_1.0.3 ## [141] uwot_0.1.16 bluster_1.11.4 ## [143] sessioninfo_1.2.2 backports_1.4.1 ## [145] BiocParallel_1.35.4 annotate_1.79.0 ## [147] rjson_0.2.21 ape_5.7-1 ## [149] limma_3.57.11 jsonlite_1.8.7 ## [151] edgeR_3.99.6 TFBSTools_1.40.0 ## [153] bitops_1.0-7 HPO.db_0.99.2 ## [155] bit64_4.0.5 yulab.utils_0.1.0 ## [157] BiocNeighbors_1.19.0 CNEr_1.37.0 ## [159] jquerylib_0.1.4 metapod_1.9.0 ## [161] GOSemSim_2.27.3 dqrng_0.3.1 ## [163] R.utils_2.12.2 lazyeval_0.2.2 ## [165] shiny_1.7.5.1 htmltools_0.5.5 ## [167] enrichplot_1.21.3 GO.db_3.18.0 ## [169] rappdirs_0.3.3 ensembldb_2.25.1 ## [171] glue_1.6.2 TFMPvalue_0.0.9 ## [173] RCurl_1.98-1.12 treeio_1.25.4 ## [175] scran_1.29.3 R6_2.5.1 ## [177] tidyr_1.3.0 labeling_0.4.3 ## [179] GenomicFeatures_1.53.3 cluster_2.1.4 ## [181] pkgload_1.3.2 Rhdf5lib_1.23.2 ## [183] aplot_0.2.2 DirichletMultinomial_1.43.0 ## [185] tidyselect_1.2.0 vipor_0.4.5 ## [187] ProtGenerics_1.33.1 ggforce_0.4.1 ## [189] xml2_1.3.5 rsvd_1.0.5 ## [191] munsell_0.5.0 BiocStyle_2.29.2 ## [193] htmlwidgets_1.6.2 fgsea_1.27.1 ## [195] ComplexHeatmap_2.17.0 RColorBrewer_1.1-3 ## [197] biomaRt_2.57.1 rlang_1.1.1 ## [199] remotes_2.4.2 fansi_1.0.4 ## [201] Cairo_1.6-1 beeswarm_0.4.0 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
