# Refinement of gene regulatory network {#refinement}
The `regulon` object constructed in the previous [chapter](#construction) contains all possible links between transcription factors and target genes. As a result, the GRN can be large and may contain some false connections. To refine it, we need to apply filters that retain only those connections supported by our dataset. One such filter has already been applied in the [`calculateP2G` function](#distance_window), which not only searches for regulatory elements within a specified distance from each target gene, but also computes the empirical p-value of the correlation for each target geneâ€“regulatory element pair. Pairs are retained if their p-value is below the threshold specified by the `cutoff_sig` argument.

In this chapter, we introduce three additional filters. The `pruneRegulon` function filters the GRN based on the co-occurrence of TF gene expression, RE chromatin accessibility and target gene expression. The `addMotifScore` function annotates regulons for the presence of motifs. Lastly, the `addLogFC` function calculates changes in gene expression between conditions, so that only target genes showing differential expression are selected.


## Network pruning {#pruning}

Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor ($TF$), regulatory element ($RE$) and target gene ($TG$). The thresholds at which the features are considered expressed are defined by the `peak_cutoff` and `exp_cutoff` arguments. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is $P(TF, RE) \cdot P(TG)$, and the number of trials is the total number of cells (or metacells if we set `aggregateCells=TRUE`), and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also $P(TF, RE) \cdot P(TG)$. The observed cell count for the active category is the number of cells jointly expressing all three elements ($n_{triple}$).


```{r}
pruned.regulon <- pruneRegulon(expMatrix = GeneExpressionMatrix,
                               exp_assay = "normalizedCounts",
                               peakMatrix = PeakMatrix,
                               peak_assay = "counts",
                               regulon = regulon,
                               prune_value = "pval",
                               regulon_cutoff = 0.05)

pruned.regulon[,c("idxATAC", "target", "tf", "corr", "pval", "stats")]
```

### Cell aggregation {#cell_aggregation}

The `pruneRegulon` function also supports aggregation of cells into metacells. This can substantially speed up GRN refinement if the dataset is large (>100K cells). Ideally, cell aggregation should also reduce noise while still maintaining the underlying biological signals. Since the data is less sparse after aggregation, users may want to adjust the feature cutoffs to better differentiate between cell aggregates with low and high expression. Setting `exp_cutoff` and `peak_cutoff` to `NULL` allows `pruneRegulon` to calculate the mean values for each feature and use these as the thresholds.

```{r eval=FALSE}
pruned.regulon.aggr <- pruneRegulon(expMatrix = GeneExpressionMatrix,
                               exp_assay = "normalizedCounts",
                               peakMatrix = PeakMatrix,
                               peak_assay = "counts",
                               regulon = regulon,
                               prune_value = "pval",
                               regulon_cutoff = 0.05,
                               aggregateCells = TRUE,
                               useDim = "LSI_RNA",
                               cellNum = 10,
                               exp_cutoff = NULL,
                               peak_cutoff = NULL)
```

## Annotation with TF motifs {#motif_score}

So far, the gene regulatory network has been constructed exclusively from TF ChIP-seq data. Some users may want to further annotate regulatory elements with motifs. We provide an option to annotate peaks with motifs from the [CIS_BP](https://cisbp.ccbr.utoronto.ca/) database. If no motifs are present for a particular factor (e.g., for co-factors or chromatin modifiers), `NA` is returned. If motifs exist for a factor and the regulatory element contains a motif, `1` is returned; if the regulatory element does not contain a motif, `0` is returned. Users can also provide their own motif annotation through the `pwms` argument.

It is important to note that filtering for the presence of motifs removes a large fraction of the target genes. Motifs are often present in a small subset of the ChIP-seq peaks (can be as low as 10%). Second, indirect TF binding, possibly through its interaction partners, may have a true biological function.


```{r message=FALSE}
pruned.regulon.motif <- addMotifScore(regulon = pruned.regulon,
                                      peaks = rowRanges(PeakMatrix),
                                      species = "human",
                                      genome = "hg38")

# filter out the rows where TF motif is not found in the peak region
pruned.regulon.motif <- pruned.regulon.motif[which(pruned.regulon.motif$motif == 1),]

pruned.regulon.motif[,c("idxATAC", "target", "tf", "corr", "p_val_peak_gene", "pval", "motif")]
```


## Annotating with log fold changes

It is sometimes helpful to filter the regulons based on gene expression changes between two conditions. The `addLogFC` function is a wrapper around `scran::findMarkers` and adds extra columns of log changes to the regulon `DataFrame`. Users can specify the reference group in `logFC_ref` and comparison groups in `logFC_condition`. If these are not provided, log fold changes are calculated for every condition in the cluster labels against the rest of the conditions.
 
```{r}
# create logcounts
GeneExpressionMatrix <- scuttle::logNormCounts(GeneExpressionMatrix)

# add log fold changes which are calculated by taking the difference of the log counts
pruned.regulon <- addLogFC(regulon = pruned.regulon,
                           clusters = GeneExpressionMatrix$cell_type,
                           expMatrix  = GeneExpressionMatrix,
                           assay.type  = "logcounts",
                           pval.type = "any",
                           logFC_condition = unique(GeneExpressionMatrix$cell_type))

pruned.regulon[,c("idxATAC", "target", "tf", "Memory CD8+ T.vs.rest.logFC", "B.vs.rest.FDR")]
```

TFs do not necessarily alter the expression of the genes next to where they bind, and thus filtering for target genes that do show differential expression can help refine the regulons. Since we do not have a defined experimental setup in this dataset, we retain target genes that show differential expression in any cell types vs. the rest.

```{r}
FDR <- pruned.regulon[,grep("rest.FDR", colnames(pruned.regulon ))]
FDR <- as.matrix(FDR) < 0.05
FDR <- apply(FDR,2, as.numeric)

logFC <- pruned.regulon[,grep("rest.logFC", colnames(pruned.regulon ))]
logFC <- abs(as.matrix(logFC)) > 0.3
logFC <- apply(logFC,2, as.numeric)

logFC_FDR <- FDR*logFC

```

```{r}
pruned.regulon.filtered <- pruned.regulon[which(rowSums(logFC_FDR) > 0), ]
```

