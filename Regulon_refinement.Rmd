# Gene regulatory network refinement{#refinement}
The `regulon` object constructed in the previous [chapter](#construction) contains all possible links between transcription factors and target genes. As a result, the GRN can be large and may contain some false connections. To refine it, we need to apply filters that retain only those connections supported by our dataset. One such filter has already been applied in the [`calculateP2G` function](#distance_window), which not only searches for regulatory elements within a specified distance from each target gene, but also computes the empirical p-value of the correlation for each target geneâ€“regulatory element pair. Pairs are retained if their p-value is below the threshold specified by the `cutoff_sig` argument.

In this chapter, we introduce three additional filters. The `pruneRegulon` function filters the GRN based on the co-occurrence of TF gene expression, RE chromatin accessibility and target gene expression. The `addMotifScore` function annotates regulons for the presence of motifs and filter for regions that contain both ChIP-seq peaks and motifs. Lastly, the `addLogFC` function calculates changes in gene expression between conditions, so that only target genes showing gene expression changes are selected.


## Network pruning

Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor ($TF$), regulatory element ($RE$) and target gene ($TG$) vs the expected number of cells if $TF\cdot{RE}$ and $TG$ are independently expressed. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is $P(TF, RE) \cdot P(TG)$, and the number of trials is the total number of cells (or metacells if we set ``), and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also $P(TF, RE) \cdot P(TG)$ and the probability otherwise is $1- P(TF, RE) \cdot P(TG)$. The observed cell count for the active category is the number of cells jointly expressing all three elements ($n_{triple}$), and the cell count for the inactive category is $n - n_{triple}$.


We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section on differential networks.

```{r}
pruned.regulon <- pruneRegulon(expMatrix = GeneExpressionMatrix,
                               exp_assay = "normalizedCounts",
                               peakMatrix = PeakMatrix,
                               peak_assay = "counts",
                               regulon = regulon,
                               prune_value = "pval",
                               regulon_cutoff = 0.05,
                               clusters = GeneExpressionMatrix$cell_type)

pruned.regulon[,c("idxATAC", "target", "tf", "corr", "pval", "stats")]
```

### Cell aggregation {#cell_aggregation}

The `pruneRegulon` function also supports aggregation of cells into metacells, which can be useful when a dataset contains many similar cells with little relevant biological variation. Aggregation reduces noise while preserving the underlying biological signal. The `useDim` argument specifies the name of the low-dimensional representation of the single-cell data stored in the `SingleCellExperiment` object.

```{r}
pruned.regulon.aggr <- pruneRegulon(expMatrix = GeneExpressionMatrix,
                               exp_assay = "normalizedCounts",
                               peakMatrix = PeakMatrix,
                               peak_assay = "counts",
                               regulon = regulon,
                               prune_value = "pval",
                               regulon_cutoff = 0.05,
                               clusters = GeneExpressionMatrix$cell_type,
                               aggregateCells = TRUE,
                               useDim = "LSI_RNA",
                               cellNum = 10)
```

## Annotation with TF motifs

So far, the gene regulatory network has been constructed exclusively from TF ChIP-seq data. Some users may want to further annotate regulatory elements with motifs. We provide an option to annotate peaks with motifs from the [CIS_BP](https://cisbp.ccbr.utoronto.ca/) database. If no motifs are present for a particular factor (e.g., for co-factors or chromatin modifiers), `NA` is returned. If motifs exist for a factor and the regulatory element contains a motif, `1` is returned; if the regulatory element does not contain a motif, `0` is returned. Users can also provide their own motif annotation through the `pwms` argument.


```{r message=FALSE}
pruned.regulon.motif <- addMotifScore(regulon = pruned.regulon,
                                      peaks = rowRanges(PeakMatrix),
                                      species = "human",
                                      genome = "hg38")

# filter out the rows where TF motif is not found in the peak region
pruned.regulon.motif <- pruned.regulon.motif[which(pruned.regulon.motif$motif == 1),]

pruned.regulon.motif[,c("idxATAC", "target", "tf", "corr", "p_val_peak_gene", "pval", "motif")]
```


## Annotate with log fold changes

It is sometimes helpful to filter the regulons based on gene expression changes between two conditions. The `addLogFC` function is a wrapper around `scran::findMarkers` and adds extra columns of log changes to the regulon `DataFrame`. The users can specify the reference condition in `logFC_ref` and conditions for comparison in `logFC_condition`. If these are not provided, log fold changes are calculated for every condition in the cluster labels against the rest of the conditions.
 
```{r}
# create logcounts
GeneExpressionMatrix <- scuttle::logNormCounts(GeneExpressionMatrix)

# add log fold changes which are calculated by taking the difference of the log counts
pruned.regulon <- addLogFC(regulon = pruned.regulon,
                           clusters = GeneExpressionMatrix$cell_type,
                           expMatrix  = GeneExpressionMatrix,
                           assay.type  = "logcounts",
                           pval.type = "any",
                           logFC_condition = c("Memory CD4+ T", "Naive CD8+ T"),
                           logFC_ref = "Naive CD4+ T")

pruned.regulon[,c("idxATAC", "target", "tf", "Memory CD4+ T.vs.Naive CD4+ T.logFC", "Memory CD4+ T.vs.Naive CD4+ T.p.value")]
```

Here we show to use these statistics to filter our regulons.

```{r}
pruned.regulon.filtered <- pruned.regulon[pruned.regulon$"Memory CD4+ T.vs.Naive CD4+ T.FDR" < 0.05 & pruned.regulon$"Memory CD4+ T.vs.Naive CD4+ T.logFC" > 0.3, ]
```

