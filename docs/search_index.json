[["index.html", "Epiregulon documentation Introduction", " Epiregulon documentation Xiaosai Yao, Tomasz Włodarczyk 2025-12-14 Introduction Gene regulatory networks model the underlying gene regulation hierarchies that drive gene expression and cell states. The main function of the epiregulon package is to construct gene regulatory networks and infer transcription factor (TF) activity in single cells by integration of scATAC-seq, scRNA-seq data and bulk TF ChIP-seq data. We consider the co-occurrence of TF expression and chromatin accessibility at TF binding sites in each cell. ChIP-seq data allows motif-agonistic activity inference of transcriptional coregulators or TF harboring neomorphic mutations. Schematics of epiregulon workflow: Main functions of epiregulon: This documentation presents epiregulon v2. Review NEWS file to learn about the changes introduced with the version 2. Check out our publication: Włodarczyk T, Lun A, Wu D, Shi M, Ye X, Menon S, Toneyan S, Seidel K, Wang L, Tan J, Chen S-Y, Keyes T, Chlebowski A, Waddell A, Zhou W, Wang Y, Yuan Q, Guo Y, Chen L-F, Daniel B, Hafner A, He M, Chibly A, Liang Y, Duren Z, Metcalfe C, Hafner M, Siebel C, Corces M. R, Yauch R, Xie S, Yao X (2025) Epiregulon: Single-cell transcription factor activity inference to predict drug response and drivers of cell states. Nature Communications 16: 7118. doi:10.1038/s41467-025-62252-5 "],["installation.html", "1 Installation 1.1 Install from GitHub 1.2 Install from Bioconductor", " 1 Installation 1.1 Install from GitHub All epiregulon components are available on GitHub. There are three separate packages: - epiregulon constructs the GRN. - epiregulon.extra provides tools for visualization, differential TF analysis and network analysis. - epiregulon.archr provides integration with ArchR. # install devtools if(!require(devtools)) install.packages(&quot;devtools&quot;) devtools::install_github(repo=&#39;xiaosaiyao/epiregulon&#39;) devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.extra&#39;) devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.archr&#39;) The data package scMultiome stores ChIP-seq data and pre-processed scMultiome datasets. devtools::install_github(repo=&#39;xiaosaiyao/scMultiome&#39;) 1.2 Install from Bioconductor Epiregulon is now available through Bioconductor. if (!require(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;epiregulon&quot;) BiocManager::install(&quot;epiregulon.extra&quot;) BiocManager::install(&quot;scMultiome&quot;) "],["quick-start.html", "2 Quick start 2.1 Prepare data 2.2 Retrieve bulk TF ChIP-seq binding sites 2.3 Link ATAC-seq peaks to target genes 2.4 Add TF motif binding to peaks 2.5 Generate regulons 2.6 Prune network (recommended) 2.7 Annotate regulon 2.8 Calculate TF activity", " 2 Quick start In this chapter, we illustrate the main steps of the epiregulon workflow. 2.1 Prepare data We need the following components to perform GRN analysis: 1. Peak matrix from scATAC-seq 2. Paired gene expression matrix from scRNA-seq 3. Dimensionality reduction matrix We download an example PBMC dataset from the scMultiome package. # load the MAE object library(scMultiome) library(epiregulon) # Download the example dataset mae &lt;- scMultiome::PBMC_10x() # Load peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # Load expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] Visualize singleCellExperiment by UMAP scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_RNA&quot;, text_by = &quot;cell_type&quot;, colour_by = &quot;cell_type&quot;, point_size = 0.3, point_alpha = 0.3) 2.2 Retrieve bulk TF ChIP-seq binding sites We retrieve a GRangesList object containing the binding sites of transcription factors and co-regulators. These binding sites are derived from bulk ChIP-seq data in the ChIP-Atlas and ENCODE databases. For further information on how these peaks are derived, please refer to ?epiregulon::getTFMotifInfo. Currently, only human genomes hg19 and hg38 and mouse mm10 are supported. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) grl ## GRangesList object of length 1377: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1376 more elements&gt; 2.3 Link ATAC-seq peaks to target genes Next, we link ATAC-seq peaks to their putative target genes. We assign a peak to genes within a size window (default ±250kb) if the chromatin accessibility of the peak and expression of the target genes are highly correlated. To compute correlation, we first create cell aggregates by performing k-means clustering on the reduced dimensionality matrix. To estimate the optimal number of cells per cluster we run optimizeMetacellNumber. set.seed(1010) cellNum &lt;- optimizeMetacellNumber(expMatrix = GeneExpressionMatrix, peakMatrix = PeakMatrix, exp_assay = &quot;normalizedCounts&quot;, peak_assay = &quot;counts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), BPPARAM = BiocParallel::SerialParam(progressbar = FALSE)) cellNum object is then provided as an argument to calculateP2G. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), exp_assay = &quot;normalizedCounts&quot;, peak_assay = &quot;counts&quot;) ## Using epiregulon to compute peak to gene links... ## Creating metacells... ## Looking for regulatory elements near target genes... ## Computing correlations... ## | | | 0% | |=== | 2% | |===== | 5% | |======== | 7% | |=========== | 9% | |============== | 11% | |================ | 14% | |=================== | 16% | |====================== | 18% | |========================= | 20% | |=========================== | 23% | |============================== | 25% | |================================= | 27% | |=================================== | 30% | |====================================== | 32% | |========================================= | 34% | |============================================ | 36% | |============================================== | 39% | |================================================= | 41% | |==================================================== | 43% | |======================================================= | 45% | |========================================================= | 48% | |============================================================ | 50% | |=============================================================== | 52% | |================================================================= | 55% | |==================================================================== | 57% | |======================================================================= | 59% | |========================================================================== | 61% | |============================================================================ | 64% | |=============================================================================== | 66% | |================================================================================== | 68% | |===================================================================================== | 70% | |======================================================================================= | 73% | |========================================================================================== | 75% | |============================================================================================= | 77% | |=============================================================================================== | 80% | |================================================================================================== | 82% | |===================================================================================================== | 84% | |======================================================================================================== | 86% | |========================================================================================================== | 89% | |============================================================================================================= | 91% | |================================================================================================================ | 93% | |=================================================================================================================== | 95% | |===================================================================================================================== | 98% | |========================================================================================================================| 100% ## ## | | | 0% | |======================== | 20% | |================================================ | 40% | |======================================================================== | 60% | |================================================================================================ | 80% | |========================================================================================================================| 100% p2g ## DataFrame with 67644 rows and 10 columns ## idxATAC chr start end idxRNA target Correlation p_val_peak_gene FDR_peak_gene distance ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; ## 1 1 chr1 817086 817586 17 LINC00115 0.487936 0.0397870 0.616636 9934 ## 2 10 chr1 897218 897718 30 HES4 0.464881 0.0456846 0.625393 102261 ## 3 27 chr1 955434 955934 30 HES4 0.552958 0.0248449 0.566187 44045 ## 4 27 chr1 955434 955934 33 AGRN 0.498275 0.0366621 0.603988 64184 ## 5 29 chr1 959712 960212 31 ISG15 -0.398968 0.0247077 0.566187 40924 ## ... ... ... ... ... ... ... ... ... ... ... ## 67640 159255 chrX 154799001 154799501 36414 DKC1 -0.378386 0.0295832 0.578736 36259 ## 67641 159255 chrX 154799001 154799501 36415 MPP1 0.644579 0.0118173 0.506844 5894 ## 67642 159255 chrX 154799001 154799501 36419 F8A1 -0.395646 0.0252025 0.566187 86846 ## 67643 159256 chrX 154800772 154801272 36415 MPP1 0.610599 0.0158884 0.532984 4123 ## 67644 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 0.0257158 0.568362 85075 2.4 Add TF motif binding to peaks We next add the TF binding information by overlapping ATAC peaks with ChIP-seq peaks. The output is a data frame object with three columns: idxATAC - index in the peak matrix idxTF - index in the gene expression matrix corresponding to the transcription factor tf - name of the transcription factor overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) head(overlap) ## idxATAC idxTF tf ## 1 1 16 ATF1 ## 2 1 17 ATF2 ## 3 1 18 ATF3 ## 4 1 21 ATF7 ## 5 1 35 BRCA2 ## 6 1 36 BRD4 2.5 Generate regulons We then generate a DataFrame object representing the inferred regulons, indicating target genes, transcription factors, and regulatory elements. regulon &lt;- getRegulon(p2g = p2g, overlap = overlap) regulon ## DataFrame with 8418612 rows and 12 columns ## idxATAC chr start end idxRNA target corr p_val_peak_gene FDR_peak_gene distance idxTF ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; &lt;integer&gt; ## 1 1 chr1 817086 817586 17 LINC00115 0.487936 0.039787 0.616636 9934 16 ## 2 1 chr1 817086 817586 17 LINC00115 0.487936 0.039787 0.616636 9934 17 ## 3 1 chr1 817086 817586 17 LINC00115 0.487936 0.039787 0.616636 9934 18 ## 4 1 chr1 817086 817586 17 LINC00115 0.487936 0.039787 0.616636 9934 21 ## 5 1 chr1 817086 817586 17 LINC00115 0.487936 0.039787 0.616636 9934 35 ## ... ... ... ... ... ... ... ... ... ... ... ... ## 8418608 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 0.0257158 0.568362 85075 979 ## 8418609 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 0.0257158 0.568362 85075 991 ## 8418610 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 0.0257158 0.568362 85075 1018 ## 8418611 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 0.0257158 0.568362 85075 1020 ## 8418612 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 0.0257158 0.568362 85075 1335 ## tf ## &lt;character&gt; ## 1 ATF1 ## 2 ATF2 ## 3 ATF3 ## 4 ATF7 ## 5 BRCA2 ## ... ... ## 8418608 MNT ## 8418609 NFIA ## 8418610 POLR2A ## 8418611 POLR2AphosphoS5 ## 8418612 ZNF766 2.6 Prune network (recommended) Since our regulons could contain false connections, we apply the pruning function. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05 ) pruned.regulon ## DataFrame with 2754396 rows and 15 columns ## idxATAC chr start end idxRNA target corr p_val_peak_gene FDR_peak_gene distance idxTF ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; &lt;integer&gt; ## 1 135 chr1 1207949 1208449 44 TNFRSF4 0.618308 0.01483209 0.528124 5702 887 ## 2 135 chr1 1207949 1208449 43 TNFRSF18 0.686583 0.00836231 0.498760 2269 887 ## 3 266 chr1 1686177 1686677 86 NADK 0.682560 0.00867039 0.499675 91791 887 ## 4 991 chr1 8947075 8947575 222 CA6 0.581208 0.02000352 0.551146 1207 887 ## 5 1103 chr1 9628994 9629494 233 SLC25A33 -0.545647 0.00456395 0.463887 89529 887 ## ... ... ... ... ... ... ... ... ... ... ... ... ## 2754392 155544 chr22 50524937 50525437 23714 TYMP -0.378229 0.0296565 0.579085 4557 1377 ## 2754393 155577 chr22 50582163 50582663 23714 TYMP -0.365791 0.0335423 0.595442 52167 1377 ## 2754394 155577 chr22 50582163 50582663 23715 ODF3B -0.337503 0.0436050 0.623854 50086 1377 ## 2754395 158053 chrX 106611664 106612164 36005 RADX 0.551794 0.0249989 0.566187 0 1377 ## 2754396 158949 chrX 150547614 150548114 36307 MTM1 0.579942 0.0201796 0.551336 20503 1377 ## tf pval stats qval ## &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 ADNP 3.83812e-09 34.70415 0.0286741 ## 2 ADNP 1.15983e-04 14.85689 1.0000000 ## 3 ADNP 2.14101e-07 26.90142 1.0000000 ## 4 ADNP 2.09927e-03 9.46065 1.0000000 ## 5 ADNP 1.01188e-03 10.80569 1.0000000 ## ... ... ... ... ... ## 2754392 ZXDC 1.93434e-02 5.47020 1 ## 2754393 ZXDC 4.48926e-04 12.31669 1 ## 2754394 ZXDC 6.00511e-03 7.54877 1 ## 2754395 ZXDC 3.72567e-06 21.40105 1 ## 2754396 ZXDC 3.33531e-03 8.61432 1 2.7 Annotate regulon Regulons can be annotated for further refinement. One such metric is the log fold change of gene expression in specified groups. Before running addLogFC function, we need to log-transform gene expression counts. In this example, we are interested in target genes differentially expressed in Naive CD4+ T cells. # add &#39;logcounts&#39; assay GeneExpressionMatrix &lt;- scuttle::logNormCounts(GeneExpressionMatrix) regulon.FC &lt;- addLogFC(expMatrix = GeneExpressionMatrix, clusters = GeneExpressionMatrix$cell_type, regulon = pruned.regulon, pval.type = &quot;any&quot;, sig_type = &quot;FDR&quot;, assay.type = &quot;logcounts&quot;, logFC_condition=c(&#39;Naive CD4+ T&#39;) ) regulon.FC ## DataFrame with 2754396 rows and 17 columns ## idxATAC chr start end idxRNA target corr p_val_peak_gene FDR_peak_gene distance idxTF ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; &lt;integer&gt; ## 1 135 chr1 1207949 1208449 44 TNFRSF4 0.618308 0.01483209 0.528124 5702 887 ## 2 135 chr1 1207949 1208449 43 TNFRSF18 0.686583 0.00836231 0.498760 2269 887 ## 3 266 chr1 1686177 1686677 86 NADK 0.682560 0.00867039 0.499675 91791 887 ## 4 991 chr1 8947075 8947575 222 CA6 0.581208 0.02000352 0.551146 1207 887 ## 5 1103 chr1 9628994 9629494 233 SLC25A33 -0.545647 0.00456395 0.463887 89529 887 ## ... ... ... ... ... ... ... ... ... ... ... ... ## 2754392 155544 chr22 50524937 50525437 23714 TYMP -0.378229 0.0296565 0.579085 4557 1377 ## 2754393 155577 chr22 50582163 50582663 23714 TYMP -0.365791 0.0335423 0.595442 52167 1377 ## 2754394 155577 chr22 50582163 50582663 23715 ODF3B -0.337503 0.0436050 0.623854 50086 1377 ## 2754395 158053 chrX 106611664 106612164 36005 RADX 0.551794 0.0249989 0.566187 0 1377 ## 2754396 158949 chrX 150547614 150548114 36307 MTM1 0.579942 0.0201796 0.551336 20503 1377 ## tf pval stats qval Naive CD4+ T.vs.rest.FDR Naive CD4+ T.vs.rest.logFC ## &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 ADNP 3.83812e-09 34.70415 0.0286741 1.24716e-40 -0.158980 ## 2 ADNP 1.15983e-04 14.85689 1.0000000 2.07408e-28 -0.106426 ## 3 ADNP 2.14101e-07 26.90142 1.0000000 4.93457e-177 -0.402145 ## 4 ADNP 2.09927e-03 9.46065 1.0000000 1.74410e-35 -0.265716 ## 5 ADNP 1.01188e-03 10.80569 1.0000000 5.97271e-65 -0.230591 ## ... ... ... ... ... ... ... ## 2754392 ZXDC 1.93434e-02 5.47020 1 0.00000e+00 -2.3462477 ## 2754393 ZXDC 4.48926e-04 12.31669 1 0.00000e+00 -2.3462477 ## 2754394 ZXDC 6.00511e-03 7.54877 1 9.44166e-179 -0.3415591 ## 2754395 ZXDC 3.72567e-06 21.40105 1 3.21089e-07 0.0323369 ## 2754396 ZXDC 3.33531e-03 8.61432 1 2.88666e-23 0.1631049 We can also annotate regulons for the presence of motifs at each regulatory element. regulon.motif &lt;- addMotifScore(regulon = pruned.regulon, peaks = rowRanges(PeakMatrix), species = &quot;human&quot;, genome = &quot;hg38&quot;) regulon.motif ## DataFrame with 2754396 rows and 16 columns ## idxATAC chr start end idxRNA target corr p_val_peak_gene FDR_peak_gene distance idxTF ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; &lt;integer&gt; ## 1 135 chr1 1207949 1208449 44 TNFRSF4 0.618308 0.01483209 0.528124 5702 887 ## 2 135 chr1 1207949 1208449 43 TNFRSF18 0.686583 0.00836231 0.498760 2269 887 ## 3 266 chr1 1686177 1686677 86 NADK 0.682560 0.00867039 0.499675 91791 887 ## 4 991 chr1 8947075 8947575 222 CA6 0.581208 0.02000352 0.551146 1207 887 ## 5 1103 chr1 9628994 9629494 233 SLC25A33 -0.545647 0.00456395 0.463887 89529 887 ## ... ... ... ... ... ... ... ... ... ... ... ... ## 2754392 155544 chr22 50524937 50525437 23714 TYMP -0.378229 0.0296565 0.579085 4557 1377 ## 2754393 155577 chr22 50582163 50582663 23714 TYMP -0.365791 0.0335423 0.595442 52167 1377 ## 2754394 155577 chr22 50582163 50582663 23715 ODF3B -0.337503 0.0436050 0.623854 50086 1377 ## 2754395 158053 chrX 106611664 106612164 36005 RADX 0.551794 0.0249989 0.566187 0 1377 ## 2754396 158949 chrX 150547614 150548114 36307 MTM1 0.579942 0.0201796 0.551336 20503 1377 ## tf pval stats qval motif ## &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;numeric&gt; ## 1 ADNP 3.83812e-09 34.70415 0.0286741 NA ## 2 ADNP 1.15983e-04 14.85689 1.0000000 NA ## 3 ADNP 2.14101e-07 26.90142 1.0000000 NA ## 4 ADNP 2.09927e-03 9.46065 1.0000000 NA ## 5 ADNP 1.01188e-03 10.80569 1.0000000 NA ## ... ... ... ... ... ... ## 2754392 ZXDC 1.93434e-02 5.47020 1 NA ## 2754393 ZXDC 4.48926e-04 12.31669 1 NA ## 2754394 ZXDC 6.00511e-03 7.54877 1 NA ## 2754395 ZXDC 3.72567e-06 21.40105 1 NA ## 2754396 ZXDC 3.33531e-03 8.61432 1 NA 2.8 Calculate TF activity Finally, activities for a specific TF in each cell are computed by averaging expressions of target genes weighted by the test statistics of choice. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weights_i\\] where \\(y\\) is the activity of a TF for a cell, \\(n\\) is the total number of targets for a TF, \\(x_i\\) is the log count expression of target \\(i\\) where \\(i\\) in {1,2,…,n} and \\(weights_i\\) is the weight of TF - target \\(i\\), calculated by running addWeights function. regulon.w &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;) score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, exp_assay = &quot;normalizedCounts&quot;, normalize = FALSE) score.combine[1:5,1:5] ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## PBMC_10k#GGTTGCATCCTGGCTT-1 PBMC_10k#GGTTGCGGTAAACAAG-1 PBMC_10k#TGTTCCTCATAAGTTC-1 PBMC_10k#CGACTAAGTAACGGGA-1 ## ADNP 0.11379320 0.09052355 0.11310774 0.07767001 ## AEBP2 0.03488950 0.06604866 0.06581493 0.07258739 ## AFF1 0.09373167 0.08967789 0.10807508 0.06184494 ## AFF4 0.11164763 0.10782789 0.13602988 0.07292949 ## AGO1 0.09017644 0.07779564 0.08892206 0.05903171 ## PBMC_10k#CTGCTCCCAAGGTCCT-1 ## ADNP 0.1201884 ## AEBP2 0.0780261 ## AFF1 0.1136837 ## AFF4 0.1392258 ## AGO1 0.0889592 "],["data-preparation.html", "3 Data preparation 3.1 Construct a SingleCellExperiment object 3.2 Start from an ArchR object 3.3 Start from a Seurat/Signac object 3.4 Start from AnnData 3.5 Start from 10x data formats 3.6 Read directly from CSV 3.7 Important points", " 3 Data preparation Epiregulon operates on the SingleCellExperiment class. We assume that gene expression, chromatin accessibility and dimension reduction have been obtained by users’ favorite packages prior to the use of Epiregulon. This chapter provides instructions on how to convert gene expression matrix and peak matrix into SingleCellExperiment objects from other formats including ArchR projects, Seurat objects, AnnData and 10x genomics output. The first section provides a quick primer on the components of a SingleCellExperiment object necessary to run Epiregulon. It is recommended for all users to go through it. 3.1 Construct a SingleCellExperiment object Let’s construct a GeneExpressionMatrix from scratch. First we create the count matrix. library(SingleCellExperiment) counts &lt;- matrix(rpois(100000, lambda = 2), ncol=1000, nrow=100) GeneExpressionMatrix &lt;- SingleCellExperiment(list(counts=counts)) rownames(GeneExpressionMatrix) &lt;- paste(&quot;Gene&quot;,1:100, sep=&quot;-&quot;) colnames(GeneExpressionMatrix) &lt;- paste(&quot;Cell&quot;,1:1000, sep=&quot;-&quot;) It is important (and efficient) to convert the count matrix to dgCMatrix format at the beginning of the workflow. library(Matrix) counts(GeneExpressionMatrix) &lt;- as(counts(GeneExpressionMatrix), &quot;dgCMatrix&quot;) Next we will add the cell information to colData colData(GeneExpressionMatrix) &lt;- DataFrame(Cluster = paste(&quot;cluster&quot;, sample(1:3,1000, TRUE))) For the purpose of Epiregulon, it is important to provide the start and end position of the genes so that we can link genes to the peak regions. seqnames &lt;- paste0(&quot;chr&quot;, sample(1:2, 100, TRUE)) start &lt;- sample(1:100000, 100, TRUE) end &lt;- start + sample(100:500, 100, TRUE) strand &lt;- sample(c(&quot;+&quot;, &quot;-&quot;, &quot;*&quot;), 100, TRUE) gr &lt;- GRanges( seqnames = seqnames, ranges = IRanges(start = start, end = end), strand = strand ) Next we provide additional information about the genes. We can add them into the mcols as DataFrame. The GRanges become the rowRanges of the GeneExpressionMatrix. mcols(gr) &lt;- DataFrame(name = paste(&quot;Gene&quot;, 1:100, sep=&quot;-&quot;), ID = paste0(&quot;ID&quot;, 1:100)) rowRanges(GeneExpressionMatrix) &lt;- gr rowRanges(GeneExpressionMatrix) ## GRanges object with 100 ranges and 2 metadata columns: ## seqnames ranges strand | name ID ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## [1] chr1 84756-84878 * | Gene-1 ID1 ## [2] chr2 62792-63002 - | Gene-2 ID2 ## [3] chr1 70586-71071 * | Gene-3 ID3 ## [4] chr1 40856-41031 + | Gene-4 ID4 ## [5] chr2 34127-34534 - | Gene-5 ID5 ## ... ... ... ... . ... ... ## [96] chr2 91230-91581 * | Gene-96 ID96 ## [97] chr1 45345-45716 - | Gene-97 ID97 ## [98] chr2 86249-86388 + | Gene-98 ID98 ## [99] chr1 51039-51145 - | Gene-99 ID99 ## [100] chr1 57524-57636 - | Gene-100 ID100 ## ------- ## seqinfo: 2 sequences from an unspecified genome; no seqlengths Additional information about the genes will also appear in rowData rowData(GeneExpressionMatrix) ## DataFrame with 100 rows and 2 columns ## name ID ## &lt;character&gt; &lt;character&gt; ## 1 Gene-1 ID1 ## 2 Gene-2 ID2 ## 3 Gene-3 ID3 ## 4 Gene-4 ID4 ## 5 Gene-5 ID5 ## ... ... ... ## 96 Gene-96 ID96 ## 97 Gene-97 ID97 ## 98 Gene-98 ID98 ## 99 Gene-99 ID99 ## 100 Gene-100 ID100 Finally we add some reduced dimension data which is needed for clustering reducedDim(GeneExpressionMatrix, &quot;PCA&quot;) &lt;- matrix(data=rnorm(20000), nrow=1000, ncol=20) GeneExpressionMatrix ## class: SingleCellExperiment ## dim: 100 1000 ## metadata(0): ## assays(1): counts ## rownames: NULL ## rowData names(2): name ID ## colnames: NULL ## colData names(1): Cluster ## reducedDimNames(1): PCA ## mainExpName: NULL ## altExpNames(0): Repeat the process to create a PeakMatrix # add counts counts &lt;- matrix(rpois(1000000, lambda = 1), ncol=1000, nrow=1000) PeakMatrix &lt;- SingleCellExperiment(list(counts=counts)) rownames(PeakMatrix) &lt;- paste(&quot;Peak&quot;,1:1000, sep=&quot;-&quot;) colnames(PeakMatrix) &lt;- paste(&quot;Cell&quot;,1:1000, sep=&quot;-&quot;) # convert count matrix to dgCMatrix counts(PeakMatrix) &lt;- as(counts(PeakMatrix), &quot;dgCMatrix&quot;) # add rowRanges seqnames &lt;- paste0(&quot;chr&quot;, sample(1:2, 1000, TRUE)) start &lt;- sample(1:100000, 1000, TRUE) end &lt;- start + sample(100:500, 1000, TRUE) strand &lt;- sample(c(&quot;+&quot;, &quot;-&quot;, &quot;*&quot;), 1000, TRUE) gr &lt;- GRanges( seqnames = seqnames, ranges = IRanges(start = start, end = end), strand = strand ) # add rowData mcols(gr) &lt;- DataFrame(name = paste(&quot;Peak&quot;, 1:1000, sep=&quot;-&quot;)) rowRanges(PeakMatrix) &lt;- gr # add reduced dimensionality matrix reducedDim(PeakMatrix, &quot;ATAC_LSI&quot;) &lt;- matrix(data=rnorm(20000), nrow=1000, ncol=20) PeakMatrix ## class: SingleCellExperiment ## dim: 1000 1000 ## metadata(0): ## assays(1): counts ## rownames: NULL ## rowData names(1): name ## colnames(1000): Cell-1 Cell-2 ... Cell-999 Cell-1000 ## colData names(0): ## reducedDimNames(1): ATAC_LSI ## mainExpName: NULL ## altExpNames(0): For more information on SingleCellExperiment, please refer to the documentation on bioconductor. For a real example of a properly formatted SingleCellExperiment object, check out datasets from the scMultiome package. Both the GeneExpressionMatrix and PeakMatrix are combined into a MultiAssayExperiment object. mae &lt;- scMultiome::reprogramSeq() Inspect the gene expression matrix GeneExpressMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] GeneExpressMatrix ## class: SingleCellExperiment ## dim: 36438 3903 ## metadata(1): .internal ## assays(2): counts normalizedCounts ## rownames(36438): MIR1302-2HG FAM138A ... IL9R WASIR1 ## rowData names(2): name strand.1 ## colnames(3903): reprogram#TTAGGAACAAGGTACG-1 reprogram#GAGCGGTCAACCTGGT-1 ... reprogram#GGTTACTAGACACCGC-1 ## reprogram#CGCTATGAGTGAACAG-1 ## colData names(23): BlacklistRatio DoubletEnrichment ... ReadsInPeaks FRIP ## reducedDimNames(2): LSI_RNA UMAP_RNA ## mainExpName: NULL ## altExpNames(0): Inspect the peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] PeakMatrix ## class: SingleCellExperiment ## dim: 126602 3903 ## metadata(1): .internal ## assays(1): counts ## rownames: NULL ## rowData names(1): idx ## colnames(3903): reprogram#TTAGGAACAAGGTACG-1 reprogram#GAGCGGTCAACCTGGT-1 ... reprogram#GGTTACTAGACACCGC-1 ## reprogram#CGCTATGAGTGAACAG-1 ## colData names(23): BlacklistRatio DoubletEnrichment ... ReadsInPeaks FRIP ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): 3.2 Start from an ArchR object Epiregulon is designed to work seamlessly with ArchR. GeneExpressionMatrix and PeakMatrix can be easily exported from ArchR using ArchR’s build-in functions. Download a test ArchR project library(ArchR) archr.proj &lt;- getTestProject() Check available matrices in ArchR project getAvailableMatrices(ArchRProj = archr.proj) ## [1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;MotifMatrix&quot; &quot;PeakMatrix&quot; &quot;TileMatrix&quot; Export the GeneExpressionMatrix and PeakMatrix from the ArchR project. GeneExpressionMatrix &lt;- getMatrixFromProject(ArchRProj = archr.proj, useMatrix = &quot;GeneIntegrationMatrix&quot;) PeakMatrix &lt;- getMatrixFromProject(ArchRProj = archr.proj, useMatrix = &quot;PeakMatrix&quot;) GeneExpressionMatrix ## class: SummarizedExperiment ## dim: 2051 127 ## metadata(0): ## assays(1): GeneIntegrationMatrix ## rownames: NULL ## rowData names(6): seqnames start ... name idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un predictedScore_Un PeakMatrix ## class: RangedSummarizedExperiment ## dim: 2142 127 ## metadata(0): ## assays(1): PeakMatrix ## rownames: NULL ## rowData names(1): idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un predictedScore_Un The GeneExpressionMatrix and PeakMatrix exported from ArchR project are in the form of SummarizedExperiment and RangedSummarizedExperiment respectively. We provide a helper function to convert both to SingleCellExperiment class. Furthermore, the genomic location of the genes are transferred from rowData in the RangedSummarizedExperiment to the rowRanges of the SingleCellExperiment. Please note that GeneExpressionMatrix extracted from ArchR project contain normalized counts (not logged) and for clarity, we rename the assay as “normalizedCounts” library(epiregulon.archr) GeneExpressionMatrix &lt;- ArchRMatrix2SCE(rse = GeneExpressionMatrix, rename = &quot;normalizedCounts&quot;) GeneExpressionMatrix ## class: SingleCellExperiment ## dim: 2051 127 ## metadata(0): ## assays(1): normalizedCounts ## rownames: NULL ## rowData names(2): name idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un predictedScore_Un ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): We can also transform the counts to logcounts. This will add a new assay and we name it as “logcounts”. GeneExpressionMatrix &lt;- ArchRMatrix2SCE(rse = GeneExpressionMatrix, transform = TRUE, transform_method = &quot;log&quot;, log_name = &quot;logcounts&quot;) GeneExpressionMatrix ## class: SingleCellExperiment ## dim: 2051 127 ## metadata(0): ## assays(2): counts logcounts ## rownames: NULL ## rowData names(2): name idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un predictedScore_Un ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): Check that rowRanges have been transferred rowRanges(GeneExpressionMatrix) ## GRanges object with 2051 ranges and 2 metadata columns: ## seqnames ranges strand | name idx ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;integer&gt; ## [1] chr11 126987-139152 - | LINC01001 1 ## [2] chr11 193080-194573 + | SCGB1C1 2 ## [3] chr11 196761-200258 + | ODF3 3 ## [4] chr11 202924-207422 - | BET1L 4 ## [5] chr11 208530-215110 + | RIC8A 5 ## ... ... ... ... . ... ... ## [2047] chr5 180551357-180552304 - | OR2V1 827 ## [2048] chr5 180581943-180582890 + | OR2V2 828 ## [2049] chr5 180620924-180632177 - | TRIM7 829 ## [2050] chr5 180650263-180662808 + | TRIM41 830 ## [2051] chr5 180683386-180688119 - | TRIM52 831 ## ------- ## seqinfo: 2 sequences from an unspecified genome; no seqlengths We next convert the PeakMatrix to a SingleCellExperiment object. The counts exported from ArchR are raw counts and thus we rename the assay as “counts” PeakMatrix &lt;- ArchRMatrix2SCE(PeakMatrix, rename = &quot;counts&quot;) PeakMatrix ## class: SingleCellExperiment ## dim: 2142 127 ## metadata(0): ## assays(1): counts ## rownames: NULL ## rowData names(1): idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un predictedScore_Un ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): Neither SummarizedExperiment object or RangedSummarizedExperiment object contains reduced dimension, so we must extract the reduced dimensionality matrix from the ArchR project and add it to GeneExpressionMatrix and/or PeakMatrix reducedDim(PeakMatrix, &quot;IterativeLSI&quot;) &lt;- getReducedDims(ArchRProj = archr.proj, reducedDims = &quot;IterativeLSI&quot;) Refer to ArchR manual for full documentation. 3.3 Start from a Seurat/Signac object We download an example multimodel dataset from SeuratData. devtools::install_github(&#39;satijalab/seurat-data&#39;) library(SeuratData) InstallData(&quot;pbmcMultiome&quot;) This is a PBMC dataset consisting of both RNAseq and ATACseq data and we load each modality as a separate Seurat object library(Seurat) library(Signac) library(SeuratData) pbmc.rna &lt;- LoadData(&quot;pbmcMultiome&quot;, &quot;pbmc.rna&quot;) pbmc.atac &lt;- LoadData(&quot;pbmcMultiome&quot;, &quot;pbmc.atac&quot;) We first convert the RNA Seurat object to GeneExpressionMatrix SingleCellExperiment class. GeneExpressionMatrix &lt;- as.SingleCellExperiment(pbmc.rna, assay=&quot;RNA&quot;) Because these genes are missing genomic positions, we must first annotate them with a genomic database, for example ensembl library(AnnotationHub) ah &lt;- AnnotationHub() edb &lt;- ah[[&quot;AH98047&quot;]] #&quot;EnsDb.Hsapiens.v105&quot; gr &lt;- genes(edb, columns = c(&quot;gene_id&quot;, &quot;gene_name&quot;)) We retain only the genes that have genomic positions. The genomic positions are necessary to link peak positions to the nearby target genes. common_genes &lt;- na.omit(intersect(gr$gene_name, rownames(GeneExpressionMatrix))) GeneExpressionMatrix &lt;- GeneExpressionMatrix[common_genes,] rowRanges(GeneExpressionMatrix) &lt;- gr[match(common_genes, gr$gene_name)] rowRanges(GeneExpressionMatrix) ## GRanges object with 23644 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id gene_name ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## ENSG00000243485 1 29554-31109 + | ENSG00000243485 MIR1302-2HG ## ENSG00000237613 1 34554-36081 - | ENSG00000237613 FAM138A ## ENSG00000186092 1 65419-71585 + | ENSG00000186092 OR4F5 ## ENSG00000284733 1 450740-451678 - | ENSG00000284733 OR4F29 ## ENSG00000284662 1 685716-686654 - | ENSG00000284662 OR4F16 ## ... ... ... ... . ... ... ## ENSG00000228296 Y 25063083-25099892 - | ENSG00000228296 TTTY4C ## ENSG00000223641 Y 25182277-25213389 - | ENSG00000223641 TTTY17C ## ENSG00000228786 Y 25378300-25394719 - | ENSG00000228786 LINC00266-4P ## ENSG00000172288 Y 25622162-25624902 + | ENSG00000172288 CDY1 ## ENSG00000231141 Y 25728490-25733388 + | ENSG00000231141 TTTY3 ## ------- ## seqinfo: 456 sequences (1 circular) from GRCh38 genome We then convert ATAC matrix to PeakMatrix. After conversion to SingleCellExperiment, the peak positions appear as rownames and must be converted to GRanges. PeakMatrix &lt;- as.SingleCellExperiment(pbmc.atac, assay=&quot;ATAC&quot;) peak_position &lt;- strsplit(rownames(PeakMatrix), split = &quot;-&quot;) gr &lt;- GRanges( seqnames = sapply(peak_position,&quot;[&quot;,1), ranges = IRanges(start = as.numeric(sapply(peak_position,&quot;[&quot;,2)), end = as.numeric(sapply(peak_position,&quot;[&quot;,3))) ) rowRanges(PeakMatrix) &lt;- gr PeakMatrix ## class: SingleCellExperiment ## dim: 108377 11909 ## metadata(0): ## assays(2): counts logcounts ## rownames: NULL ## rowData names(0): ## colnames(11909): AAACAGCCAAGGAATC-1 AAACAGCCAATCCCTT-1 ... TTTGTTGGTTGGTTAG-1 TTTGTTGGTTTGCAGA-1 ## colData names(5): orig.ident nCount_ATAC nFeature_ATAC seurat_annotations ident ## reducedDimNames(0): ## mainExpName: ATAC ## altExpNames(0): For more information, refer to Signac tutorial 3.4 Start from AnnData We download an example PBMC anndata dataset from scglue. We first import the GeneExpressionMatrix. library(zellkonverter) library(GenomicRanges) library(SingleCellExperiment) url &lt;- &quot;http://download.gao-lab.org/GLUE/dataset/10x-Multiome-Pbmc10k-RNA.h5ad&quot; destfile &lt;- tempfile(fileext = &quot;.h5ad&quot;) # Download the file download.file(url, destfile, mode = &quot;wb&quot;) GeneExpressionMatrix &lt;- readH5AD(destfile, version=&quot;0.10.6&quot;) The field “chrom” “chromStart” “chromEnd” correspond to genomic positions of the genes. rowData(GeneExpressionMatrix) ## DataFrame with 29095 rows and 26 columns ## gene_ids feature_types genome chrom chromStart chromEnd name score strand thickStart ## &lt;character&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;character&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 ENSG00000238009 Gene Expression GRCh38 chr1 89294 133723 ENSG00000238009 . - . ## AL627309.5 ENSG00000241860 Gene Expression GRCh38 chr1 141473 173862 ENSG00000241860 . - . ## AL627309.4 ENSG00000241599 Gene Expression GRCh38 chr1 160445 161525 ENSG00000241599 . + . ## AP006222.2 ENSG00000286448 Gene Expression GRCh38 chr1 266854 268655 ENSG00000286448 . + . ## AL669831.2 ENSG00000229905 Gene Expression GRCh38 chr1 760910 761989 ENSG00000229905 . + . ## ... ... ... ... ... ... ... ... ... ... ... ## AC004556.3 ENSG00000276345 Gene Expression GRCh38 KI270721.1 2584 11802 ENSG00000276345 . + . ## AC233755.2 ENSG00000277856 Gene Expression GRCh38 KI270726.1 26240 26534 ENSG00000277856 . + . ## AC233755.1 ENSG00000275063 Gene Expression GRCh38 KI270726.1 41443 41876 ENSG00000275063 . + . ## AC007325.1 ENSG00000276017 Gene Expression GRCh38 KI270734.1 72410 74814 ENSG00000276017 . + . ## AC007325.4 ENSG00000278817 Gene Expression GRCh38 KI270734.1 131493 137392 ENSG00000278817 . + . ## thickEnd itemRgb blockCount blockSizes blockStarts gene_type gene_name hgnc_id havana_gene ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 . . . . . lncRNA AL627309.1 NA OTTHUMG00000001096.2 ## AL627309.5 . . . . . lncRNA AL627309.5 NA OTTHUMG00000002480.4 ## AL627309.4 . . . . . lncRNA AL627309.4 NA OTTHUMG00000002525.1 ## AP006222.2 . . . . . lncRNA AP006222.2 NA OTTHUMG00000194680.1 ## AL669831.2 . . . . . lncRNA AL669831.2 NA OTTHUMG00000002408.1 ## ... ... ... ... ... ... ... ... ... ... ## AC004556.3 . . . . . protein_coding AC004556.3 NA NA ## AC233755.2 . . . . . protein_coding AC233755.2 NA NA ## AC233755.1 . . . . . protein_coding AC233755.1 NA NA ## AC007325.1 . . . . . protein_coding AC007325.1 NA NA ## AC007325.4 . . . . . protein_coding AC007325.4 NA NA ## tag n_counts highly_variable highly_variable_rank means variances variances_norm ## &lt;factor&gt; &lt;numeric&gt; &lt;logical&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AL627309.1 overlapping_locus 70 FALSE NaN 0.007268196 0.008462225 0.971895 ## AL627309.5 ncRNA_host 442 FALSE NaN 0.045893469 0.050853072 0.888672 ## AL627309.4 NA 44 FALSE NaN 0.004568581 0.004755865 0.891707 ## AP006222.2 NA 1 FALSE NaN 0.000103831 0.000103831 0.999904 ## AL669831.2 NA 10 FALSE NaN 0.001038314 0.001037343 0.933916 ## ... ... ... ... ... ... ... ... ## AC004556.3 NA 320 FALSE NaN 0.033226041 0.035448356 0.856870 ## AC233755.2 NA 1 FALSE NaN 0.000103831 0.000103831 0.999904 ## AC233755.1 NA 1 FALSE NaN 0.000103831 0.000103831 0.999904 ## AC007325.1 NA 3 FALSE NaN 0.000311494 0.000311429 0.975766 ## AC007325.4 NA 43 FALSE NaN 0.004464749 0.004445277 0.854162 They must be renamed to “seqnames” “start” and “end” before conversion to GRanges index_to_rename &lt;- match(c(&quot;chrom&quot;, &quot;chromStart&quot;, &quot;chromEnd&quot;), colnames(rowData(GeneExpressionMatrix))) colnames(rowData(GeneExpressionMatrix))[index_to_rename] &lt;- c(&quot;seqnames&quot;, &quot;start&quot;, &quot;end&quot;) rowRanges(GeneExpressionMatrix) &lt;- GRanges(rowData(GeneExpressionMatrix)) rowRanges(GeneExpressionMatrix) ## GRanges object with 29095 ranges and 22 metadata columns: ## seqnames ranges strand | gene_ids feature_types genome name score thickStart ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; &lt;factor&gt; &lt;character&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 chr1 89294-133723 - | ENSG00000238009 Gene Expression GRCh38 ENSG00000238009 . . ## AL627309.5 chr1 141473-173862 - | ENSG00000241860 Gene Expression GRCh38 ENSG00000241860 . . ## AL627309.4 chr1 160445-161525 + | ENSG00000241599 Gene Expression GRCh38 ENSG00000241599 . . ## AP006222.2 chr1 266854-268655 + | ENSG00000286448 Gene Expression GRCh38 ENSG00000286448 . . ## AL669831.2 chr1 760910-761989 + | ENSG00000229905 Gene Expression GRCh38 ENSG00000229905 . . ## ... ... ... ... . ... ... ... ... ... ... ## AC004556.3 KI270721.1 2584-11802 + | ENSG00000276345 Gene Expression GRCh38 ENSG00000276345 . . ## AC233755.2 KI270726.1 26240-26534 + | ENSG00000277856 Gene Expression GRCh38 ENSG00000277856 . . ## AC233755.1 KI270726.1 41443-41876 + | ENSG00000275063 Gene Expression GRCh38 ENSG00000275063 . . ## AC007325.1 KI270734.1 72410-74814 + | ENSG00000276017 Gene Expression GRCh38 ENSG00000276017 . . ## AC007325.4 KI270734.1 131493-137392 + | ENSG00000278817 Gene Expression GRCh38 ENSG00000278817 . . ## thickEnd itemRgb blockCount blockSizes blockStarts gene_type gene_name hgnc_id havana_gene ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 . . . . . lncRNA AL627309.1 NA OTTHUMG00000001096.2 ## AL627309.5 . . . . . lncRNA AL627309.5 NA OTTHUMG00000002480.4 ## AL627309.4 . . . . . lncRNA AL627309.4 NA OTTHUMG00000002525.1 ## AP006222.2 . . . . . lncRNA AP006222.2 NA OTTHUMG00000194680.1 ## AL669831.2 . . . . . lncRNA AL669831.2 NA OTTHUMG00000002408.1 ## ... ... ... ... ... ... ... ... ... ... ## AC004556.3 . . . . . protein_coding AC004556.3 NA NA ## AC233755.2 . . . . . protein_coding AC233755.2 NA NA ## AC233755.1 . . . . . protein_coding AC233755.1 NA NA ## AC007325.1 . . . . . protein_coding AC007325.1 NA NA ## AC007325.4 . . . . . protein_coding AC007325.4 NA NA ## tag n_counts highly_variable highly_variable_rank means variances variances_norm ## &lt;factor&gt; &lt;numeric&gt; &lt;logical&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AL627309.1 overlapping_locus 70 FALSE NaN 0.007268196 0.008462225 0.971895 ## AL627309.5 ncRNA_host 442 FALSE NaN 0.045893469 0.050853072 0.888672 ## AL627309.4 NA 44 FALSE NaN 0.004568581 0.004755865 0.891707 ## AP006222.2 NA 1 FALSE NaN 0.000103831 0.000103831 0.999904 ## AL669831.2 NA 10 FALSE NaN 0.001038314 0.001037343 0.933916 ## ... ... ... ... ... ... ... ... ## AC004556.3 NA 320 FALSE NaN 0.033226041 0.035448356 0.856870 ## AC233755.2 NA 1 FALSE NaN 0.000103831 0.000103831 0.999904 ## AC233755.1 NA 1 FALSE NaN 0.000103831 0.000103831 0.999904 ## AC007325.1 NA 3 FALSE NaN 0.000311494 0.000311429 0.975766 ## AC007325.4 NA 43 FALSE NaN 0.004464749 0.004445277 0.854162 ## ------- ## seqinfo: 34 sequences from an unspecified genome; no seqlengths We next import the PeakMatrix. The rownames are already in the format of seqnames:start-end, so rowRanges can be extracted directly from rowData. library(zellkonverter) url &lt;- &quot;http://download.gao-lab.org/GLUE/dataset/10x-Multiome-Pbmc10k-ATAC.h5ad&quot; destfile &lt;- tempfile(fileext = &quot;.h5ad&quot;) # Download the file download.file(url, destfile, mode = &quot;wb&quot;) PeakMatrix &lt;- readH5AD(destfile, version=&quot;0.10.6&quot;) rowRanges(PeakMatrix) &lt;- GRanges(rowData(PeakMatrix)) rowRanges(PeakMatrix) ## GRanges object with 107194 ranges and 3 metadata columns: ## seqnames ranges strand | feature_types genome n_counts ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt; ## chr1:816881-817647 chr1 816881-817647 * | Peaks GRCh38 1025 ## chr1:819912-823500 chr1 819912-823500 * | Peaks GRCh38 1384 ## chr1:825827-825889 chr1 825827-825889 * | Peaks GRCh38 20 ## chr1:826612-827979 chr1 826612-827979 * | Peaks GRCh38 4555 ## chr1:841243-843059 chr1 841243-843059 * | Peaks GRCh38 555 ## ... ... ... ... . ... ... ... ## KI270713.1:20444-22615 KI270713.1 20444-22615 * | Peaks GRCh38 12640 ## KI270713.1:27118-28927 KI270713.1 27118-28927 * | Peaks GRCh38 533 ## KI270713.1:29485-30706 KI270713.1 29485-30706 * | Peaks GRCh38 622 ## KI270713.1:31511-32072 KI270713.1 31511-32072 * | Peaks GRCh38 207 ## KI270713.1:37129-37638 KI270713.1 37129-37638 * | Peaks GRCh38 388 ## ------- ## seqinfo: 32 sequences from an unspecified genome; no seqlengths This example SingleCellExperiment dataset is missing the dimensionality reduction information. Users should have been this precalculated. Refer to the section on how to import from csv files, or refer to OSCA book on how to perform dimensionality reduction. 3.5 Start from 10x data formats 3.5.1 Read from .h5 file We first download the publicly available PBMC data from 10x Genomics url &lt;- &quot;https://cf.10xgenomics.com/samples/cell-arc/1.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5&quot; destfile &lt;- tempfile(fileext = &quot;.h5&quot;) # Download the file download.file(url, destfile, mode = &quot;wb&quot;) This .h5 file contains both genes and peak regions as features, so we read in all the features into a single SingleCellExperiment, and we can specify “Gene Expression” as the main experiment and “Peaks” as the alternative experiment. We then split this single object into 2 separate SingleCellExperiment objects for consistency with other sections. library(DropletUtils) sce10x &lt;- read10xCounts(destfile) sce10x &lt;- splitAltExps(sce10x, f=rowData(sce10x)$Type, ref=&quot;Gene Expression&quot;) peakMatrix &lt;- altExp(sce10x) rowRanges(peakMatrix) &lt;- GRanges(rownames(peakMatrix)) GeneExpressionMatrix &lt;- removeAltExps(sce10x) 3.5.2 Read directly from a 10x directory We can also create a SingleCellExperiment object from a directory containing “matrix.mtx.gz”, “barcodes.tsv.gz” and “features.tsv.gz” example(write10xCounts) list.files(tmpdir) sce10x &lt;- read10xCounts(tmpdir) Refer to the section on Constructing a SingleCellExperiment object on how to construct SingleCellExperiment, add colData, rowData and reduced dimensions. 3.6 Read directly from CSV If the count matrices are in the form of csv files, read in the count matrix as a sparse matrix and convert it to a dgCMatrix. library(SparseArray) counts &lt;- readSparseCSV(&quot;counts.csv&quot;) counts &lt;- as(counts, &quot;dgCMatrix&quot;) Then read in the genomic positions as data.frame and convert it to a GRanges. peak_position &lt;- read.csv(&quot;peaks.csv&quot;) peak_position &lt;- data.frame(peak_position) gr &lt;- GenomicRanges::makeGRangesFromDataFrame(peak_position) Refer to the section on Constructing a SingleCellExperiment object on how to construct SingleCellExperiment, add colData, rowData and reduced dimensions. 3.7 Important points Finally, we would like to emphasize again the importance of converting all count matrices to dgCMatrix for speed and compatibility. Both gene expression and peak matrices require rowRanges to indicate genomic positions of target gene position and peak position. "],["construction.html", "4 Construction of the gene regulatory network 4.1 Download and format dataset 4.2 Retrieve TF occupancy data 4.3 Link ATACseq peaks to target genes 4.4 Add TF occupancy to peaks 4.5 Generate regulons", " 4 Construction of the gene regulatory network This chapter outlines the basic steps for constructing a gene regulatory network, which takes the form of a tripartite graph: TF → RE → TG. In brief, TF occupancy data—derived from either ChIP-seq or motif information—are used to map transcription factors onto genomic regions (here, ATAC-seq peaks). These regions are then linked to their target genes by leveraging the assumption that chromatin accessibility and gene expression are highly correlated. 4.1 Download and format dataset We will make use of the PBMC data set from 10x Genomics. The MAE object was uploaded to scMultiome for full reproducibility. # Download the example dataset mae &lt;- scMultiome::PBMC_10x() # Load peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # Load expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] Visualize the data. scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_RNA&quot;, text_by = &quot;cell_type&quot;, colour_by = &quot;cell_type&quot;, point_size = 0.3, point_alpha = 0.3) 4.2 Retrieve TF occupancy data We recommend using ChIP-seq data—rather than motifs—as the proxy for TF occupancy. The gold standard in the field is to use sample-matched ChIP-seq for TF binding. To support this, we provide both sample-specific and tissue-specific ChIP-seq peak sets. However, sample-matched or tissue-matched ChIP-seq data are not available for many factors. To address this, we include a set of pan-tissue ChIP-seq peaks, generated by merging data across multiple samples and lineages; this serves as the default TF occupancy source. Benchmarking in our manuscript demonstrates that pan-tissue ChIP-seq still outperforms motif-based annotations for TF activity inference and target-gene recovery. In addition, ChIP-seq offers a key advantage over motifs in enabling GRN inference for transcriptional co-regulators that lack known motifs. One limitation of ChIP-seq–based occupancy is that its accuracy depends on the underlying experimental quality. We applied several quality-control filters to the ChIP-seq data included (see Methods in the manuscript), but some factors still exhibit very large numbers of binding sites (&gt;100k). This may reflect true biology or simply false positives. In such cases, filtering TF occupancy based on the intersection of ChIP-seq peaks and motif sites (see next chapter) can be helpful. 4.2.1 ChIP-seq data We retrieve a GRangesList object containing the binding sites of all the transcription factors and co-regulators. These binding sites are derived from bulk ChIP-seq data in the ChIP-Atlas and ENCODE databases, and merged across multiple cell lines or tissues. Currently, human genomes hg19 and hg38 and mouse mm10 are supported. All ChIP-seq and motif binding sites are hosted on ExperimentHub. The initial download may take some time, but the data are cached for subsequent use. library(epiregulon) grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; For both ChIP-Atlas and ENCODE data, we also provide sample-specific TF binding sites. They are retrieved as a list of GrangesList objects, by specifying atlas.sample or encode.sample in the source argument. grl_list_sample_atlas &lt;- getTFMotifInfo(genome = &quot;hg38&quot;, source = &quot;atlas.sample&quot;) head(names(grl_list_sample_atlas)) ## [1] &quot;ML-2&quot; &quot;hTERT RPE-1&quot; &quot;DLD-1&quot; &quot;293&quot; &quot;HeLa&quot; &quot;MCF-7&quot; Then we need to access a specific list element by providing the sample of interest. Here we choose \"Peripheral blood mononuclear cells\". grl_list_sample_atlas[[&quot;Peripheral blood mononuclear cells&quot;]] ## GRangesList object of length 2: ## $EZH2 ## GRanges object with 14399 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9949-10539 * ## [2] chr1 28949-29442 * ## [3] chr1 180750-181044 * ## [4] chr1 199296-200054 * ## [5] chr1 629280-630005 * ## ... ... ... ... ## [14395] chrUn_KI270435v1 91984-92197 * ## [14396] chrUn_KI270512v1 252-395 * ## [14397] chr15_KI270727v1_ran.. 80081-80345 * ## [14398] chr1_KI270706v1_random 165426-165601 * ## [14399] chrUn_KI270743v1 152955-153105 * ## ------- ## seqinfo: 89 sequences from an unspecified genome; no seqlengths ## ## $HIF1A ## GRanges object with 2199 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 10009-10248 * ## [2] chr1 10359-10460 * ## [3] chr1 180748-180991 * ## [4] chr1 631239-631293 * ## [5] chr1 631989-632060 * ## ... ... ... ... ## [2195] chrY 56826777-56826855 * ## [2196] chrY 56847169-56847217 * ## [2197] chrY 56850383-56850460 * ## [2198] chrY 56850790-56850873 * ## [2199] chrY 56851105-56851159 * ## ------- ## seqinfo: 89 sequences from an unspecified genome; no seqlengths Alternatively, we might retrieve chip-seq data for \"K562\" cells present in the ENCODE database. grl_list_sample_encode &lt;- getTFMotifInfo(genome = &quot;hg38&quot;, source = &quot;encode.sample&quot;) grl_list_sample_encode[[&quot;K562&quot;]] ## GRangesList object of length 468: ## $PYGO2 ## GRanges object with 6664 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr3 3110104-3110423 * ## [2] chr3 4225236-4225599 * ## [3] chr3 4350776-4351095 * ## [4] chr3 4467164-4467483 * ## [5] chr3 4533816-4534135 * ## ... ... ... ... ## [6660] chr13 99053615-99053934 * ## [6661] chr13 109707096-109707415 * ## [6662] chr13 110874168-110874531 * ## [6663] chr13 110963556-110963834 * ## [6664] chr13 112711615-112711978 * ## ------- ## seqinfo: 54 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;467 more elements&gt; The tissue-specific chip-seq data are also available. They were compiled from the ChIP-Atlas database. grl_list_tissue &lt;- getTFMotifInfo(genome = &quot;hg38&quot;, source = &quot;atlas.tissue&quot;) grl_list_tissue[[&quot;Blood&quot;]] ## GRangesList object of length 770: ## $`MLL-AF6` ## GRanges object with 477 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 4303013-4303150 * ## [2] chr1 71928076-71928393 * ## [3] chr1 87300735-87300856 * ## [4] chr1 91387234-91387457 * ## [5] chr1 108771977-108772126 * ## ... ... ... ... ## [473] chrY 56838883-56839022 * ## [474] chrY 56843654-56843767 * ## [475] chrY 56848774-56848878 * ## [476] chrY 56850362-56850481 * ## [477] chrY 56851423-56851611 * ## ------- ## seqinfo: 183 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;769 more elements&gt; The advantage of using tissue- or sample-specific ChIP-seq data is that they accurately reflect TF binding sites that are characteristic of a given cell type or cell line. The downside is the small number of factors and peaks due to the limited number of experiments used to compile the data. # calculate the total number of factors contained in each grl # pan-tissue length(grl) ## [1] 1558 # blood tissue length(grl_list_tissue[[&quot;Blood&quot;]]) ## [1] 770 # Peripheral blood mononuclear cells sample length(grl_list_sample_atlas[[&quot;Peripheral blood mononuclear cells&quot;]]) ## [1] 2 # K562 cell line sample length(grl_list_sample_encode[[&quot;K562&quot;]]) ## [1] 468 # calculate the total number of regions contained in each grl # pan-tissue format(sum(unlist(lapply(grl, length))), big.mark=&quot;,&quot;) ## [1] &quot;54,501,169&quot; # blood tissue format(sum(unlist(lapply(grl_list_tissue[[&quot;Blood&quot;]], length))), big.mark=&quot;,&quot;) ## [1] &quot;18,684,867&quot; # Peripheral blood mononuclear cells sample format(sum(unlist(lapply(grl_list_sample_atlas[[&quot;Peripheral blood mononuclear cells&quot;]], length))), big.mark=&quot;,&quot;) ## [1] &quot;16,598&quot; # K562 cell line sample format(sum(unlist(lapply(grl_list_sample_encode[[&quot;K562&quot;]], length))), big.mark=&quot;,&quot;) ## [1] &quot;6,352,422&quot; Lastly, users can always supply their custom ChIP-seq data and convert them into GrangesList. 4.2.2 Motif information While ChIP-seq data provide experimentally determined TF biding sites, some users might prefer to start from motif sequences as positions of TF occupancy. If motif is chosen for mode, getTFMotifInfo retrieves the motif information from the CIS_BP database and scans the peak regions for presence of motifs. grl_motif &lt;- getTFMotifInfo(genome = &quot;hg38&quot;, mode = &quot;motif&quot;, peaks = rowRanges(PeakMatrix)) 4.3 Link ATACseq peaks to target genes Next, we link ATAC-seq peaks to their putative target genes. We assign a peak to a gene if it falls within a size window (default ±250kb) and if the chromatin accessibility of the peak and expression of the target gene is highly correlated across cell aggregates. To calculate correlations, we create cell aggregates (or metacells) by performing deterministic k-means clustering on the reduced dimensionality matrix (for description of the algorithm description, see https://ltla.github.io/CppKmeans/classkmeans_1_1InitializeVariancePartition.html. Then we aggregate the counts for the gene expression and peak matrices and normalize them by the number of cells. Correlations are thus computed on the averaged gene expression and chromatin accessibility. 4.3.1 Optimize the number of metacells (optional) It is important to pick the correct value for the cellNum parameter, which controls the number of metacells used for aggregation. Too few metacells can obscure biologically meaningful variation, while overly fine-grained aggregation may fail to sufficiently stabilize the signal, leaving substantial noise arising from data sparsity, technical bias, or biologically irrelevant fluctuations. In practice, we aim to strike a balance between these extremes and identify an optimal metacell number. This is the motivation behind the introduction of the new function optimizeMetacellNumber, released with epiregulon v2.0.0. The function computes mean empirical p-values across a range of metacell numbers, then fits a quadratic model that regresses these p-values against the square root of the mean number of cells per metacell. Squaring the value of \\(x_{min}\\) yields the estimated optimal mean number of cells per metacell. set.seed(1010) cellNum &lt;- optimizeMetacellNumber(expMatrix = GeneExpressionMatrix, peakMatrix = PeakMatrix, exp_assay = &quot;normalizedCounts&quot;, peak_assay = &quot;counts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), BPPARAM = BiocParallel::SerialParam(progressbar = FALSE)) cellNum ## A CellNumSol object. ## Estimated optimal number of cells per cluster: 447.01 ## Evaluation points: 4.47213595499958, 11.1403077174484, 14.4743935986728, 17.8084794798972, 21.1425653611216, 24.4766512423461, 27.8107371235705, 31.1448230047949 ## Mean p-values: 0.47119290983881, 0.462715427201451, 0.462501891217645, 0.464072311510151, 0.462019850925825, 0.465810140254992, 0.465848907466871, 0.463170513939028 We can check specifically the estimated optimal number of cells per cluster (mean metacell size) by computing the square of the solution slot. cellNum@solution^2 ## [1] 447.0081 The plot function allows for visualization of the function performance at different evaluation points. The estimated optimum is marked by a red dashed line. plot(cellNum) The object returned by optimizeMetacellNumber can be passed to calculateP2G as the cellNum parameter. User might also provide a numeric to directly set the mean number of cells per cluster. 4.3.2 Find peak-target gene links within a defined distance The default method for linking regulatory elements to target genes is to compute correlations at the metacell level. A null distribution is generated by correlating randomly selected peak–gene pairs located on different chromosomes. Correlations are then calculated for all peak–gene pairs within a specified genomic distance (default ±250 kb). By default, only links with a p-value &lt; 0.05 are retained, although this behavior can be modified via the cutoff_sig argument. Although the algorithm for identifying metacell clusters is deterministic, reproducibility still requires setting a random seed because the null distribution is estimated from randomly sampled peak–gene pairs. To reduce the stochasticity introduced by this random sampling, one may increase the nRandConn parameter, which controls the number of random connections drawn. If cluster labels are provided, peak–gene correlations are also computed within each cluster. A peak–gene link is retained if it passes the p-value threshold in any cluster. The resulting expanded list of links captures both inter- and intra-cluster variation. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), cellNum = cellNum, BPPARAM = BiocParallel::SerialParam(progressbar = FALSE)) ## Using epiregulon to compute peak to gene links... ## Creating metacells... ## Looking for regulatory elements near target genes... ## Computing correlations... p2g ## DataFrame with 73073 rows and 10 columns ## idxATAC chr start end idxRNA target Correlation p_val_peak_gene FDR_peak_gene distance ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; ## 1 7 chr1 860832 861332 16 FAM87B 0.854753 0.00984755 0.476024 43461 ## 2 9 chr1 869608 870108 20 AL645608.6 -0.540742 0.04212981 0.571132 34724 ## 3 13 chr1 904517 905017 18 LINC01128 0.722237 0.03621755 0.550509 76919 ## 4 23 chr1 941054 941554 29 AL645608.7 -0.585016 0.02718616 0.524680 56495 ## 5 27 chr1 955434 955934 29 AL645608.7 0.697603 0.04456119 0.577848 42115 ## ... ... ... ... ... ... ... ... ... ... ... ## 73069 159273 chrX 155094423 155094923 36424 VBP1 0.782766 0.02117841 0.503759 102082 ## 73070 159278 chrX 155216170 155216670 36424 VBP1 0.744842 0.02974866 0.531715 19163 ## 73071 159279 chrX 155242243 155242743 36426 CLIC2 0.815972 0.01512155 0.486993 91869 ## 73072 159283 chrX 155334892 155335392 36426 CLIC2 0.945613 0.00168933 0.400879 278 ## 73073 159285 chrX 155611289 155611789 36434 TMLHE 0.852475 0.01009477 0.476024 1086 4.3.3 Link peaks to the nearest genes Alternatively, we can identify the downstream targets of each regulatory region by assigning them to their nearest gene. The maxDist argument specifies the maximum allowed distance between a regulatory element and a gene for a link to be made. As before, correlations are computed and only those exceeding the threshold are retained. set.seed(1010) p2g_nearest &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), assignment_method = &quot;nearest&quot;, BPPARAM = BiocParallel::SerialParam(progressbar = FALSE) ) ## Using epiregulon to compute peak to gene links... ## Creating metacells... ## Looking for regulatory elements near target genes... ## Computing correlations... 4.3.4 Filter peak-target gene links The number of possible links between target genes and regulatory elements can be large. Therefore, we need to reduce this number, keeping only those links for which we have support in our data. By default, calculateP2G uses a p-value threshold to pinpoint putative connections between target genes and regulatory regions. However, users may also choose to use FDR or rely directly on the correlation. This behavior is controlled by the cutoff_stat argument. If Correlation is specified, the default threshold of 0.5 is used, as defined by cor_cutoff. Note that only links with correlation greater than this threshold will be kept, potentially ignoring meaningful highly negative correlations. Additionally, the correlation distribution might vary with dataset size, resulting in different FDRs for the same correlation threshold. Threshold for p_val and FDR is set by the cutoff_sig argument. 4.4 Add TF occupancy to peaks The next step is to add TF binding information to peak regions. overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) head(overlap) ## idxATAC idxTF tf ## 711 7 12 ARID5B ## 712 7 91 ELF3 ## 713 7 150 HEY1 ## 714 7 159 HNF4A ## 715 7 160 HNF4G ## 716 7 217 MAX 4.5 Generate regulons A DataFrame, representing the inferred regulons, is then generated. The DataFrame object consists of the following columns: idxATAC - index of the peak in the peak matrix chr - chromosome number start - start position of the peak end - end position of the peak idxRNA - index in the gene expression matrix corresponding to the target gene target - name of the target gene corr - correlation between target gene expression and the chromatin accessibility at the peak. If cluster labels are provided, this field is a matrix with columns names corresponding to correlation across all cells and for each of the clusters. p_val_peak_gene - empirical p-value of the correlation between peak and target gene. If cluster labels are provided, this field is a matrix with columns names corresponding to p-value for all cells and for each of the clusters. FDR_peak_gene - false discovery rates calculated based on the empirical p-value of the correlations between peaks and target genes. If cluster labels are provided, this field is a matrix with columns names corresponding to FDR for all cells and for each of the clusters. distance - distance between the transcription start site of the target gene and the middle of the peak idxTF - index in the gene expression matrix corresponding to the transcription factor tf - name of the transcription factor regulon &lt;- getRegulon(p2g, overlap, aggregate=FALSE) regulon ## DataFrame with 9563289 rows and 12 columns ## idxATAC chr start end idxRNA target corr p_val_peak_gene FDR_peak_gene distance idxTF ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; &lt;integer&gt; ## 1 7 chr1 860832 861332 16 FAM87B 0.854753 0.00984755 0.476024 43461 12 ## 2 7 chr1 860832 861332 16 FAM87B 0.854753 0.00984755 0.476024 43461 91 ## 3 7 chr1 860832 861332 16 FAM87B 0.854753 0.00984755 0.476024 43461 150 ## 4 7 chr1 860832 861332 16 FAM87B 0.854753 0.00984755 0.476024 43461 159 ## 5 7 chr1 860832 861332 16 FAM87B 0.854753 0.00984755 0.476024 43461 160 ## ... ... ... ... ... ... ... ... ... ... ... ... ## 9563285 159285 chrX 155611289 155611789 36434 TMLHE 0.852475 0.0100948 0.476024 1086 348 ## 9563286 159285 chrX 155611289 155611789 36434 TMLHE 0.852475 0.0100948 0.476024 1086 360 ## 9563287 159285 chrX 155611289 155611789 36434 TMLHE 0.852475 0.0100948 0.476024 1086 432 ## 9563288 159285 chrX 155611289 155611789 36434 TMLHE 0.852475 0.0100948 0.476024 1086 630 ## 9563289 159285 chrX 155611289 155611789 36434 TMLHE 0.852475 0.0100948 0.476024 1086 785 ## tf ## &lt;character&gt; ## 1 ARID5B ## 2 ELF3 ## 3 HEY1 ## 4 HNF4A ## 5 HNF4G ## ... ... ## 9563285 SMARCC1 ## 9563286 SPI1 ## 9563287 ZBTB7A ## 9563288 GFP ## 9563289 MYH11 "],["refinement.html", "5 Refinement of gene regulatory network 5.1 Prune network 5.2 Annotate with TF motifs 5.3 Annotate with log fold changes", " 5 Refinement of gene regulatory network The regulon object constructed in the previous chapter contains all possible links between transcription factors and target genes. As a result, the GRN can be large and may contain some false connections. To refine it, we need to apply filters that retain only those connections supported by our dataset. One such filter has already been applied in the calculateP2G function, which not only searches for regulatory elements within a specified distance from each target gene, but also computes the empirical p-value of the correlation for each target gene–regulatory element pair. Pairs are retained if their p-value is below the threshold specified by the cutoff_sig argument. In this chapter, we introduce three additional filters. The pruneRegulon function filters the GRN based on the co-occurrence of TF gene expression, RE chromatin accessibility and target gene expression. The addMotifScore function annotates regulons for the presence of motifs. Lastly, the addLogFC function calculates changes in gene expression between conditions, so that only target genes showing differential expression are selected. 5.1 Prune network Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (\\(TF\\)), regulatory element (\\(RE\\)) and target gene (\\(TG\\)). The thresholds at which the features are considered expressed are defined by the peak_cutoff and exp_cutoff arguments. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is \\(P(TF, RE) \\cdot P(TG)\\), and the number of trials is the total number of cells (or metacells if we set aggregateCells=TRUE), and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also \\(P(TF, RE) \\cdot P(TG)\\). The observed cell count for the active category is the number of cells jointly expressing all three elements (\\(n_{triple}\\)). pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, regulon = regulon, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05) pruned.regulon[,c(&quot;idxATAC&quot;, &quot;target&quot;, &quot;tf&quot;, &quot;corr&quot;, &quot;pval&quot;, &quot;stats&quot;)] ## DataFrame with 2575700 rows and 6 columns ## idxATAC target tf corr pval stats ## &lt;integer&gt; &lt;array&gt; &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 135 TNFRSF18 ADNP 0.796526 1.15983e-04 14.85689 ## 2 266 NADK ADNP 0.789720 2.14101e-07 26.90142 ## 3 491 AL139246.3 ADNP -0.528735 1.98772e-02 5.42265 ## 4 991 CA6 ADNP 0.863810 2.09927e-03 9.46065 ## 5 1103 SLC25A33 ADNP -0.834313 1.01188e-03 10.80569 ## ... ... ... ... ... ... ... ## 2575696 155577 SCO2 ZXDC -0.548795 3.06126e-02 4.67456 ## 2575697 155577 TYMP ZXDC -0.560573 4.48926e-04 12.31669 ## 2575698 155577 ODF3B ZXDC -0.549052 6.00511e-03 7.54877 ## 2575699 157674 OGT ZXDC 0.694312 1.01153e-02 6.61447 ## 2575700 158053 RADX ZXDC 0.727684 3.72567e-06 21.40105 5.1.1 Aggregate cells The pruneRegulon function also supports aggregation of cells into metacells. This can substantially speed up GRN refinement if the dataset is large (&gt;100K cells). Ideally, cell aggregation should also reduce noise while still maintaining the underlying biological signals. Since the data is less sparse after aggregation, users may want to adjust the feature cutoffs to better differentiate between cell aggregates with low and high expression. Setting exp_cutoff and peak_cutoff to NULL allows pruneRegulon to calculate the mean values for each feature and use these as the thresholds. pruned.regulon.aggr &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, regulon = regulon, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05, aggregateCells = TRUE, useDim = &quot;LSI_RNA&quot;, cellNum = 10, exp_cutoff = NULL, peak_cutoff = NULL) 5.2 Annotate with TF motifs So far, the gene regulatory network has been constructed exclusively from TF ChIP-seq data. Some users may want to further annotate regulatory elements with motifs. We provide an option to annotate peaks with motifs from the CIS_BP database. If no motifs are present for a particular factor (e.g., for co-factors or chromatin modifiers), NA is returned. If motifs exist for a factor and the regulatory element contains a motif, 1 is returned; if the regulatory element does not contain a motif, 0 is returned. Users can also provide their own motif annotation through the pwms argument. It is important to note that filtering for the presence of motifs removes a large fraction of the target genes. Motifs are often present in a small subset of the ChIP-seq peaks (can be as low as 10%). Second, indirect TF binding, possibly through its interaction partners, may have a true biological function. pruned.regulon.motif &lt;- addMotifScore(regulon = pruned.regulon, peaks = rowRanges(PeakMatrix), species = &quot;human&quot;, genome = &quot;hg38&quot;) # filter out the rows where TF motif is not found in the peak region pruned.regulon.motif &lt;- pruned.regulon.motif[which(pruned.regulon.motif$motif == 1),] pruned.regulon.motif[,c(&quot;idxATAC&quot;, &quot;target&quot;, &quot;tf&quot;, &quot;corr&quot;, &quot;p_val_peak_gene&quot;, &quot;pval&quot;, &quot;motif&quot;)] ## DataFrame with 192760 rows and 7 columns ## idxATAC target tf corr p_val_peak_gene pval motif ## &lt;integer&gt; &lt;array&gt; &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;numeric&gt; ## 1 199 ACAP3 AHR -0.628315 0.01717839 2.44093e-02 1 ## 2 723 TNFRSF25 AHR 0.771313 0.02373300 3.79686e-08 1 ## 3 1100 SLC25A33 AHR -0.726697 0.00437233 2.41562e-08 1 ## 4 3937 RNF19B AHR -0.715055 0.00534396 1.14941e-02 1 ## 5 4494 PPT1 AHR 0.718666 0.03720643 2.44180e-05 1 ## ... ... ... ... ... ... ... ... ## 192756 157055 CFP ZSCAN16 0.829179 0.0130202 0.009152565 1 ## 192757 33086 GTPBP8 ZSCAN4 0.773445 0.0230119 0.000171032 1 ## 192758 40337 PYURF ZSCAN4 0.701525 0.0431397 0.019287955 1 ## 192759 104541 ZNF84 ZSCAN4 0.745546 0.0295838 0.034884124 1 ## 192760 115841 PARP16 ZSCAN4 0.687043 0.0487639 0.003539738 1 5.3 Annotate with log fold changes It is sometimes helpful to filter the regulons based on gene expression changes between two conditions. The addLogFC function is a wrapper around scran::findMarkers and adds extra columns of log changes to the regulon DataFrame. Users can specify the reference group in logFC_ref and comparison groups in logFC_condition. If these are not provided, log fold changes are calculated for every condition in the cluster labels against the rest of the conditions. # create logcounts GeneExpressionMatrix &lt;- scuttle::logNormCounts(GeneExpressionMatrix) # add log fold changes which are calculated by taking the difference of the log counts pruned.regulon &lt;- addLogFC(regulon = pruned.regulon, clusters = GeneExpressionMatrix$cell_type, expMatrix = GeneExpressionMatrix, assay.type = &quot;logcounts&quot;, pval.type = &quot;any&quot;, logFC_condition = unique(GeneExpressionMatrix$cell_type)) pruned.regulon[,c(&quot;idxATAC&quot;, &quot;target&quot;, &quot;tf&quot;, &quot;Memory CD8+ T.vs.rest.logFC&quot;, &quot;B.vs.rest.FDR&quot;)] ## DataFrame with 2575700 rows and 5 columns ## idxATAC target tf Memory CD8+ T.vs.rest.logFC B.vs.rest.FDR ## &lt;integer&gt; &lt;array&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 135 TNFRSF18 ADNP -0.0906689 2.12607e-23 ## 2 266 NADK ADNP -0.3582261 1.86039e-71 ## 3 491 AL139246.3 ADNP -0.0156938 2.86752e-02 ## 4 991 CA6 ADNP -0.3802831 2.38300e-91 ## 5 1103 SLC25A33 ADNP -0.2311624 5.77745e-26 ## ... ... ... ... ... ... ## 2575696 155577 SCO2 ZXDC -0.6694588 1.26531e-315 ## 2575697 155577 TYMP ZXDC -2.3157151 0.00000e+00 ## 2575698 155577 ODF3B ZXDC -0.3380033 2.16867e-129 ## 2575699 157674 OGT ZXDC 0.5698316 3.41241e-56 ## 2575700 158053 RADX ZXDC 0.0456558 1.51853e-04 TFs do not necessarily alter the expression of the genes next to where they bind, and thus filtering for target genes that do show differential expression can help refine the regulons. Since we do not have a defined experimental setup in this dataset, we retain target genes that show differential expression in any cell types vs. the rest. FDR &lt;- pruned.regulon[,grep(&quot;rest.FDR&quot;, colnames(pruned.regulon ))] FDR &lt;- as.matrix(FDR) &lt; 0.05 FDR &lt;- apply(FDR,2, as.numeric) logFC &lt;- pruned.regulon[,grep(&quot;rest.logFC&quot;, colnames(pruned.regulon ))] logFC &lt;- abs(as.matrix(logFC)) &gt; 0.3 logFC &lt;- apply(logFC,2, as.numeric) logFC_FDR &lt;- FDR*logFC pruned.regulon.filtered &lt;- pruned.regulon[which(rowSums(logFC_FDR) &gt; 0), ] "],["calculation-of-the-tf-activity.html", "6 Calculation of the TF activity 6.1 Add weights 6.2 Calculate TF activity", " 6 Calculation of the TF activity Once we define the target genes of TFs by constructing the GRN, we can calculate the per cell TF activity by summing up the expression of the individual target genes. While it is reasonable to assume equal contribution from each target genes, epiregulon tries to estimate the weights of each target gene. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. 6.1 Add weights Epiregulon estimates the regulatory potential using one of the three measures: Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs. cells that do not. Correlation between TG and TF, or between TG and the product of TF and RE. Mutual information between TG and TF expression, or between TG and the product of TF and RE. Wilcoxon and correlation methods give both the magnitude and directionality of changes whereas mutual information is always positive. The correlation and mutual information statistics are computed on grouped pseudobulks following user-supplied cluster labels and yield a single weight across all clusters per each TF-RE-target triplet. In contrast, the Wilcoxon method can give a single weight across all cells or give cluster-specific weights if the users provide cluster labels. In general, we recommend computing a single weight across all cells because the data in totality provides the variability of target gene expression necessary for weights estimation. For example, we want to include both untreated and treated cells to gauge the effects of the treatment. Cluster-specific weights can be useful for inferring differential network connectivity (See section on Differential Network Analysis). The choice of weights method can have a profound effect on the estimate of TF activity. When the TF activity is directly correlated with TF expression, all methods tend to work quite well. However, there are scenarios such as drug treatment or CRISPR knockout when TF continues to be expressed despite post-translational inhibition of TF activity. Epiregulon was designed to handle scenarios where TF expression is decoupled from TF activity. In such cases, wilcox is the preferred choice. For a specific use case, see an example on comparing \"wilcox\" and \"corr\" methods. Refer to our manuscript for a more in-depth discussion of the biological scenarios compatible with each weight method. regulon.w &lt;- addWeights(regulon = pruned.regulon.filtered, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, method = &quot;wilcox&quot;, clusters = GeneExpressionMatrix$cell_type, useDim = &quot;LSI_RNA&quot;) regulon.w ## DataFrame with 1374834 rows and 49 columns ## idxATAC chr start end idxRNA target corr p_val_peak_gene FDR_peak_gene distance idxTF ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; &lt;integer&gt; ## 1 266 chr1 1686177 1686677 86 NADK 0.789720 0.01973630 0.502977 91791 1030 ## 2 991 chr1 8947075 8947575 222 CA6 0.863810 0.00859085 0.470017 1207 1030 ## 3 1204 chr1 10208525 10209025 248 KIF1B 0.752412 0.02785332 0.525093 1778 1030 ## 4 1607 chr1 15296927 15297427 351 EFHD2 0.724069 0.03562011 0.550436 112459 1030 ## 5 2158 chr1 21022229 21022729 476 EIF4G3 0.755471 0.02721467 0.524680 28263 1030 ## ... ... ... ... ... ... ... ... ... ... ... ... ## 1374830 155544 chr22 50524937 50525437 23714 TYMP -0.632002 0.0165565 0.496846 4557 1558 ## 1374831 155577 chr22 50582163 50582663 23713 SCO2 -0.548795 0.0391178 0.561465 56559 1558 ## 1374832 155577 chr22 50582163 50582663 23714 TYMP -0.560573 0.0348815 0.547340 52167 1558 ## 1374833 155577 chr22 50582163 50582663 23715 ODF3B -0.549052 0.0390983 0.561465 50086 1558 ## 1374834 157674 chrX 71532678 71533178 35821 OGT 0.694312 0.0457767 0.579826 0 1558 ## tf pval stats qval CD14..Mono.vs.rest.FDR CD14..Mono.vs.rest.p.value CD14..Mono.vs.rest.logFC ## &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 ADNP 2.14101e-07 26.90142 1.00000e+00 1.12227e-273 3.58197e-275 0.453974 ## 2 ADNP 2.09927e-03 9.46065 1.00000e+00 1.07642e-91 1.13527e-92 -0.381033 ## 3 ADNP 3.18769e-21 89.42324 2.88367e-14 7.65618e-310 2.01501e-311 0.575687 ## 4 ADNP 4.50461e-03 8.06831 1.00000e+00 0.00000e+00 0.00000e+00 0.579157 ## 5 ADNP 8.62498e-05 15.41611 1.00000e+00 0.00000e+00 0.00000e+00 1.127554 ## ... ... ... ... ... ... ... ... ## 1374830 ZXDC 0.019343447 5.47020 1 0.00000e+00 0.00000e+00 2.369751 ## 1374831 ZXDC 0.030612624 4.67456 1 0.00000e+00 0.00000e+00 0.703607 ## 1374832 ZXDC 0.000448926 12.31669 1 0.00000e+00 0.00000e+00 2.369751 ## 1374833 ZXDC 0.006005115 7.54877 1 2.70505e-207 1.26648e-208 0.355839 ## 1374834 ZXDC 0.010115322 6.61447 1 1.37044e-267 4.55459e-269 0.443879 ## Memory.CD4..T.vs.rest.FDR Memory.CD4..T.vs.rest.p.value Memory.CD4..T.vs.rest.logFC B.vs.rest.FDR B.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 2.05315e-154 6.44038e-156 -0.375422 1.86039e-71 7.26021e-73 ## 2 4.84933e-83 3.37369e-84 -0.366194 2.38300e-91 7.00421e-93 ## 3 5.24986e-87 3.43190e-88 -0.374737 2.15099e-133 3.81343e-135 ## 4 2.68684e-150 8.80424e-152 -0.431623 4.46147e-126 8.60754e-128 ## 5 1.58185e-203 3.28630e-205 -0.769835 9.85829e-110 2.29967e-111 ## ... ... ... ... ... ... ## 1374830 0.00000e+00 0.00000e+00 -2.246853 0.00000e+00 0.00000e+00 ## 1374831 0.00000e+00 0.00000e+00 -0.669777 1.26531e-315 4.89624e-318 ## 1374832 0.00000e+00 0.00000e+00 -2.246853 0.00000e+00 0.00000e+00 ## 1374833 7.68600e-155 2.39621e-156 -0.323648 2.16867e-129 4.01738e-131 ## 1374834 5.86017e-169 1.62112e-170 0.553519 3.41241e-56 1.79433e-57 ## B.vs.rest.logFC Monocytes.vs.rest.FDR Monocytes.vs.rest.p.value Monocytes.vs.rest.logFC Naive.CD8..T.vs.rest.FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 -0.336361 1.61672e-15 1.49878e-16 0.310028 1.69311e-155 ## 2 -0.381502 7.44419e-91 4.10638e-93 -0.381965 1.88762e-92 ## 3 -0.484800 1.52032e-18 1.15574e-19 0.396732 2.67629e-197 ## 4 -0.461085 1.51226e-45 3.07532e-47 0.961398 4.65608e-199 ## 5 0.950493 6.72774e-52 1.06534e-53 1.283433 1.15679e-224 ## ... ... ... ... ... ... ## 1374830 -2.137413 5.62567e-83 3.56642e-85 1.673328 0.00000e+00 ## 1374831 -0.691577 5.05831e-18 3.97441e-19 0.434858 0.00000e+00 ## 1374832 -2.137413 5.62567e-83 3.56642e-85 1.673328 0.00000e+00 ## 1374833 -0.324067 2.75961e-13 3.00060e-14 0.252888 2.29027e-184 ## 1374834 0.407450 6.94934e-24 3.81243e-25 0.458222 3.58531e-155 ## Naive.CD8..T.vs.rest.p.value Naive.CD8..T.vs.rest.logFC FCGR3A..Mono.vs.rest.FDR FCGR3A..Mono.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 4.84635e-157 -0.381930 1.28738e-75 3.94290e-77 ## 2 1.02675e-93 0.381965 1.85410e-91 4.10631e-93 ## 3 5.40575e-199 -0.502247 4.51660e-48 2.62284e-49 ## 4 9.32800e-201 -0.488863 3.23963e-108 5.18334e-110 ## 5 1.98101e-226 -0.822841 2.28494e-101 4.15125e-103 ## ... ... ... ... ... ## 1374830 0.00000e+00 -2.369751 4.02540e-319 4.74303e-322 ## 1374831 0.00000e+00 -0.697245 1.10843e-54 5.33866e-56 ## 1374832 0.00000e+00 -2.369751 4.02540e-319 4.74303e-322 ## 1374833 5.13517e-186 -0.343186 2.39081e-31 2.25381e-32 ## 1374834 1.03118e-156 0.600549 4.86603e-46 2.96732e-47 ## FCGR3A..Mono.vs.rest.logFC DC.vs.rest.FDR DC.vs.rest.p.value DC.vs.rest.logFC Naive.CD4..T.vs.rest.FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 0.613397 1.48721e-10 1.38321e-11 0.467425 4.93457e-177 ## 2 -0.381965 5.36314e-91 4.10647e-93 -0.381965 1.74410e-35 ## 3 0.464689 1.15367e-05 1.85408e-06 0.325063 2.32559e-185 ## 4 0.912985 6.92276e-55 1.00693e-56 -1.224596 5.94247e-203 ## 5 -0.752391 3.09698e-24 1.18820e-25 1.224873 2.27925e-259 ## ... ... ... ... ... ... ## 1374830 2.407016 9.94254e-52 1.54440e-53 -2.022347 0.00000e+00 ## 1374831 0.529519 3.60704e-33 9.35467e-35 -0.635970 0.00000e+00 ## 1374832 2.407016 9.94254e-52 1.54440e-53 -2.022347 0.00000e+00 ## 1374833 0.272149 9.20085e-16 5.72181e-17 -0.281375 9.44166e-179 ## 1374834 0.405742 1.55880e-26 5.31323e-28 1.288327 3.85455e-118 ## Naive.CD4..T.vs.rest.p.value Naive.CD4..T.vs.rest.logFC Memory.CD8..T.vs.rest.FDR Memory.CD8..T.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 9.94010e-179 -0.402145 4.83824e-93 1.51369e-94 ## 2 2.12424e-36 -0.265716 2.07278e-90 6.76934e-92 ## 3 4.42934e-187 -0.499501 5.15609e-58 2.82016e-59 ## 4 1.00949e-204 -0.498699 2.89359e-93 9.00523e-95 ## 5 2.86486e-261 -0.883351 3.34172e-94 1.02531e-95 ## ... ... ... ... ... ## 1374830 0.00000e+00 -2.346248 0.00000e+00 0.00000e+00 ## 1374831 0.00000e+00 -0.703607 1.78609e-274 1.09308e-276 ## 1374832 0.00000e+00 -2.346248 0.00000e+00 0.00000e+00 ## 1374833 1.87859e-180 -0.341559 1.03392e-165 1.46415e-167 ## 1374834 1.36250e-119 0.518676 6.48018e-81 2.40619e-82 ## Memory.CD8..T.vs.rest.logFC NK.vs.rest.FDR NK.vs.rest.p.value NK.vs.rest.logFC NA.vs.rest.FDR NA.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 -0.358226 1.19826e-65 3.53184e-67 -0.355368 1.34418e-273 3.58197e-275 ## 2 -0.380283 4.31779e-89 8.81618e-91 -0.379363 4.29660e-92 4.10700e-93 ## 3 -0.379189 7.20212e-67 2.07735e-68 -0.450352 9.36515e-310 2.01501e-311 ## 4 0.678123 2.95876e-118 4.05187e-120 1.421655 0.00000e+00 0.00000e+00 ## 5 0.766010 6.52472e-70 1.79959e-71 0.967395 0.00000e+00 0.00000e+00 ## ... ... ... ... ... ... ... ## 1374830 -2.315715 2.18585e-267 7.37856e-270 -2.218151 4.85186e-06 1.65084e-06 ## 1374831 -0.669459 9.48323e-192 5.85577e-194 -0.665203 3.69027e-01 1.89547e-01 ## 1374832 -2.315715 2.18585e-267 7.37856e-270 -2.218151 4.85186e-06 1.65084e-06 ## 1374833 -0.338003 1.38920e-89 2.80981e-91 -0.321178 3.12869e-207 1.26648e-208 ## 1374834 0.569832 2.21855e-40 1.17083e-41 0.527130 1.63992e-267 4.55459e-269 ## NA.vs.rest.logFC weight ## &lt;numeric&gt; &lt;matrix&gt; ## 1 -0.453974 0.0583992: 0.00000000:-0.00307422:... ## 2 -0.381965 0.0311224:-0.00137646:-0.00249145:... ## 3 -0.575687 0.1032210: 0.01156464: 0.03634468:... ## 4 -0.579157 0.0333821: 0.00000000: 0.00137167:... ## 5 -1.127554 0.0550255:-0.00297161: 0.03414523:... ## ... ... ... ## 1374830 -2.121123 0.0258094: 0.00679141:-0.00776715:... ## 1374831 -0.531398 0.0262938:-0.01485703: 0.00423260:... ## 1374832 -2.121123 0.0532873:-0.00953433: 0.00931223:... ## 1374833 -0.355839 0.0311489:-0.05049477: 0.00802140:... ## 1374834 -0.443879 0.0256298: 0.04065795: 0.01652375:... 6.1.1 Aggregate cells As with the pruneRegulon function, cells can be aggregated into metacells using the aggregateCells argument in addWeights. Use this option only with the Wilcoxon method, since the other two methods already incorporate cell aggregation. By default, the function generates aggregates containing an average of 10 cells. However, the exact number may vary across metacells, depending on how single cells are distributed in the reduced dimensionality space. Refer to the cell aggregation section in Regulation Refinement for additional information. regulon.w.aggr &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, method = &quot;wilcox&quot;, clusters = GeneExpressionMatrix$cell_type, aggregateCells = TRUE, useDim = &quot;LSI_RNA&quot;, exp_cutoff=NULL, peak_cutoff=NULL) 6.1.2 Using chromatin accessibility data The corr and MI methods for calculating weights by default ignore information about chromatin accessibility. However, it is possible to incorporate this modality into the calculations by setting the tf_re.merge argument to TRUE. This adds an additional step to the procedure, in which transcription factor expression is multiplied by chromatin accessibility. Therefore, expression is reduced to zero if the corresponding element is not accessible. The TF-RE product is calculated at the level of aggregated cells, mitigating the effect of sparsity, which affects ATAC-seq data more than gene expression. See an example using the tf_re.merge argument. 6.2 Calculate TF activity Finally, the activity for a specific TF in each cell is computed by averaging the expression of target genes weighted by the test statistics of choice as explained in the add weights section. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weights_i\\] where \\(y\\) is the activity of a TF for a cell, \\(n\\) is the total number of targets for a TF, \\(x_i\\) is the log count expression of target \\(i\\) where \\(i\\) in {1,2,…,n} and \\(weights_i\\) is the weight of TF - target \\(i\\) score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, exp_assay = &quot;normalizedCounts&quot;) score.combine[1:5,1:5] ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## PBMC_10k#GGTTGCATCCTGGCTT-1 PBMC_10k#GGTTGCGGTAAACAAG-1 PBMC_10k#TGTTCCTCATAAGTTC-1 PBMC_10k#CGACTAAGTAACGGGA-1 ## ADNP 0.19163136 0.1479988 0.1897086 0.11159201 ## AEBP2 0.07737805 0.1577963 0.1498887 0.18522299 ## AFF1 0.16854888 0.1645562 0.2024166 0.11041418 ## AFF4 0.20493204 0.1909851 0.2443615 0.12750381 ## AGO1 0.15670300 0.1384629 0.1603721 0.09831584 ## PBMC_10k#CTGCTCCCAAGGTCCT-1 ## ADNP 0.2122728 ## AEBP2 0.1830738 ## AFF1 0.2081108 ## AFF4 0.2504034 ## AGO1 0.1595813 "],["network-analysis.html", "7 Network analysis 7.1 Perform differential TF activity 7.2 Visualize TF activities 7.3 Perform geneset enrichment 7.4 Perform differential network analysis 7.5 Find interaction partners", " 7 Network analysis The epiregulon.extra package provides tools for downstream analysis of gene regulatory networks (GRNs) and TF activity. It enables users to identify differential TF activity, visualize these differences, construct differential graphs that highlight changes in GRN topology, and discover potential interaction partners by identifying overlapping regulons. 7.1 Perform differential TF activity We can determine which TFs exhibit differential activities across cell clusters/groups via the findDifferentialActivity function. This function is a wrapper around the findMarkers function from scran package. library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = GeneExpressionMatrix$cell_type, pval.type = &quot;some&quot;, direction = &quot;up&quot;, logvalues = FALSE) markers getSigGenes compiles the group-wise tests into a single dataframe and enables users to select the top differential TFs based on their desired cutoffs. markers.sig &lt;- getSigGenes(markers, topgenes = 5, direction = &quot;up&quot; ) markers.sig 7.2 Visualize TF activities Epiregulon also provides the option for visualizing the inferred TF activities. options(ggrastr.default.dpi=300) tfs_interest &lt;- c( &quot;EBF1&quot;,&quot;TBX21&quot;,&quot;EOMES&quot;,&quot;SPI1&quot;) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP_RNA&quot;, nrow=2, ncol=2, point_size=0.1, label = &quot;cell_type&quot;, rasterise = TRUE) We can compare the activity with gene expression of the same TFs. plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP_RNA&quot;, nrow=2, ncol=2, legend.label = &quot;Gex&quot;, colors = c(&quot;grey&quot;,&quot;blue&quot;), point_size=0.1, rasterise = TRUE) We can also generate violin plots to visualize TF activity. plotActivityViolin(activity_matrix = score.combine, tf = tfs_interest, clusters = GeneExpressionMatrix$cell_type, legend.label = &quot;Gex&quot;, nrow=2, ncol=2, boxplot = TRUE) We generate violin plots to visualize TF gene expression. plotActivityViolin(activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, clusters = GeneExpressionMatrix$cell_type, nrow=2, ncol=2, legend.label = &quot;gene expression&quot;, boxplot=TRUE) We can visualize the different TFs in a bubble plot: plotBubble(activity_matrix = score.combine, tf = tfs_interest, clusters = GeneExpressionMatrix$cell_type, pval.type = &quot;some&quot;, direction = &quot;up&quot;, logvalues = FALSE) We visualize the top differential TFs based on activity. plotBubble(activity_matrix = score.combine, tf = markers.sig$tf, GeneExpressionMatrix$cell_type, pval.type = &quot;some&quot;, direction = &quot;up&quot;, logvalues = FALSE) 7.3 Perform geneset enrichment Sometimes we are interested in knowing what pathways are enriched in the regulon of a particular TF. We can perform gene set enrichment using the enricher function from clusterProfiler. Here we first download Hallmark and C2 signatures from MSigDB and then perform gene set enrichment of the known lineage factors. As expected, EBF1 shows enrichment for pathways associated with B cells, and TBX21 with T cells, EOMES with NK cells, and SPI1 with myeloid cells. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot; ) C2 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C2&quot;, gene.id.type = &quot;SYMBOL&quot; ) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H, C2) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = tfs_interest, regulon = regulon.w, weight = &quot;weight&quot;, weight_cutoff = 0.1, genesets = gs.list) #plot results enrichPlot(results = enrichresults, ncol=2) 7.4 Perform differential network analysis A second approach to investigate differential TF activity is to compare the weights of the target genes between groups. In this example, we are interested to compare the networks of B cells and CD4 memory T cells. We build an edge subtracted graph and calculate the degree centrality of the subtracted graph. We normalize centrality using the default square root function. The top 5 most positive TFs represent lineage factors more active in B cells whereas the bottom 5 TFs present lineage factors enriched in CD4+ memory T cells. We successfully identified the B factors EBF1, PAX5 and IRF4. The putative CD4 memory T cells factors are less understood and remain to be validated. # construct a graph of the CD4.M and NK cells respectively CD4.M_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;Memory CD4+ T&quot;) B_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;B&quot;) # construct a difference graph diff_graph &lt;- buildDiffGraph(B_network,CD4.M_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table, 10), tail(rank_table, 10)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5, max.overlaps = Inf) + theme_classic() + ggtitle (&quot;differential TFs (B-CD4.M) ranked by degree centrality&quot;) 7.5 Find interaction partners Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of regulons and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to EBF1, and we successfully identify PAX5 as the most similar TF. Both PAX5 and EBF1 are important factors for B cell development (https://www.nature.com/articles/ni.2641). library(ggplot2) # construct a graph of the preB cells B_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;B&quot;) # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(B_network) # Focus on EBF1 similarity_score_EBF1 &lt;- similarity_score[, &quot;EBF1&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_EBF1, decreasing = TRUE),20), TF = names(head(sort(similarity_score_EBF1, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;EBF1 similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by the average edge weights of the permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(B_network, &quot;EBF1&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_EBF1),] diff_matrix &lt;- similarity_score_EBF1-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted EBF1 similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_EBF1})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## PAX5 BCL11A POU2F2 RELB MTA3 MEF2A TCF4 TCF3 KMT2D NBN NFATC3 ETV6 TRIM22 BCLAF1 NCOR2 SKIL FOXO1 EED ## 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## ARID3A NFIC ## 0 0 "],["archr-workflow-and-different-weight-methods.html", "8 ArchR workflow and different weight methods 8.1 Prepare data 8.2 Load ArchR project 8.3 Retrieve matrices from ArchR project 8.4 Retrieve bulk TF ChIP-seq binding sites 8.5 Link ATAC-seq peaks to target genes 8.6 Add TF occupancy data to peaks 8.7 Generate regulons 8.8 (Optional) Annotate with TF motifs 8.9 Prune network 8.10 Add Weights 8.11 Calculate TF activity 8.12 Perform differential activity 8.13 Visualize the results 8.14 Geneset enrichment 8.15 Differential network analysis {diff_network}", " 8 ArchR workflow and different weight methods In this chapter, we illustrate the epiregulon workflow starting from an ArchR project and compare the different weight estimation methods. The dataset consists of unpaired scATACseq/scRNAseq of parental LNCaP cells treated with DMSO, enzalutamide and Enza resistant cells. The dataset was taken from Taavitsainen et al (GSE168667 and GSE168668). 8.1 Prepare data Please refer to the full ArchR manual for instructions Before running Epiregulon, the following analyses need to be completed: Obtain a peak matrix on scATACseq by using addGroupCoverages &gt; addReproduciblePeakSet &gt; addPeakMatrix. See chapter 10 from ArchR manual RNA-seq integration. For unpaired scATAC-seq, use addGeneIntegrationMatrix. See chapter 8 from ArchR manual For multiome data, use addGeneExpressionMatrix. See multiome tutorial Perform dimensionality reduction from with either single modalities or joint scRNAseq and scATACseq using addCombinedDims. See vignette 8.2 Load ArchR project Download and load the ArchR project. library(ArchR) temp_path &lt;- tempdir() download.file(&quot;http://research-pub.gene.com/oncbx/yaox/Epiregulon/GSE168667.tar.gz&quot;, file.path(temp_path, &quot;GSE168667.tar.gz&quot;)) untar(tarfile=file.path(temp_path, &quot;GSE168667.tar.gz&quot;), exdir = temp_path) archR_project_path &lt;- file.path(temp_path, &quot;multiome&quot;) proj &lt;- loadArchRProject(path = archR_project_path, showLogo = FALSE) 8.3 Retrieve matrices from ArchR project Retrieve gene expression and peak matrix from the ArchR project GeneExpressionMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;GeneIntegrationMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) PeakMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;PeakMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) If we extract the gene expression from matrix, it will be in the form of RangedSummarizedExperiment. We can make use of ArchRMatrix2SCE to convert gene expression matrix to a SingleCellExperiment object. It’s also important to note that gene expression from ArchR is library size normalized (not logged). library(epiregulon.archr) GeneExpressionMatrix &lt;- ArchRMatrix2SCE(GeneExpressionMatrix, rename = &quot;normalizedCounts&quot;) rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name We rename the assay name of the PeakMatrix as counts. PeakMatrix &lt;- ArchRMatrix2SCE(PeakMatrix, rename = &quot;counts&quot;) Transfer embeddings from ArchR project to SingleCellExperiment for visualization reducedDim(GeneExpressionMatrix, &quot;UMAP_Combined&quot;) &lt;- getEmbedding(ArchRProj = proj, embedding = &quot;UMAP_Combined&quot;, returnDF = TRUE)[colnames(GeneExpressionMatrix),] # add cell label GeneExpressionMatrix$label &lt;- GeneExpressionMatrix$Cells GeneExpressionMatrix$label[GeneExpressionMatrix$Treatment == &quot;enzalutamide 48h&quot;] &lt;- &quot;LNCaP–ENZ48&quot; GeneExpressionMatrix$label &lt;- factor(GeneExpressionMatrix$label, levels = c(&quot;LNCaP&quot;, &quot;LNCaP–ENZ48&quot;, &quot;LNCaP RES-A&quot;, &quot;LNCaP RES-B&quot;)) Visualize the SingleCellExperiment object by UMAP scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_Combined&quot;, text_by = &quot;label&quot;, colour_by = &quot;label&quot;) 8.4 Retrieve bulk TF ChIP-seq binding sites We retrieve TF binding sites compiled from ChIP-Atlas and ENCODE ChIP-seq. Currently, human genomes hg19 and hg38 and mouse mm10 are available. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 8.5 Link ATAC-seq peaks to target genes We compute peak to gene correlations using the addPeak2GeneLinks function from the ArchR package. The user would need to supply a path to an ArchR project already containing peak and gene matrices, as well as Latent semantic indexing (LSI) dimensionality reduction. We will use the joint reducedDims - “LSI_Combined”. p2g &lt;- calculateP2G(ArchR_path = archR_project_path, useDim = &quot;iLSI_Combined&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, threads = 1) ## Using ArchR to compute peak to gene links... p2g ## DataFrame with 17979 rows and 8 columns ## idxATAC chr start end idxRNA target Correlation distance ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 15 chr1 912762 913262 7 NOC2L 0.546722 46297 ## 2 15 chr1 912762 913262 8 KLHL17 0.516539 47575 ## 3 25 chr1 920261 920761 7 NOC2L 0.649425 38798 ## 4 25 chr1 920261 920761 8 KLHL17 0.637711 40076 ## 5 32 chr1 927728 928228 7 NOC2L 0.610240 31331 ## ... ... ... ... ... ... ... ... ... ## 17975 210643 chrX 154542721 154543221 23496 CH17-340M24.3 0.611273 114492 ## 17976 210643 chrX 154542721 154543221 23501 LAGE3 0.698033 63714 ## 17977 210643 chrX 154542721 154543221 23506 IKBKG 0.518586 1716 ## 17978 210643 chrX 154542721 154543221 23509 DKC1 0.526624 219771 ## 17979 210665 chrX 154815200 154815700 23515 F8 0.547783 211490 8.6 Add TF occupancy data to peaks The next step is to add the TF binding information by overlapping the regions of the peak matrix with the bulk ChIP-seq data. Users can supply an ArchR project path and this function will retrieve the positions of the peaks from the peak matrix. overlap &lt;- addTFMotifInfo(archR_project_path = archR_project_path, grl = grl, p2g = p2g) 8.7 Generate regulons A long format data frame, representing the inferred regulons, is then generated. Three columns are important: transcription factors (tf) target genes (target) peak to gene correlation between tf and target gene (corr) regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 2776926 rows and 10 columns ## idxATAC chr start end idxRNA target corr distance idxTF tf ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt; &lt;character&gt; ## 1 15 chr1 912762 913262 7 NOC2L 0.546722 46297 4 AGO1 ## 2 15 chr1 912762 913262 7 NOC2L 0.546722 46297 11 ARID4B ## 3 15 chr1 912762 913262 7 NOC2L 0.546722 46297 12 ARID5B ## 4 15 chr1 912762 913262 7 NOC2L 0.546722 46297 30 BCOR ## 5 15 chr1 912762 913262 7 NOC2L 0.546722 46297 36 BRD4 ## ... ... ... ... ... ... ... ... ... ... ... ## 2776922 210665 chrX 154815200 154815700 23515 F8 0.547783 211490 1146 NFRKB ## 2776923 210665 chrX 154815200 154815700 23515 F8 0.547783 211490 1175 POLR2H ## 2776924 210665 chrX 154815200 154815700 23515 F8 0.547783 211490 1273 ZBTB8A ## 2776925 210665 chrX 154815200 154815700 23515 F8 0.547783 211490 1456 ZNF589 ## 2776926 210665 chrX 154815200 154815700 23515 F8 0.547783 211490 1457 ZNF592 8.8 (Optional) Annotate with TF motifs In this example, we will filter the regulons for the presence of transcription factor motifs and continue the workflow with the regulon.motif object. However, if users prefer to retain all target genes, they may proceed with the regulon object. regulon.motif &lt;- addMotifScore(regulon = regulon, ArchProj = proj ) # retain only TF-RE-TG triplets with motifs regulon.motif &lt;- regulon.motif[which(regulon.motif$motif ==1),] 8.9 Prune network We prune the regulons. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon = regulon.motif, clusters = GeneExpressionMatrix$label, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05) 8.10 Add Weights Before we calculate AR activity, we visualize its expression and show that enzalutamide does not decrease AR expression despite being an AR antagonist. library(epiregulon.extra) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix), tf = &quot;AR&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;gene expression&quot;) Then we extract the chromVarMatrix from ArchR project and visualize the chromatin accessibility at AR bound sites. We can see that 48 hour of enzalutamide treatment reduced chromatin accessibility at AR bound sites. chromVarMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;MotifMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1 ) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(chromVarMatrix, &quot;z&quot;), tf = &quot;AR_689&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;chromVar&quot;) Next, we are going to compare 3 different weight methods. In the first method, the wilcoxon test compares target gene expression in cells meeting both the TF expression and accessibility cutoffs vs cells failing either the TF expression or/and accessibility cutoffs. Next, we try out the correlation method which comes in two flavors. When tf_re.merge = FALSE, weight is computed on the correlation of target gene expression vs TF gene expression. When tf_re.merge = TRUE, weight is computed on the correlation of target gene expression vs the product of TF expression and chromatin accessibility at TF-bound regulatory elements. regulon.w.wilcox &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;wilcoxon&quot;) regulon.w.corr &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;) regulon.w.corr.re &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;, tf_re.merge = TRUE) 8.11 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging the weighted expressions of target genes linked to the TF. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weight_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,…,n} \\(weight_i\\) is the weight of TF and target i We calculate the activities corresponding to three weight methods. score.combine.wilcox &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, regulon = regulon.w.wilcox, normalize = TRUE, mode = &quot;weight&quot;) score.combine.corr &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, regulon = regulon.w.corr, normalize = TRUE, mode = &quot;weight&quot;) score.combine.corr.re &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, regulon = regulon.w.corr.re, normalize = TRUE, mode = &quot;weight&quot;) We visualize the different activities side by side. library(epiregulon.extra) plotActivityViolin(activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by wilcoxon&quot;) plotActivityViolin(activity_matrix = score.combine.corr, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF vs TG&quot;) plotActivityViolin(activity_matrix = score.combine.corr.re, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF*RE vs TG&quot;) We can see that the AR activity calculated from correlation based on TF and TG expression is clearly wrong because AR activity is increased after enzalutamide treatment despite it being an AR antagonist. Therefore, for drug treatment which often decouples TF gene expression from its activity, it is important to take into consideration both TF gene expression and RE chromatin accessibility; the latter may be a better indicator of TF function. In this case, the recommended methods are either wilcox or corr with tf_re.merge = TRUE. The astute users could however detect a difference in the prediction of the AR activity in the resistant clones “RES-A” and “RES-B” with respect to the parental “LNCaP” between the two methods. For example, the corr with tf_re.merge = TRUE shows increased AR activity in “RES-B” compared to “LNCaP” because “RES-B” shows increased AR expression. In contrast, the wilcoxon method did not predict an increase in AR activity in “RES-B” because “RES-B” still shows reduced chromatin accessibility compared to “LNCaP”. Since wilcoxon takes into account the co-occurrence of both TF gene expression and RE chromatin accessibility, this method does not predict an overall increase in AR activity. In the absence of the ground truth, it is difficult to judge which method is superior. Therefore, it is always crucial to validate key findings with empirical evidence. The most important disclaimer we wish to make is that all predictions by epiregulon should be robustly tested experimentally. 8.12 Perform differential activity For the remaining steps, we continue with activity derived from the wilcoxon method. markers &lt;- findDifferentialActivity(activity_matrix = score.combine.wilcox, clusters = GeneExpressionMatrix$label, pval.type = &quot;some&quot;, direction = &quot;any&quot;, test.type = &quot;t&quot;, logvalues = FALSE ) markers ## List of length 4 ## names(4): LNCaP LNCaP–ENZ48 LNCaP RES-A LNCaP RES-B Take the top differential TFs. Summary represents comparison of cells in the indicated class vs all the remaining cells. markers.sig &lt;- getSigGenes(markers, direction = &quot;any&quot;, topgenes = 2 ) markers.sig ## p.value FDR summary.diff class tf ## 1 0 0 0.06918392 LNCaP HES4 ## 3 0 0 0.05180702 LNCaP SPDEF ## 11 0 0 0.05553992 LNCaP–ENZ48 HES4 ## 31 0 0 -0.03564181 LNCaP–ENZ48 NR2F6 ## 12 0 0 0.07761191 LNCaP RES-A ATF5 ## 2 0 0 -0.03724509 LNCaP RES-A EHF ## 21 0 0 0.04959529 LNCaP RES-B JUN ## 32 0 0 0.04786785 LNCaP RES-B NR2F2 8.13 Visualize the results First visualize the known differential TFs by bubble plot plotBubble(activity_matrix = score.combine.wilcox, tf = c(&quot;AR&quot;,&quot;FOXA1&quot;, &quot;MYC&quot;,&quot;JUN&quot;), pval.type = &quot;some&quot;, direction = &quot;up&quot;, clusters = GeneExpressionMatrix$label, logvalues = FALSE) Then visualize the most differential TFs by clusters plotBubble(activity_matrix = score.combine.wilcox, tf = unique(markers.sig$tf), pval.type = &quot;some&quot;, direction = &quot;any&quot;, clusters = GeneExpressionMatrix$label, logvalues = FALSE) Visualize the known differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize the differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = markers.sig$tf[1:4], dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize regulons by heatmap rowData(GeneExpressionMatrix) &lt;- NULL plotHeatmapRegulon(sce=GeneExpressionMatrix, tfs= c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon=regulon.w.wilcox, regulon_cutoff=0.1, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;normalizedCounts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) plotHeatmapActivity(activity=score.combine.wilcox, sce=GeneExpressionMatrix, tfs=rownames(score.combine.wilcox), downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name = &quot;transcription factor activity&quot;, column_title_rot = 45) 8.14 Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H,C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = c(&quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) #plot results enrichPlot(results = enrichresults, ncol = 2) We can visualize the genesets of known factors as a network plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) We can visualize the genesets of differential factors as a network enrichresults &lt;- regulonEnrich(TF = markers.sig$tf, regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) 8.15 Differential network analysis {diff_network} In addition to looking at summed TF activity, a second approach to investigate differential TF activity is to compare target genes or network topology. In this example, we know that AR is downregulated in the enzalutamide treated cells compared to parental LNCaP. We perform edge subtracted graph between two conditions and rank TFs by degree centrality. In this example, positive centrality indicates higher activity in parental LNCaP and negative centrality indicates higher activity in enzalutamide treated cells. # construct a graph of the parental and enzalutamide treated cells respectively LNCaP_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaP&quot;) ENZ_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaP–ENZ48&quot;) # construct a difference graph diff_graph &lt;- buildDiffGraph(LNCaP_network, ENZ_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table,5), tail(rank_table,5)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5) + theme_classic() + ggtitle (&quot;differential TFs (LNCaP-ENZ) ranked by degree centrality&quot;) Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of the targets genes for all the TFs and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to AR. library(igraph) diff_graph_filter &lt;- subgraph.edges(diff_graph, E(diff_graph)[E(diff_graph)$weight&gt;0], del=TRUE) # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(diff_graph_filter) # Focus on AR similarity_score_AR &lt;- similarity_score[, &quot;AR&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_AR, decreasing = TRUE),20), TF = names(head(sort(similarity_score_AR, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to SPI1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;AR similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(diff_graph_filter, &quot;AR&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_AR),] diff_matrix &lt;- similarity_score_AR-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to AR topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted AR similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_AR})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## JUND MYC HOXB13 FOXA1 NFIC CEBPB XBP1 MAZ ATF4 CTCF REST GATA2 ETV1 FOXP1 CEBPG JUN YY1 NFIB ## 0.00 0.00 0.00 0.01 0.03 0.01 0.00 0.03 0.01 0.00 0.01 0.01 0.03 0.01 0.01 0.03 0.00 0.00 ## ZNF148 USF2 ## 0.00 0.01 "],["single-modality-scrna-seq-only.html", "9 Single modality: scRNA-seq only 9.1 Load regulons 9.2 Load scRNA-seq data 9.3 Calculate activity 9.4 Perform differential activity 9.5 Visualize activity 9.6 Perform pathway enrichment", " 9 Single modality: scRNA-seq only Epiregulon also supports transcription factor activity inference when users only have scRNA-seq. To enable TF activity inference on scRNA-seq, users can supply a pre-constructed gene regulatory network. In this vignette, we bypass the regulon construction step and go straight to calculate TF activity from a Dorothea GRN. 9.1 Load regulons Dorothea provides both human and mouse pre-constructed gene regulatory networks based on curated experimental and computational data. library(dorothea) data(dorothea_mm, package = &quot;dorothea&quot;) regulon &lt;- dorothea_mm #known tfs genes_to_plot &lt;- c(&quot;Onecut1&quot;, &quot;Hnf1a&quot;,&quot;Pdx1&quot;,&quot;Arx&quot;) 9.2 Load scRNA-seq data We download the raw counts of a mouse pancreas data set from scRNAseq. We add normalized logcounts, perform dimension reduction and visualize the embeddings using scater. library(scRNAseq) library(scater) sce &lt;- BaronPancreasData(&#39;mouse&#39;) sce &lt;- logNormCounts(sce) sce &lt;- runPCA(sce) sce &lt;- runUMAP(sce) plotUMAP(sce, colour_by = &quot;label&quot;, text_by = &quot;label&quot;) 9.3 Calculate activity Even though Dorothea provides weights under the mor column, we can achieve superior performance if we recompute the weights based on the correlation between tf and target gene expression based on our own data. We performed 2 steps: the first step is to add weights to the Dorothea regulons and the second step is to estimate the TF activity by taking the weighted average of the target gene expression. library(epiregulon) #Add weights to regulon. Default method (wilcoxon) cannot be used regulon.ms &lt;- addWeights(regulon = regulon, expMatrix = sce, clusters = sce$label, BPPARAM = BiocParallel::MulticoreParam(), method=&quot;corr&quot;) #Calculate activity score.combine &lt;- calculateActivity(sce, regulon = regulon.ms, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) 9.4 Perform differential activity library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = sce$label, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) Take the top TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) 9.5 Visualize activity Finally we visualize the TF activity by either UMAP, violin plots or bubble plots. We confirm the activity of known lineage factors: Pdx1 in beta cells, Arx in alpha cells, Onecut1 in ductal cells and Hnf1a in both endocrine and exocrine cells. # plot umap plotActivityDim(sce = sce, activity_matrix = score.combine, tf = genes_to_plot, legend.label = &quot;score&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2) # plot violin plot plotActivityViolin(score.combine, tf = genes_to_plot, clusters = sce$label) # plot bubble plot plotBubble(score.combine, tf = genes_to_plot, clusters = sce$label) Plot bubble plot of differential TFs plotBubble(score.combine, tf = markers.sig$tf, clusters = sce$label) We can adapt the epiregulon package to plot gene expression. When compared against TF activity, gene expression tends to have noisy signals and high dropout rates. Epiregulon enhances the signal to noise ratio of TF activity and better resolves lineage differences. # plot umap plotActivityDim(sce = sce, activity_matrix = logcounts(sce), tf = genes_to_plot, legend.label = &quot;gex&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2, colors = c(&quot;gray&quot;,&quot;blue&quot;), limit = c(0,2)) # plot violin plot plotActivityViolin(logcounts(sce), tf = genes_to_plot, clusters = sce$label, legend.label = &quot;gex&quot;) # plot Bubble plot plotBubble(logcounts(sce), tf = markers.sig$tf, clusters = sce$label, legend.label = &quot;gex&quot;, title = &quot;gene expression&quot;) We can visualize the target genes for transcription factors of interest plotHeatmapRegulon(sce=sce, tfs=genes_to_plot, regulon=regulon.ms, regulon_cutoff=0.5, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;logcounts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) plotHeatmapActivity(activity_matrix = score.combine, sce=sce, tfs=genes_to_plot, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) 9.6 Perform pathway enrichment Sometimes it is useful to understand what pathways are enriched in the regulons. We take the highly correlated target genes of a regulon and perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets MH &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;MH&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) M7 &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;M7&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(MH,M7) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs = x, genes = gs[[x]])})) enrichresults &lt;- regulonEnrich(genes_to_plot, regulon = regulon.ms, weight = &quot;weight&quot;, weight_cutoff = 0.3, genesets = gs.list) #plot results enrichPlot(results = enrichresults, ncol = 1, top=5) "],["session-info.html", "10 Session Info", " 10 Session Info sessionInfo() ## R version 4.5.0 (2025-04-11) ## Platform: x86_64-pc-linux-gnu ## Running under: Red Hat Enterprise Linux 8.10 (Ootpa) ## ## Matrix products: default ## BLAS/LAPACK: FlexiBLAS OPENBLAS; LAPACK version 3.12.0 ## ## Random number generation: ## RNG: L&#39;Ecuyer-CMRG ## Normal: Inversion ## Sample: Rejection ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/Los_Angeles ## tzcode source: system (glibc) ## ## attached base packages: ## [1] parallel grid stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] org.Mm.eg.db_3.22.0 scater_1.38.0 scuttle_1.20.0 ## [4] scRNAseq_2.24.0 dorothea_1.22.0 igraph_2.2.1 ## [7] org.Hs.eg.db_3.22.0 nabor_0.5.0 msigdbr_25.1.1 ## [10] epiregulon.extra_1.6.0 zellkonverter_1.20.0 ensembldb_2.34.0 ## [13] AnnotationFilter_1.34.0 GenomicFeatures_1.62.0 AnnotationDbi_1.72.0 ## [16] pbmcMultiome.SeuratData_0.1.4 SeuratData_0.2.2.9002 Signac_1.16.0 ## [19] Seurat_5.3.1 SeuratObject_5.2.0 sp_2.2-0 ## [22] epiregulon.archr_0.99.8 rhdf5_2.54.1 RcppArmadillo_15.2.2-1 ## [25] Rcpp_1.1.0 sparseMatrixStats_1.22.0 data.table_1.17.8 ## [28] stringr_1.6.0 plyr_1.8.9 magrittr_2.0.4 ## [31] ggplot2_4.0.1 gtable_0.3.6 gtools_3.9.5 ## [34] gridExtra_2.3 devtools_2.4.6 usethis_3.2.1 ## [37] ArchR_1.0.3.1 Matrix_1.7-4 BSgenome.Hsapiens.UCSC.hg38_1.4.5 ## [40] BSgenome_1.78.0 rtracklayer_1.70.0 BiocIO_1.20.0 ## [43] Biostrings_2.78.0 XVector_0.50.0 GenomeInfoDb_1.46.2 ## [46] epiregulon_2.0.2 scMultiome_1.10.0 SingleCellExperiment_1.32.0 ## [49] MultiAssayExperiment_1.36.1 SummarizedExperiment_1.40.0 Biobase_2.70.0 ## [52] GenomicRanges_1.62.0 Seqinfo_1.0.0 IRanges_2.44.0 ## [55] S4Vectors_0.48.0 MatrixGenerics_1.22.0 matrixStats_1.5.0 ## [58] ExperimentHub_3.0.0 AnnotationHub_4.0.0 BiocFileCache_3.0.0 ## [61] dbplyr_2.5.1 BiocGenerics_0.56.0 generics_0.1.4 ## [64] BiocStyle_2.38.0 ## ## loaded via a namespace (and not attached): ## [1] graph_1.88.0 ica_1.0-3 plotly_4.11.0 ## [4] BiocBaseUtils_1.12.0 doParallel_1.0.17 tidyselect_1.2.1 ## [7] bit_4.6.0 clue_0.3-66 lattice_0.22-7 ## [10] rjson_0.2.23 blob_1.2.4 S4Arrays_1.10.1 ## [13] dichromat_2.0-0.1 seqLogo_1.76.0 png_0.1-8 ## [16] cli_3.6.5 ggplotify_0.1.3 ProtGenerics_1.42.0 ## [19] goftest_1.2-3 bluster_1.20.0 purrr_1.2.0 ## [22] EnrichmentBrowser_2.40.0 BiocNeighbors_2.4.0 uwot_0.2.4 ## [25] curl_7.0.0 mime_0.13 evaluate_1.0.5 ## [28] tidytree_0.4.6 ComplexHeatmap_2.26.0 stringi_1.8.7 ## [31] backports_1.5.0 XML_3.99-0.20 httpuv_1.6.16 ## [34] clusterProfiler_4.18.2 rappdirs_0.3.3 splines_4.5.0 ## [37] RcppRoll_0.3.1 ggraph_2.2.2 bcellViper_1.46.0 ## [40] dplyr_1.1.4 sctransform_0.4.2 ggbeeswarm_0.7.3 ## [43] sessioninfo_1.2.3 DBI_1.2.3 HDF5Array_1.38.0 ## [46] jquerylib_0.1.4 withr_3.0.2 systemfonts_1.3.1 ## [49] enrichplot_1.30.4 lmtest_0.9-40 ggnewscale_0.5.2 ## [52] GSEABase_1.72.0 tidygraph_1.3.1 BiocManager_1.30.27 ## [55] htmlwidgets_1.6.4 fs_1.6.6 ggrepel_0.9.6 ## [58] labeling_0.4.3 SparseArray_1.10.6 h5mread_1.2.1 ## [61] annotate_1.88.0 reticulate_1.44.1 zoo_1.8-14 ## [64] knitr_1.50 TFBSTools_1.48.0 UCSC.utils_1.6.0 ## [67] TFMPvalue_0.0.9 foreach_1.5.2 patchwork_1.3.2 ## [70] caTools_1.18.3 ggtree_4.0.1 pwalign_1.6.0 ## [73] R.oo_1.27.1 ggiraph_0.9.2 RSpectra_0.16-2 ## [76] irlba_2.3.5.1 ggrastr_1.0.2 alabaster.schemas_1.10.0 ## [79] fastDummies_1.7.5 gridGraphics_0.5-1 ellipsis_0.3.2 ## [82] lazyeval_0.2.2 yaml_2.3.12 survival_3.8-3 ## [85] scattermore_1.2 BiocVersion_3.22.0 crayon_1.5.3 ## [88] RcppAnnoy_0.0.22 RColorBrewer_1.1-3 tidyr_1.3.1 ## [91] progressr_0.18.0 tweenr_2.0.3 later_1.4.4 ## [94] Rgraphviz_2.54.0 GlobalOptions_0.1.3 ggridges_0.5.7 ## [97] codetools_0.2-20 KEGGREST_1.50.0 shape_1.4.6.1 ## [100] Rtsne_0.17 limma_3.66.0 gdtools_0.4.4 ## [103] Rsamtools_2.26.0 filelock_1.0.3 pkgconfig_2.0.3 ## [106] KEGGgraph_1.70.0 spatstat.univar_3.1-5 GenomicAlignments_1.46.0 ## [109] aplot_0.2.9 alabaster.base_1.10.0 spatstat.sparse_3.1-0 ## [112] ape_5.8-1 viridisLite_0.4.2 xtable_1.8-4 ## [115] httr_1.4.7 tools_4.5.0 globals_0.18.0 ## [118] pkgbuild_1.4.8 beeswarm_0.4.0 checkmate_2.3.3 ## [121] nlme_3.1-168 assertthat_0.2.1 digest_0.6.39 ## [124] bookdown_0.46 dir.expiry_1.18.0 farver_2.1.2 ## [127] reshape2_1.4.5 yulab.utils_0.2.2 viridis_0.6.5 ## [130] DirichletMultinomial_1.52.0 glue_1.8.0 cachem_1.1.0 ## [133] polyclip_1.10-7 parallelly_1.45.1 pkgload_1.4.1 ## [136] statmod_1.5.1 RcppHNSW_0.6.0 ScaledMatrix_1.18.0 ## [139] fontBitstreamVera_0.1.1 pbapply_1.7-4 httr2_1.2.2 ## [142] spam_2.11-1 gson_0.1.0 dqrng_0.4.1 ## [145] basilisk_1.22.0 graphlayouts_1.2.2 alabaster.se_1.10.0 ## [148] shiny_1.12.1 tidydr_0.0.6 scrapper_1.4.0 ## [151] R.utils_2.13.0 rhdf5filters_1.22.0 RCurl_1.98-1.17 ## [154] alabaster.sce_1.10.0 memoise_2.0.1 rmarkdown_2.30 ## [157] scales_1.4.0 R.methodsS3_1.8.2 gypsum_1.6.0 ## [160] future_1.68.0 chromote_0.5.1 RANN_2.6.2 ## [163] fontLiberation_0.1.0 Cairo_1.7-0 spatstat.data_3.1-9 ## [166] rstudioapi_0.17.1 cluster_2.1.8.1 spatstat.utils_3.2-0 ## [169] fitdistrplus_1.2-4 cowplot_1.2.0 colorspace_2.1-2 ## [172] FNN_1.1.4.1 rlang_1.1.6 BSgenome.Hsapiens.UCSC.hg19_1.4.3 ## [175] dotCall64_1.2 circlize_0.4.17 ggforce_0.5.0 ## [178] ggtangle_0.0.9 xfun_0.54 alabaster.matrix_1.10.0 ## [181] iterators_1.0.14 remotes_2.5.0 abind_1.4-8 ## [184] GOSemSim_2.36.0 tibble_3.3.0 treeio_1.34.0 ## [187] Rhdf5lib_1.32.0 motifmatchr_1.32.0 bitops_1.0-9 ## [190] ps_1.9.1 promises_1.5.0 scatterpie_0.2.6 ## [193] RSQLite_2.4.5 qvalue_2.42.0 fgsea_1.36.0 ## [196] DelayedArray_0.36.0 GO.db_3.22.0 compiler_4.5.0 ## [199] alabaster.ranges_1.10.0 beachmat_2.26.0 listenv_0.10.0 ## [202] fontquiver_0.2.1 edgeR_4.8.0 BiocSingular_1.26.1 ## [205] tensor_1.5.1 MASS_7.3-65 BiocParallel_1.44.0 ## [208] babelgene_22.9 spatstat.random_3.4-3 R6_2.6.1 ## [211] fastmap_1.2.0 fastmatch_1.1-6 vipor_0.4.7 ## [214] ROCR_1.0-11 websocket_1.4.4 rsvd_1.0.5 ## [217] KernSmooth_2.23-26 miniUI_0.1.2 deldir_2.0-4 ## [220] htmltools_0.5.9 bit64_4.6.0-1 spatstat.explore_3.6-0 ## [223] lifecycle_1.0.4 S7_0.2.1 processx_3.8.6 ## [226] restfulr_0.0.16 sass_0.4.10 vctrs_0.6.5 ## [229] rsconnect_1.7.0 spatstat.geom_3.6-1 DOSE_4.4.0 ## [232] scran_1.38.0 ggfun_0.2.0 future.apply_1.20.1 ## [235] bslib_0.9.0 pillar_1.11.1 magick_2.9.0 ## [238] metapod_1.18.0 locfit_1.5-9.12 otel_0.2.0 ## [241] jsonlite_2.0.0 GetoptLong_1.1.0 cigarillo_1.0.0 "],["contact.html", "11 Contact", " 11 Contact The issues related to epiregulon suite of packages can be reported on the package GitHub repository page. epiregulon epiregulon.extra epiregulon.archr If you need more information on the package usage you can contact authors directly: Xiaosai Yao, yao.xiaosai@gene.com Tomasz Włodarczy, tomwlo@gmail.com "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
