[["index.html", "Epiregulon documentation Introduction", " Epiregulon documentation Xiaosai Yao, Tomasz Włodarczyk 2025-01-15 Introduction Gene regulatory networks model the underlying gene regulation hierarchies that drive gene expression and cell states. The main function of the epiregulon package is to construct gene regulatory networks and infer transcription factor (TF) activity in single cells by integration of scATAC-seq and scRNA-seq data and incorporation of public bulk TF ChIP-seq data. Epiregulon assigns regulatory elements (REs) to their putative target genes (TGs) if the chromatin accessibility and gene expressions are highly correlated across cell clusters. Each regulatory element is then interrogated for TF occupancy based on a compilation of public TF ChIP-seq binding sites from ChIP-Atlas and ENCODE TF ChIP-seq data. This maps out the preliminary TF-RE-TG regulatory relationships. Further pruning of the gene regulatory network is necessary to remove spurious gene regulatory relationships not supported by the data, especially because the public ChIP-seq data was most certainly obtained in different cell lines or treatment conditions. In this case, we want to identify the most likely TF-RE-TG triplets. Here we apply tests of independence (binomial or chi-square tests) which identify TF-RE-TG triplets jointly occurring at probabilities deviating from the expected probabilities if these three events occur independently. In other words, we assume that a TF-RE-TG regulatory relationship holds true if expression of the TG, chromatin accessibility at RE and expression of the TG tend to co-exist in the same cells. While we recognize that there could be time delays between chromatin accessibility and the expression of target genes in true RE-TG relationships, we want to be conservative in our inference and rule out unsubstantiated TF-RE-TG relationships. After network pruning, we would like to further estimate the strength of regulation. This can be achieved using one of the three methods: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, and 3) effect size of the Wilcoxon test between target gene expression in cells jointly expressing all 3 elements vs cells that do not. The activity of transcription factor is the weighted sum of all its target genes in which the weights correspond to the strength of regulation. The target genes of TFs can be queried against known pathways to predict the functions of TFs. We can also perform differential TF activity using two approaches: 1) differential total activity or 2) differential network topology. The first approach compares differences in the sum of the target genes. The second approach involves edge subtraction between two networks and the TFs are ranked by the degree centrality of the differential graphs. Epiregulon also allows identification of interaction partners by the degree of overlaps in the target genes between two TFs. Current prerequisites for running epiregulon include pre-computed peak matrix, gene expression matrix and dimensionality reduction. Epiregulon offers seamless integration with ArchR. Alternately, users can analyze their data using their favorite analysis tools and package their matrices into MultiAssayExperiment (See scMultiome package). The scATAC-seq experiment can be either paired or unpaired with the scRNA-seq dataset as long as they were already integrated. The final output of epiregulon is a matrix of TF activities where rows are individual TFs and columns are single cell indexes. Check out our preprint Epiregulon: Inference of single-cell transcription factor activity to dissect mechanisms of lineage plasticity and drug response Tomasz Włodarczyk, Aaron Lun, Diana Wu, Shreya Menon, Shushan Toneyan, Kerstin Seidel, Liang Wang, Jenille Tan, Shang-Yang Chen, Timothy Keyes, Aleksander Chlebowski, Yu Guo, Ciara Metcalfe, Marc Hafner, Christian W. Siebel, M. Ryan Corces, Robert Yauch, Shiqi Xie, Xiaosai Yao bioRxiv 2023.11.27.568955; doi: https://doi.org/10.1101/2023.11.27.568955 "],["installation.html", "1 Installation 1.1 Installing from github 1.2 Installing from Bioconductor", " 1 Installation 1.1 Installing from github All the epiregulon components are available on github. There are three separate epiregulon packages. The core epiregulon package supports input in the form of SingleCellExperiment objects. If the users would like to start from ArchR projects, they may choose to use epiregulon.archr package, which allows for the seamless integration with ArchR package through accepting its output to be used in the downstream workflow. # install devtools if(!require(devtools)) install.packages(&quot;devtools&quot;) # install basic epiregulon package devtools::install_github(repo=&#39;xiaosaiyao/epiregulon&#39;) # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.archr&#39;) Moreover, we provide a suite of tools for the enrichment analysis, visualization, and network analysis which can be run on the epireglon or epiregulon.archr output. # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.extra&#39;) The data package scMultiome is for storing TF ChIP-seq data and pre-processed datasets. # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/scMultiome&#39;) 1.2 Installing from Bioconductor Epiregulon is now available through Bioconductor. if (!require(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;epiregulon&quot;) BiocManager::install(&quot;epiregulon.extra&quot;) BiocManager::install(&quot;scMultiome&quot;) "],["data-preparation.html", "2 Data preparation 2.1 Constructing a SingleCellExperiment object 2.2 Starting from an ArchR object 2.3 Starting from a Seurat/Signac object 2.4 Starting from AnnData 2.5 Starting from 10x data formats 2.6 Reading directly from CSV 2.7 Important points", " 2 Data preparation Epiregulon operates on the SingleCellExperiment class. We assume that gene expression, chromatin accessibility and dimension reduction have been obtained by users’ favorite packages prior to the use of Epiregulon. This chapter provides instructions on how to convert gene expression matrix and peak matrix into SingleCellExperiment objects from other formats including ArchR project, Seurat objects, AnnData and 10x genomics output. The first section provides a quick primer on the components of a SingleCellExperiment object necessary to run Epiregulon. It is thus recommended for all users to go through it. 2.1 Constructing a SingleCellExperiment object Let’s construct a GeneExpressionMatrix from scratch. First we will create the count matrix. library(SingleCellExperiment) counts &lt;- matrix(rpois(100000, lambda = 2), ncol=1000, nrow=100) GeneExpressionMatrix &lt;- SingleCellExperiment(list(counts=counts)) rownames(GeneExpressionMatrix) &lt;- paste(&quot;Gene&quot;,1:100, sep=&quot;-&quot;) colnames(GeneExpressionMatrix) &lt;- paste(&quot;Cell&quot;,1:1000, sep=&quot;-&quot;) It is important (and efficient) to convert the count matrix to dgCMatrix format at the beginning of the workflow. library(Matrix) ## ## Attaching package: &#39;Matrix&#39; ## The following object is masked from &#39;package:S4Vectors&#39;: ## ## expand counts(GeneExpressionMatrix) &lt;- as(counts(GeneExpressionMatrix), &quot;dgCMatrix&quot;) Next we will add the cell information to colData colData(GeneExpressionMatrix) &lt;- DataFrame(Cluster = paste(&quot;cluster&quot;, sample(1:3,1000, TRUE))) For the purpose of Epiregulon, it is important to provide the start and end position of the genes so that we can link genes to the peak regions. seqnames &lt;- paste0(&quot;chr&quot;, sample(1:2, 100, TRUE)) start &lt;- sample(1:100000, 100, TRUE) end &lt;- start + sample(100:500, 100, TRUE) strand &lt;- sample(c(&quot;+&quot;, &quot;-&quot;, &quot;*&quot;), 100, TRUE) gr &lt;- GRanges( seqnames = seqnames, ranges = IRanges(start = start, end = end), strand = strand ) Next we provide additional information about the genes. We can add them into the mcols as DataFrame. The GRanges become the rowRanges of the GeneExpressionMatrix. mcols(gr) &lt;- DataFrame(name = paste(&quot;Gene&quot;, 1:100, sep=&quot;-&quot;), ID = paste0(&quot;ID&quot;, 1:100)) rowRanges(GeneExpressionMatrix) &lt;- gr rowRanges(GeneExpressionMatrix) ## GRanges object with 100 ranges and 2 metadata columns: ## seqnames ranges strand | name ID ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## [1] chr2 78037-78301 - | Gene-1 ID1 ## [2] chr1 98640-99070 - | Gene-2 ID2 ## [3] chr1 50743-50946 + | Gene-3 ID3 ## [4] chr1 14336-14511 - | Gene-4 ID4 ## [5] chr2 53117-53532 + | Gene-5 ID5 ## ... ... ... ... . ... ... ## [96] chr1 52310-52704 * | Gene-96 ID96 ## [97] chr2 66603-66908 + | Gene-97 ID97 ## [98] chr1 44113-44406 + | Gene-98 ID98 ## [99] chr1 28535-28985 - | Gene-99 ID99 ## [100] chr1 17917-18021 + | Gene-100 ID100 ## ------- ## seqinfo: 2 sequences from an unspecified genome; no seqlengths The additional information about the genes will also appear in rowData rowData(GeneExpressionMatrix) ## DataFrame with 100 rows and 2 columns ## name ID ## &lt;character&gt; &lt;character&gt; ## 1 Gene-1 ID1 ## 2 Gene-2 ID2 ## 3 Gene-3 ID3 ## 4 Gene-4 ID4 ## 5 Gene-5 ID5 ## ... ... ... ## 96 Gene-96 ID96 ## 97 Gene-97 ID97 ## 98 Gene-98 ID98 ## 99 Gene-99 ID99 ## 100 Gene-100 ID100 Finally we add some reduced dimension data which is needed for clustering reducedDim(GeneExpressionMatrix, &quot;PCA&quot;) &lt;- matrix(data=rnorm(20000), nrow=1000, ncol=20) GeneExpressionMatrix ## class: SingleCellExperiment ## dim: 100 1000 ## metadata(0): ## assays(1): counts ## rownames: NULL ## rowData names(2): name ID ## colnames: NULL ## colData names(1): Cluster ## reducedDimNames(1): PCA ## mainExpName: NULL ## altExpNames(0): Repeat the process to create a PeakMatrix # add counts counts &lt;- matrix(rpois(1000000, lambda = 1), ncol=1000, nrow=1000) PeakMatrix &lt;- SingleCellExperiment(list(counts=counts)) rownames(PeakMatrix) &lt;- paste(&quot;Peak&quot;,1:1000, sep=&quot;-&quot;) colnames(PeakMatrix) &lt;- paste(&quot;Cell&quot;,1:1000, sep=&quot;-&quot;) # convert count matrix to dgCMatrix counts(PeakMatrix) &lt;- as(counts(PeakMatrix), &quot;dgCMatrix&quot;) # add rowRanges seqnames &lt;- paste0(&quot;chr&quot;, sample(1:2, 1000, TRUE)) start &lt;- sample(1:100000, 1000, TRUE) end &lt;- start + sample(100:500, 1000, TRUE) strand &lt;- sample(c(&quot;+&quot;, &quot;-&quot;, &quot;*&quot;), 1000, TRUE) gr &lt;- GRanges( seqnames = seqnames, ranges = IRanges(start = start, end = end), strand = strand ) # add rowData mcols(gr) &lt;- DataFrame(name = paste(&quot;Peak&quot;, 1:1000, sep=&quot;-&quot;)) rowRanges(PeakMatrix) &lt;- gr # add reduced dimensionality matrix reducedDim(PeakMatrix, &quot;ATAC_LSI&quot;) &lt;- matrix(data=rnorm(20000), nrow=1000, ncol=20) PeakMatrix ## class: SingleCellExperiment ## dim: 1000 1000 ## metadata(0): ## assays(1): counts ## rownames: NULL ## rowData names(1): name ## colnames(1000): Cell-1 Cell-2 ... Cell-999 Cell-1000 ## colData names(0): ## reducedDimNames(1): ATAC_LSI ## mainExpName: NULL ## altExpNames(0): For more information on SingleCellExperiment, please refer to the documentation on bioconductor. For a real example of a properly formatted SingleCellExperiment object, check out datasets from the scMultiome package. Both the GeneExpressionMatrix and PeakMatrix are combined into a MultiAssayExperiment object. mae &lt;- scMultiome::reprogramSeq() ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache GeneExpressMatrix &lt;- mae[[&quot;GeneExpressMatrix &quot;]] GeneExpressMatrix ## NULL PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] PeakMatrix ## class: SingleCellExperiment ## dim: 126602 3903 ## metadata(1): .internal ## assays(1): counts ## rownames: NULL ## rowData names(1): idx ## colnames(3903): reprogram#TTAGGAACAAGGTACG-1 ## reprogram#GAGCGGTCAACCTGGT-1 ... reprogram#GGTTACTAGACACCGC-1 ## reprogram#CGCTATGAGTGAACAG-1 ## colData names(23): BlacklistRatio DoubletEnrichment ... ReadsInPeaks ## FRIP ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): 2.2 Starting from an ArchR object Epiregulon is designed to work seamlessly with ArchR. GeneExpressionMatrix and PeakMatrix can be easily exported from ArchR using ArchR’s build-in function. Download a test ArchR project library(ArchR) archr.proj &lt;- getTestProject() Check available matrices in ArchR project getAvailableMatrices(ArchRProj = archr.proj) ## [1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;MotifMatrix&quot; ## [4] &quot;PeakMatrix&quot; &quot;TileMatrix&quot; Export the GeneExpressionMatrix and PeakMatrix from the ArchR project. GeneExpressionMatrix &lt;- getMatrixFromProject(ArchRProj = archr.proj, useMatrix = &quot;GeneIntegrationMatrix&quot;) PeakMatrix &lt;- getMatrixFromProject(ArchRProj = archr.proj, useMatrix = &quot;PeakMatrix&quot;) GeneExpressionMatrix ## class: SummarizedExperiment ## dim: 2051 127 ## metadata(0): ## assays(1): GeneIntegrationMatrix ## rownames: NULL ## rowData names(6): seqnames start ... name idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un PeakMatrix ## class: RangedSummarizedExperiment ## dim: 2142 127 ## metadata(0): ## assays(1): PeakMatrix ## rownames: NULL ## rowData names(1): idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un The GeneExpressionMatrix and PeakMatrix exported from ArchR project are in the form of SummarizedExperiment and RangedSummarizedExperiment respectively. We provide a helper function to convert both to SingleCellExperiment class. Furthermore, the genomic location of the genes are transferred from rowData in the RangedSummarizedExperiment to the rowRanges of the SingleCellExperiment. Please note that GeneExpressionMatrix extracted from ArchR project contain normalized counts (not logged) and for clarity, we rename the assay as “normalizedCounts” library(epiregulon.archr) ## Loading required package: epiregulon ## ## Attaching package: &#39;epiregulon.archr&#39; ## The following objects are masked from &#39;package:epiregulon&#39;: ## ## addMotifScore, addTFMotifInfo, calculateP2G, getTFMotifInfo GeneExpressionMatrix &lt;- ArchRMatrix2SCE(rse = GeneExpressionMatrix, rename = &quot;normalizedCounts&quot;) GeneExpressionMatrix ## class: SingleCellExperiment ## dim: 2051 127 ## metadata(0): ## assays(1): normalizedCounts ## rownames: NULL ## rowData names(2): name idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): We can also transform the counts to logcounts. This will add a new assay and we name it as “logcounts”. GeneExpressionMatrix &lt;- ArchRMatrix2SCE(rse = GeneExpressionMatrix, transform = TRUE, transform_method = &quot;log&quot;, log_name = &quot;logcounts&quot;) GeneExpressionMatrix ## class: SingleCellExperiment ## dim: 2051 127 ## metadata(0): ## assays(2): counts logcounts ## rownames: NULL ## rowData names(2): name idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): Check that rowRanges have been transferred rowRanges(GeneExpressionMatrix) ## GRanges object with 2051 ranges and 2 metadata columns: ## seqnames ranges strand | name idx ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;integer&gt; ## [1] chr11 126987-139152 - | LINC01001 1 ## [2] chr11 193080-194573 + | SCGB1C1 2 ## [3] chr11 196761-200258 + | ODF3 3 ## [4] chr11 202924-207422 - | BET1L 4 ## [5] chr11 208530-215110 + | RIC8A 5 ## ... ... ... ... . ... ... ## [2047] chr5 180551357-180552304 - | OR2V1 827 ## [2048] chr5 180581943-180582890 + | OR2V2 828 ## [2049] chr5 180620924-180632177 - | TRIM7 829 ## [2050] chr5 180650263-180662808 + | TRIM41 830 ## [2051] chr5 180683386-180688119 - | TRIM52 831 ## ------- ## seqinfo: 2 sequences from an unspecified genome; no seqlengths We next convert the PeakMatrix to a SingleCellExperiment object. The counts exported from ArchR are raw counts and thus we rename the assay as “counts” PeakMatrix &lt;- ArchRMatrix2SCE(PeakMatrix, rename = &quot;counts&quot;) PeakMatrix ## class: SingleCellExperiment ## dim: 2142 127 ## metadata(0): ## assays(1): counts ## rownames: NULL ## rowData names(1): idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): Neither SummarizedExperiment object or RangedSummarizedExperiment object contains reduced dimension, so we must extract the reduced dimensionality matrix from the ArchR project and add it to GeneExpressionMatrix and/or PeakMatrix reducedDim(PeakMatrix, &quot;IterativeLSI&quot;) &lt;- getReducedDims(ArchRProj = archr.proj, reducedDims = &quot;IterativeLSI&quot;) Refer to ArchR manual for full documentation. 2.3 Starting from a Seurat/Signac object We download an example multimodel dataset from SeuratData. library(SeuratData) InstallData(&quot;pbmcMultiome&quot;) This is a PBMC dataset consisting of both RNAseq and ATACseq data and we load each modality as a separate Seurat object library(Seurat) ## Loading required package: SeuratObject ## Loading required package: sp ## ## Attaching package: &#39;sp&#39; ## The following object is masked from &#39;package:IRanges&#39;: ## ## %over% ## ## Attaching package: &#39;SeuratObject&#39; ## The following object is masked from &#39;package:SummarizedExperiment&#39;: ## ## Assays ## The following object is masked from &#39;package:GenomicRanges&#39;: ## ## intersect ## The following object is masked from &#39;package:GenomeInfoDb&#39;: ## ## intersect ## The following object is masked from &#39;package:IRanges&#39;: ## ## intersect ## The following object is masked from &#39;package:S4Vectors&#39;: ## ## intersect ## The following object is masked from &#39;package:BiocGenerics&#39;: ## ## intersect ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, t ## ## Attaching package: &#39;Seurat&#39; ## The following object is masked from &#39;package:SummarizedExperiment&#39;: ## ## Assays library(Signac) library(SeuratData) ## ── Installed datasets ──────────────────────────────── SeuratData v0.2.2.9001 ── ## ✔ pbmcMultiome 0.1.4 ## ────────────────────────────────────── Key ───────────────────────────────────── ## ✔ Dataset loaded successfully ## ❯ Dataset built with a newer version of Seurat than installed ## ❓ Unknown version of Seurat installed pbmc.rna &lt;- LoadData(&quot;pbmcMultiome&quot;, &quot;pbmc.rna&quot;) ## Validating object structure ## Updating object slots ## Ensuring keys are in the proper structure ## Ensuring keys are in the proper structure ## Ensuring feature names don&#39;t have underscores or pipes ## Updating slots in RNA ## Validating object structure for Assay &#39;RNA&#39; ## Object representation is consistent with the most current Seurat version ## Warning: Assay RNA changing from Assay to Assay5 pbmc.atac &lt;- LoadData(&quot;pbmcMultiome&quot;, &quot;pbmc.atac&quot;) ## Validating object structure ## Updating object slots ## Ensuring keys are in the proper structure ## Ensuring keys are in the proper structure ## Ensuring feature names don&#39;t have underscores or pipes ## Updating slots in ATAC ## Validating object structure for ChromatinAssay &#39;ATAC&#39; ## Object representation is consistent with the most current Seurat version We first convert the RNA Seurat object to GeneExpressionMatrix SingleCellExperiment class. GeneExpressionMatrix &lt;- as.SingleCellExperiment(pbmc.rna, assay=&quot;RNA&quot;) ## Warning: Layer &#39;scale.data&#39; is empty Because these genes are missing genomic positions, we must first annotate them with a genomic database, for example ensembl library(AnnotationHub) ah &lt;- AnnotationHub() edb &lt;- ah[[&quot;AH98047&quot;]] #&quot;EnsDb.Hsapiens.v105&quot; ## loading from cache ## require(&quot;ensembldb&quot;) gr &lt;- genes(edb, columns = c(&quot;gene_id&quot;, &quot;gene_name&quot;)) We retain only the genes that have genomic positions. The genomic positions are necessary to link peak positions to the nearby target genes. common_genes &lt;- na.omit(intersect(gr$gene_name, rownames(GeneExpressionMatrix))) GeneExpressionMatrix &lt;- GeneExpressionMatrix[common_genes,] rowRanges(GeneExpressionMatrix) &lt;- gr[match(common_genes, gr$gene_name)] rowRanges(GeneExpressionMatrix) ## GRanges object with 23644 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; ## ENSG00000243485 1 29554-31109 + | ENSG00000243485 ## ENSG00000237613 1 34554-36081 - | ENSG00000237613 ## ENSG00000186092 1 65419-71585 + | ENSG00000186092 ## ENSG00000284733 1 450740-451678 - | ENSG00000284733 ## ENSG00000284662 1 685716-686654 - | ENSG00000284662 ## ... ... ... ... . ... ## ENSG00000228296 Y 25063083-25099892 - | ENSG00000228296 ## ENSG00000223641 Y 25182277-25213389 - | ENSG00000223641 ## ENSG00000228786 Y 25378300-25394719 - | ENSG00000228786 ## ENSG00000172288 Y 25622162-25624902 + | ENSG00000172288 ## ENSG00000231141 Y 25728490-25733388 + | ENSG00000231141 ## gene_name ## &lt;character&gt; ## ENSG00000243485 MIR1302-2HG ## ENSG00000237613 FAM138A ## ENSG00000186092 OR4F5 ## ENSG00000284733 OR4F29 ## ENSG00000284662 OR4F16 ## ... ... ## ENSG00000228296 TTTY4C ## ENSG00000223641 TTTY17C ## ENSG00000228786 LINC00266-4P ## ENSG00000172288 CDY1 ## ENSG00000231141 TTTY3 ## ------- ## seqinfo: 456 sequences (1 circular) from GRCh38 genome We then convert ATAC matrix to PeakMatrix. After conversion to SingleCellExperiment, the peak positions appear as rownames and must be converted to GRanges. PeakMatrix &lt;- as.SingleCellExperiment(pbmc.atac, assay=&quot;ATAC&quot;) peak_position &lt;- strsplit(rownames(PeakMatrix), split = &quot;-&quot;) gr &lt;- GRanges( seqnames = sapply(peak_position,&quot;[&quot;,1), ranges = IRanges(start = as.numeric(sapply(peak_position,&quot;[&quot;,2)), end = as.numeric(sapply(peak_position,&quot;[&quot;,3))) ) rowRanges(PeakMatrix) &lt;- gr PeakMatrix ## class: SingleCellExperiment ## dim: 108377 11909 ## metadata(0): ## assays(2): counts logcounts ## rownames: NULL ## rowData names(0): ## colnames(11909): AAACAGCCAAGGAATC-1 AAACAGCCAATCCCTT-1 ... ## TTTGTTGGTTGGTTAG-1 TTTGTTGGTTTGCAGA-1 ## colData names(5): orig.ident nCount_ATAC nFeature_ATAC ## seurat_annotations ident ## reducedDimNames(0): ## mainExpName: ATAC ## altExpNames(0): For more information, refer to Signac tutorial 2.4 Starting from AnnData We download an example PBMC anndata dataset from scglue. We first import the GeneExpressionMatrix. library(zellkonverter) ## Registered S3 method overwritten by &#39;zellkonverter&#39;: ## method from ## py_to_r.pandas.core.arrays.categorical.Categorical reticulate library(GenomicRanges) library(SingleCellExperiment) url &lt;- &quot;http://download.gao-lab.org/GLUE/dataset/10x-Multiome-Pbmc10k-RNA.h5ad&quot; destfile &lt;- tempfile(fileext = &quot;.h5ad&quot;) # Download the file download.file(url, destfile, mode = &quot;wb&quot;) GeneExpressionMatrix &lt;- readH5AD(destfile) The field “chrom” “chromStart” “chromEnd” correspond to genomic positions of the genes. rowData(GeneExpressionMatrix) ## DataFrame with 29095 rows and 26 columns ## gene_ids feature_types genome chrom chromStart ## &lt;character&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt; ## AL627309.1 ENSG00000238009 Gene Expression GRCh38 chr1 89294 ## AL627309.5 ENSG00000241860 Gene Expression GRCh38 chr1 141473 ## AL627309.4 ENSG00000241599 Gene Expression GRCh38 chr1 160445 ## AP006222.2 ENSG00000286448 Gene Expression GRCh38 chr1 266854 ## AL669831.2 ENSG00000229905 Gene Expression GRCh38 chr1 760910 ## ... ... ... ... ... ... ## AC004556.3 ENSG00000276345 Gene Expression GRCh38 KI270721.1 2584 ## AC233755.2 ENSG00000277856 Gene Expression GRCh38 KI270726.1 26240 ## AC233755.1 ENSG00000275063 Gene Expression GRCh38 KI270726.1 41443 ## AC007325.1 ENSG00000276017 Gene Expression GRCh38 KI270734.1 72410 ## AC007325.4 ENSG00000278817 Gene Expression GRCh38 KI270734.1 131493 ## chromEnd name score strand thickStart thickEnd ## &lt;numeric&gt; &lt;character&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 133723 ENSG00000238009 . - . . ## AL627309.5 173862 ENSG00000241860 . - . . ## AL627309.4 161525 ENSG00000241599 . + . . ## AP006222.2 268655 ENSG00000286448 . + . . ## AL669831.2 761989 ENSG00000229905 . + . . ## ... ... ... ... ... ... ... ## AC004556.3 11802 ENSG00000276345 . + . . ## AC233755.2 26534 ENSG00000277856 . + . . ## AC233755.1 41876 ENSG00000275063 . + . . ## AC007325.1 74814 ENSG00000276017 . + . . ## AC007325.4 137392 ENSG00000278817 . + . . ## itemRgb blockCount blockSizes blockStarts gene_type gene_name ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 . . . . lncRNA AL627309.1 ## AL627309.5 . . . . lncRNA AL627309.5 ## AL627309.4 . . . . lncRNA AL627309.4 ## AP006222.2 . . . . lncRNA AP006222.2 ## AL669831.2 . . . . lncRNA AL669831.2 ## ... ... ... ... ... ... ... ## AC004556.3 . . . . protein_coding AC004556.3 ## AC233755.2 . . . . protein_coding AC233755.2 ## AC233755.1 . . . . protein_coding AC233755.1 ## AC007325.1 . . . . protein_coding AC007325.1 ## AC007325.4 . . . . protein_coding AC007325.4 ## hgnc_id havana_gene tag n_counts ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt; ## AL627309.1 NA OTTHUMG00000001096.2 overlapping_locus 70 ## AL627309.5 NA OTTHUMG00000002480.4 ncRNA_host 442 ## AL627309.4 NA OTTHUMG00000002525.1 NA 44 ## AP006222.2 NA OTTHUMG00000194680.1 NA 1 ## AL669831.2 NA OTTHUMG00000002408.1 NA 10 ## ... ... ... ... ... ## AC004556.3 NA NA NA 320 ## AC233755.2 NA NA NA 1 ## AC233755.1 NA NA NA 1 ## AC007325.1 NA NA NA 3 ## AC007325.4 NA NA NA 43 ## highly_variable highly_variable_rank means variances ## &lt;logical&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AL627309.1 FALSE NaN 0.007268196 0.008462225 ## AL627309.5 FALSE NaN 0.045893469 0.050853072 ## AL627309.4 FALSE NaN 0.004568581 0.004755865 ## AP006222.2 FALSE NaN 0.000103831 0.000103831 ## AL669831.2 FALSE NaN 0.001038314 0.001037343 ## ... ... ... ... ... ## AC004556.3 FALSE NaN 0.033226041 0.035448356 ## AC233755.2 FALSE NaN 0.000103831 0.000103831 ## AC233755.1 FALSE NaN 0.000103831 0.000103831 ## AC007325.1 FALSE NaN 0.000311494 0.000311429 ## AC007325.4 FALSE NaN 0.004464749 0.004445277 ## variances_norm ## &lt;numeric&gt; ## AL627309.1 0.971895 ## AL627309.5 0.888672 ## AL627309.4 0.891707 ## AP006222.2 0.999904 ## AL669831.2 0.933916 ## ... ... ## AC004556.3 0.856870 ## AC233755.2 0.999904 ## AC233755.1 0.999904 ## AC007325.1 0.975766 ## AC007325.4 0.854162 They must be renamed to “seqnames” “start” and “end” before conversion to GRanges index_to_rename &lt;- match(c(&quot;chrom&quot;, &quot;chromStart&quot;, &quot;chromEnd&quot;), colnames(rowData(GeneExpressionMatrix))) colnames(rowData(GeneExpressionMatrix))[index_to_rename] &lt;- c(&quot;seqnames&quot;, &quot;start&quot;, &quot;end&quot;) rowRanges(GeneExpressionMatrix) &lt;- GRanges(rowData(GeneExpressionMatrix)) rowRanges(GeneExpressionMatrix) ## GRanges object with 29095 ranges and 22 metadata columns: ## seqnames ranges strand | gene_ids feature_types ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## AL627309.1 chr1 89294-133723 - | ENSG00000238009 Gene Expression ## AL627309.5 chr1 141473-173862 - | ENSG00000241860 Gene Expression ## AL627309.4 chr1 160445-161525 + | ENSG00000241599 Gene Expression ## AP006222.2 chr1 266854-268655 + | ENSG00000286448 Gene Expression ## AL669831.2 chr1 760910-761989 + | ENSG00000229905 Gene Expression ## ... ... ... ... . ... ... ## AC004556.3 KI270721.1 2584-11802 + | ENSG00000276345 Gene Expression ## AC233755.2 KI270726.1 26240-26534 + | ENSG00000277856 Gene Expression ## AC233755.1 KI270726.1 41443-41876 + | ENSG00000275063 Gene Expression ## AC007325.1 KI270734.1 72410-74814 + | ENSG00000276017 Gene Expression ## AC007325.4 KI270734.1 131493-137392 + | ENSG00000278817 Gene Expression ## genome name score thickStart thickEnd itemRgb ## &lt;factor&gt; &lt;character&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 GRCh38 ENSG00000238009 . . . . ## AL627309.5 GRCh38 ENSG00000241860 . . . . ## AL627309.4 GRCh38 ENSG00000241599 . . . . ## AP006222.2 GRCh38 ENSG00000286448 . . . . ## AL669831.2 GRCh38 ENSG00000229905 . . . . ## ... ... ... ... ... ... ... ## AC004556.3 GRCh38 ENSG00000276345 . . . . ## AC233755.2 GRCh38 ENSG00000277856 . . . . ## AC233755.1 GRCh38 ENSG00000275063 . . . . ## AC007325.1 GRCh38 ENSG00000276017 . . . . ## AC007325.4 GRCh38 ENSG00000278817 . . . . ## blockCount blockSizes blockStarts gene_type gene_name ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 . . . lncRNA AL627309.1 ## AL627309.5 . . . lncRNA AL627309.5 ## AL627309.4 . . . lncRNA AL627309.4 ## AP006222.2 . . . lncRNA AP006222.2 ## AL669831.2 . . . lncRNA AL669831.2 ## ... ... ... ... ... ... ## AC004556.3 . . . protein_coding AC004556.3 ## AC233755.2 . . . protein_coding AC233755.2 ## AC233755.1 . . . protein_coding AC233755.1 ## AC007325.1 . . . protein_coding AC007325.1 ## AC007325.4 . . . protein_coding AC007325.4 ## hgnc_id havana_gene tag n_counts ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt; ## AL627309.1 NA OTTHUMG00000001096.2 overlapping_locus 70 ## AL627309.5 NA OTTHUMG00000002480.4 ncRNA_host 442 ## AL627309.4 NA OTTHUMG00000002525.1 NA 44 ## AP006222.2 NA OTTHUMG00000194680.1 NA 1 ## AL669831.2 NA OTTHUMG00000002408.1 NA 10 ## ... ... ... ... ... ## AC004556.3 NA NA NA 320 ## AC233755.2 NA NA NA 1 ## AC233755.1 NA NA NA 1 ## AC007325.1 NA NA NA 3 ## AC007325.4 NA NA NA 43 ## highly_variable highly_variable_rank means variances ## &lt;logical&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AL627309.1 FALSE NaN 0.007268196 0.008462225 ## AL627309.5 FALSE NaN 0.045893469 0.050853072 ## AL627309.4 FALSE NaN 0.004568581 0.004755865 ## AP006222.2 FALSE NaN 0.000103831 0.000103831 ## AL669831.2 FALSE NaN 0.001038314 0.001037343 ## ... ... ... ... ... ## AC004556.3 FALSE NaN 0.033226041 0.035448356 ## AC233755.2 FALSE NaN 0.000103831 0.000103831 ## AC233755.1 FALSE NaN 0.000103831 0.000103831 ## AC007325.1 FALSE NaN 0.000311494 0.000311429 ## AC007325.4 FALSE NaN 0.004464749 0.004445277 ## variances_norm ## &lt;numeric&gt; ## AL627309.1 0.971895 ## AL627309.5 0.888672 ## AL627309.4 0.891707 ## AP006222.2 0.999904 ## AL669831.2 0.933916 ## ... ... ## AC004556.3 0.856870 ## AC233755.2 0.999904 ## AC233755.1 0.999904 ## AC007325.1 0.975766 ## AC007325.4 0.854162 ## ------- ## seqinfo: 34 sequences from an unspecified genome; no seqlengths We next import the PeakMatrix. The rownames are already in the format of seqnames:start-end, so rowRanges can be extracted directly from rowData. library(zellkonverter) url &lt;- &quot;http://download.gao-lab.org/GLUE/dataset/10x-Multiome-Pbmc10k-ATAC.h5ad&quot; destfile &lt;- tempfile(fileext = &quot;.h5ad&quot;) # Download the file download.file(url, destfile, mode = &quot;wb&quot;) PeakMatrix &lt;- readH5AD(destfile) rowRanges(PeakMatrix) &lt;- GRanges(rowData(PeakMatrix)) rowRanges(PeakMatrix) ## GRanges object with 107194 ranges and 3 metadata columns: ## seqnames ranges strand | feature_types ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; ## chr1:816881-817647 chr1 816881-817647 * | Peaks ## chr1:819912-823500 chr1 819912-823500 * | Peaks ## chr1:825827-825889 chr1 825827-825889 * | Peaks ## chr1:826612-827979 chr1 826612-827979 * | Peaks ## chr1:841243-843059 chr1 841243-843059 * | Peaks ## ... ... ... ... . ... ## KI270713.1:20444-22615 KI270713.1 20444-22615 * | Peaks ## KI270713.1:27118-28927 KI270713.1 27118-28927 * | Peaks ## KI270713.1:29485-30706 KI270713.1 29485-30706 * | Peaks ## KI270713.1:31511-32072 KI270713.1 31511-32072 * | Peaks ## KI270713.1:37129-37638 KI270713.1 37129-37638 * | Peaks ## genome n_counts ## &lt;factor&gt; &lt;numeric&gt; ## chr1:816881-817647 GRCh38 1025 ## chr1:819912-823500 GRCh38 1384 ## chr1:825827-825889 GRCh38 20 ## chr1:826612-827979 GRCh38 4555 ## chr1:841243-843059 GRCh38 555 ## ... ... ... ## KI270713.1:20444-22615 GRCh38 12640 ## KI270713.1:27118-28927 GRCh38 533 ## KI270713.1:29485-30706 GRCh38 622 ## KI270713.1:31511-32072 GRCh38 207 ## KI270713.1:37129-37638 GRCh38 388 ## ------- ## seqinfo: 32 sequences from an unspecified genome; no seqlengths This example SingleCellExperiment dataset is missing the dimensionality reduction information. Users should have been this precalculated. Refer to the section on how to import from csv files, or refer to OSCA book on how to perform dimensionality reduction. 2.5 Starting from 10x data formats 2.5.1 Reading from .h5 file We first download the publicly available PBMC data from 10x Genomics url &lt;- &quot;https://cf.10xgenomics.com/samples/cell-arc/1.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5&quot; destfile &lt;- tempfile(fileext = &quot;.h5&quot;) # Download the file download.file(url, destfile, mode = &quot;wb&quot;) This .h5 file contains both genes and peak regions as features, so we read in all the features into a single SingleCellExperiment, and we can specify “Gene Expression” as the main experiment and “Peaks” as the alternative experiment. We then split this single object into 2 separate SingleCellExperiment objects for consistency with other sections. library(DropletUtils) sce10x &lt;- read10xCounts(destfile) sce10x &lt;- splitAltExps(sce10x, f=rowData(sce10x)$Type, ref=&quot;Gene Expression&quot;) peakMatrix &lt;- altExp(sce10x) rowRanges(peakMatrix) &lt;- GRanges(rownames(peakMatrix)) GeneExpressionMatrix &lt;- removeAltExps(sce10x) 2.5.2 Reading directly from a 10x directory We can also create a SingleCellExperiment object from a directory containing “matrix.mtx.gz”, “barcodes.tsv.gz” and “features.tsv.gz” example(write10xCounts) ## ## wrt10C&gt; # Mocking up some count data. ## wrt10C&gt; library(Matrix) ## ## wrt10C&gt; my.counts &lt;- matrix(rpois(1000, lambda=5), ncol=10, nrow=100) ## ## wrt10C&gt; my.counts &lt;- as(my.counts, &quot;CsparseMatrix&quot;) ## ## wrt10C&gt; cell.ids &lt;- paste0(&quot;BARCODE-&quot;, seq_len(ncol(my.counts))) ## ## wrt10C&gt; ngenes &lt;- nrow(my.counts) ## ## wrt10C&gt; gene.ids &lt;- paste0(&quot;ENSG0000&quot;, seq_len(ngenes)) ## ## wrt10C&gt; gene.symb &lt;- paste0(&quot;GENE&quot;, seq_len(ngenes)) ## ## wrt10C&gt; # Writing this to file: ## wrt10C&gt; tmpdir &lt;- tempfile() ## ## wrt10C&gt; write10xCounts(tmpdir, my.counts, gene.id=gene.ids, ## wrt10C+ gene.symbol=gene.symb, barcodes=cell.ids) ## ## wrt10C&gt; list.files(tmpdir) ## [1] &quot;barcodes.tsv&quot; &quot;genes.tsv&quot; &quot;matrix.mtx&quot; ## ## wrt10C&gt; # Creating a version 3 HDF5 file: ## wrt10C&gt; tmph5 &lt;- tempfile(fileext=&quot;.h5&quot;) ## ## wrt10C&gt; write10xCounts(tmph5, my.counts, gene.id=gene.ids, ## wrt10C+ gene.symbol=gene.symb, barcodes=cell.ids, version=&#39;3&#39;) list.files(tmpdir) ## [1] &quot;barcodes.tsv&quot; &quot;genes.tsv&quot; &quot;matrix.mtx&quot; sce10x &lt;- read10xCounts(tmpdir) Follow the section on Constructing a SingleCellExperiment object on how to construct SingleCellExperiment, add colData, rowData and reduced dimensions 2.6 Reading directly from CSV If the count matrices are in the form of csv files, read in the count matrix as a sparse matrix and convert it to a dgCMatrix. library(SparseArray) counts &lt;- readSparseCSV(&quot;counts.csv&quot;) counts &lt;- as(counts, &quot;dgCMatrix&quot;) Then read in the genomic positions as data.frame and convert it to a GRanges. peak_position &lt;- read.csv(&quot;peaks.csv&quot;) peak_position &lt;- data.frame(peak_position) gr &lt;- GenomicRanges::makeGRangesFromDataFrame(peak_position) Refer to the section on Constructing a SingleCellExperiment object on how to construct SingleCellExperiment, add colData, rowData and reduced dimensions. 2.7 Important points Finally, we would like to emphasize again the importance of converting all count matrices to dgCMatrix for speed and compatibility. Both gene expression and peak matrices require rowRanges to indicate genomic positions of target gene position and peak position. "],["basic-workflow-with-multiassayexperiment.html", "3 Basic workflow with MultiAssayExperiment 3.1 Data preparation 3.2 Quick start 3.3 Session Info", " 3 Basic workflow with MultiAssayExperiment In this chapter, we illustrate the epiregulon workflow starting from data in the form of SingleCellExperiment objects using the correlation weight estimation method. This tutorial demonstrates the basic functions of epiregulon, using the reprogram-seq dataset which can be downloaded from the scMultiome package. In this example, prostate cancer cells (LNCaP) were infected in separate wells with viruses encoding 4 transcription factors (NKX2-1, GATA6, FOXA1 and FOXA2) and a positive control (mNeonGreen) before pooling. The identity of the infected transcription factors was tracked through cell hashing (available in the field hash_assignment of the colData) and serves as the ground truth. 3.1 Data preparation Prior to using epiregulon, single cell preprocessing needs to performed by user’s favorite methods. The following components are required: 1. Peak matrix from scATAC-seq containing the chromatin accessibility information 2. Gene expression matrix from either paired or unpaired scRNA-seq. RNA-seq integration needs to be performed for unpaired dataset. 3. Dimensionality reduction matrix from with either single modalities or joint scRNA-seq and scATAC-seq # load the MAE object library(scMultiome) library(epiregulon) mae &lt;- scMultiome::reprogramSeq() # extract peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # extract expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name # define the order of hash_assigment GeneExpressionMatrix$hash_assignment &lt;- factor(as.character(GeneExpressionMatrix$hash_assignment), levels = c(&quot;HTO10_GATA6_UTR&quot;, &quot;HTO2_GATA6_v2&quot;, &quot;HTO8_NKX2.1_UTR&quot;, &quot;HTO3_NKX2.1_v2&quot;, &quot;HTO1_FOXA2_v2&quot;, &quot;HTO4_mFOXA1_v2&quot;, &quot;HTO6_hFOXA1_UTR&quot;, &quot;HTO5_NeonG_v2&quot;)) # extract dimensional reduction matrix reducedDimMatrix &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;LSI_ATAC&quot;) # transfer UMAP_combined from TileMatrix to GeneExpressionMatrix reducedDim(GeneExpressionMatrix, &quot;UMAP_Combined&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;UMAP_Combined&quot;) Visualize singleCellExperiment by UMAP scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_Combined&quot;, text_by = &quot;Clusters&quot;, colour_by = &quot;Clusters&quot;) 3.2 Quick start 3.2.1 Retrieve bulk TF ChIP-seq binding sites First, we retrieve a GRangesList object containing the binding sites of all the transcription factors and co-regulators. These binding sites are derived from bulk ChIP-seq data in the ChIP-Atlas and ENCODE databases. For the same transcription factor, multiple ChIP-seq files from different cell lines or tissues are merged. For further information on how these peaks are derived, please refer to ?epiregulon::getTFMotifInfo. Currently, human genomes hg19 and hg38 and mouse mm10 are supported. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 3.2.2 Link ATAC-seq peaks to target genes Next, we try to link ATAC-seq peaks to their putative target genes. We assign a peak to a gene within a size window (default ±250kb) if the chromatin accessibility of the peak and expression of the target genes are highly correlated (default threshold 0.5). To compute correlations, we first create cell aggregates by performing k-means clustering on the reduced dimensionality matrix. Then we aggregate the counts of the gene expression and peak matrix and average across the number of cells. Correlations are computed on the averaged gene expression and chromatin accessibility. If cluster labels are provided, peak-to-gene correlations are computed on all the cells and for each cluster. Peak-to-gene links are retained as long as any of the correlations pass the threshold; the longer list of peak-to-gene links capture both inter- and intra-cluster variations. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, reducedDim = reducedDimMatrix, exp_assay = &quot;normalizedCounts&quot;, peak_assay = &quot;counts&quot;) ## Using epiregulon to compute peak to gene links... ## performing k means clustering to form metacells ## Computing correlation p2g ## DataFrame with 7892 rows and 8 columns ## idxATAC chr start end idxRNA target Correlation ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; ## 1 37 chr1 1020509 1021009 22 AL645608.4 0.592745 ## 2 39 chr1 1039811 1040311 33 AGRN 0.523777 ## 3 42 chr1 1053517 1054017 33 AGRN 0.521471 ## 4 86 chr1 1290083 1290583 58 DVL1 0.524540 ## 5 104 chr1 1343943 1344443 66 AL391244.1 0.515194 ## ... ... ... ... ... ... ... ... ## 7888 126535 chrX 154368842 154369342 36389 FLNA 0.852869 ## 7889 126536 chrX 154369373 154369873 36389 FLNA 0.828660 ## 7890 126537 chrX 154370531 154371031 36389 FLNA 0.573066 ## 7891 126541 chrX 154374945 154375445 36389 FLNA 0.572236 ## 7892 126590 chrX 155228844 155229344 36426 CLIC2 0.527470 ## distance ## &lt;integer&gt; ## 1 106338 ## 2 19691 ## 3 33397 ## 4 58527 ## 5 75800 ## ... ... ## 7888 1878 ## 7889 1347 ## 7890 189 ## 7891 3723 ## 7892 105268 3.2.3 Add TF motif binding to peaks The next step is to add the TF binding information by overlapping regions of the peak matrix with the bulk chip-seq database. The output is a data frame object with three columns: idxATAC - index of the peak in the peak matrix idxTF - index in the gene expression matrix corresponding to the transcription factor tf - name of the transcription factor overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) ## Computing overlap... ## Success! head(overlap) ## idxATAC idxTF tf ## 9312 37 4 AGO1 ## 9313 37 7 ARID1B ## 9314 37 8 ARID2 ## 9315 37 18 ATF3 ## 9316 37 21 ATF7 ## 9317 37 23 BACH1 3.2.4 Generate regulons A DataFrame, representing the inferred regulons, is then generated. The DataFrame consists of ten columns: idxATAC - index of the peak in the peak matrix chr - chromosome number start - start position of the peak end - end position of the peak idxRNA - index in the gene expression matrix corresponding to the target gene target - name of the target gene distance - distance between the transcription start site of the target gene and the middle of the peak idxTF - index in the gene expression matrix corresponding to the transcription factor tf - name of the transcription factor corr - correlation between target gene expression and the chromatin accessibility at the peak. if cluster labels are provided, this field is a matrix with columns names corresponding to correlation across all cells and for each of the clusters. regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 743656 rows and 10 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 37 chr1 1020509 1021009 22 AL645608.4 ## 2 37 chr1 1020509 1021009 22 AL645608.4 ## 3 37 chr1 1020509 1021009 22 AL645608.4 ## 4 37 chr1 1020509 1021009 22 AL645608.4 ## 5 37 chr1 1020509 1021009 22 AL645608.4 ## ... ... ... ... ... ... ... ## 743652 126541 chrX 154374945 154375445 36389 FLNA ## 743653 126541 chrX 154374945 154375445 36389 FLNA ## 743654 126590 chrX 155228844 155229344 36426 CLIC2 ## 743655 126590 chrX 155228844 155229344 36426 CLIC2 ## 743656 126590 chrX 155228844 155229344 36426 CLIC2 ## distance idxTF tf corr ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 106338 4 AGO1 0.592745 ## 2 106338 7 ARID1B 0.592745 ## 3 106338 8 ARID2 0.592745 ## 4 106338 18 ATF3 0.592745 ## 5 106338 21 ATF7 0.592745 ## ... ... ... ... ... ## 743652 3723 1492 ZNF692 0.572236 ## 743653 3723 1557 ZXDB 0.572236 ## 743654 105268 114 FOXA1 0.527470 ## 743655 105268 128 GATA2 0.527470 ## 743656 105268 952 SUMO2 0.527470 3.2.5 Network pruning (highly recommended) Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. The users can choose between two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the category of “active TF” is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon[regulon$tf %in% c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;),], clusters = GeneExpressionMatrix$Clusters, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05 ) pruned.regulon 3.2.6 Add Weights While the pruneRegulon function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the three measures: 1) correlation between TF and target gene expression, 2) mutual information between the TF and target gene expression and 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Two of the measures (correlation and Wilcoxon statistics) give both the magnitude and directionality of changes whereas mutual information is always positive. The correlation and mutual information statistics are computed on pseudobulks aggregated by user-supplied cluster labels, whereas the Wilcoxon method groups cells into two categories: 1) the active category of cells jointly expressing TF, RE and TG and 2) the inactive category consisting of the remaining cells. We calculate cluster-specific weights if users supply cluster labels. regulon.w &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$Clusters, method = &quot;wilcox&quot;) regulon.w 3.2.7 (Optional) Annotate with TF motifs So far the gene regulatory network was constructed from TF ChIP-seq exclusively. Some users would prefer to further annotate regulatory elements with the presence of motifs. We provide an option to annotate peaks with motifs from the Cisbp database. If no motifs are present for this particular factor (as in the case of co-factors or chromatin modifiers), we return NA. If motifs are available for a factor and the RE contains a motif, we return 1. If motifs are available and the RE does not contain a motif, we return 0. regulon.w.motif &lt;- addMotifScore(regulon = regulon.w, peaks = rowRanges(PeakMatrix), species = &quot;human&quot;, genome = &quot;hg38&quot;) # if desired, set weight to 0 if no motif is found regulon.w.motif$weight[regulon.w.motif$motif == 0] &lt;- 0 regulon.w.motif ## DataFrame with 3290 rows and 15 columns ## idxATAC chr start end idxRNA target distance ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt; ## 1 86 chr1 1290083 1290583 58 DVL1 58527 ## 2 288 chr1 2526365 2526865 108 AL139246.1 33107 ## 3 640 chr1 7988538 7989038 208 TNFRSF9 47672 ## 4 654 chr1 8040536 8041036 212 ERRFI1 24903 ## 5 787 chr1 9290024 9290524 229 SPSB1 2368 ## ... ... ... ... ... ... ... ... ## 3286 120296 chr9 36118633 36119133 34311 CLTA 71721 ## 3287 121835 chr9 98192900 98193400 34702 CORO2A 20016 ## 3288 122254 chr9 108991440 108991940 34784 CTNNAL1 27885 ## 3289 122461 chr9 113174265 113174765 34825 SLC31A1 46777 ## 3290 123380 chr9 128635245 128635745 35034 SPTAN1 82687 ## idxTF tf corr pval ## &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 490 AR 0.524540 1.91265e-03:0.50585953:0.000249278:... ## 2 490 AR 0.602193 5.02384e-02:0.00249757:1.000000000:... ## 3 490 AR 0.875387 7.53206e-09:0.15249790:1.000000000:... ## 4 490 AR 0.550906 9.18676e-02:0.76535176:1.000000000:... ## 5 490 AR 0.891738 9.64012e-13:0.51358560:1.000000000:... ## ... ... ... ... ... ## 3286 807 NKX2-1 0.522644 0.035831331:1:1:... ## 3287 807 NKX2-1 0.541195 0.000419607:1:1:... ## 3288 807 NKX2-1 0.872888 0.013099814:1:1:... ## 3289 807 NKX2-1 0.683659 0.045120208:1:1:... ## 3290 807 NKX2-1 0.745530 0.045120208:1:1:... ## stats qval weight ## &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 9.63153:0.4426222:13.4176:... 1.00000e+00:1:1:... 0:0:0:... ## 2 3.83348:9.1423696: 0.0000:... 1.00000e+00:1:1:... 0:0:0:... ## 3 33.39232:2.0470852: 0.0000:... 1.24761e-04:1:1:... 0:0:0:... ## 4 2.84134:0.0890786: 0.0000:... 1.00000e+00:1:1:... 0:0:0:... ## 5 50.91607:0.4267549: 0.0000:... 1.60836e-08:1:1:... 0:0:0:... ## ... ... ... ... ## 3286 4.40511:0:0:... 1:1:1:... 0.0343753:0:0:... ## 3287 12.44280:0:0:... 1:1:1:... 0.0000000:0:0:... ## 3288 6.15558:0:0:... 1:1:1:... 0.0000000:0:0:... ## 3289 4.01414:0:0:... 1:1:1:... 0.0000000:0:0:... ## 3290 4.01414:0:0:... 1:1:1:... 0.0000000:0:0:... ## motif ## &lt;numeric&gt; ## 1 0 ## 2 0 ## 3 0 ## 4 0 ## 5 0 ## ... ... ## 3286 1 ## 3287 0 ## 3288 0 ## 3289 0 ## 3290 0 3.2.8 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging expressions of target genes linked to the TF weighted by the test statistics of choice, chosen from either correlation, mutual information or the Wilcoxon test statistics. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weights_i\\] where \\(y\\) is the activity of a TF for a cell, \\(n\\) is the total number of targets for a TF, \\(x_i\\) is the log count expression of target \\(i\\) where \\(i\\) in {1,2,…,n} and \\(weights_i\\) is the weight of TF - target \\(i\\) score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;, exp_assay = &quot;normalizedCounts&quot;, normalize = FALSE) ## calculating TF activity from regulon using weightedmean ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, regulon = ## regulon.w, : The weight column contains multiple subcolumns but no cluster ## information was provided. Using first column to compute activity... ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by the number of targets... score.combine[1:5,1:5] ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## reprogram#TTAGGAACAAGGTACG-1 reprogram#GAGCGGTCAACCTGGT-1 ## AR 0.043408741 0.06010198 ## FOXA1 0.035260181 0.04408534 ## FOXA2 0.008868738 0.04479888 ## GATA6 0.033885727 0.13969050 ## NKX2-1 0.065298024 0.02791934 ## reprogram#TTATAGCCACCCTCAC-1 reprogram#TGGTGATTCCTGTTCA-1 ## AR 0.02734512 0.03422265 ## FOXA1 0.01708987 0.01827346 ## FOXA2 0.01153884 0.01998275 ## GATA6 0.01667011 0.01904236 ## NKX2-1 0.01410221 0.01023911 ## reprogram#TCGGTTCTCACTAGGT-1 ## AR 0.04019227 ## FOXA1 0.03426071 ## FOXA2 0.01368200 ## GATA6 0.02905760 ## NKX2-1 0.05365239 3.3 Session Info sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Red Hat Enterprise Linux 8.6 (Ootpa) ## ## Matrix products: default ## BLAS/LAPACK: /apps/rocs/2020.08/cascadelake/software/OpenBLAS/0.3.9-GCC-9.3.0/lib/libopenblas_skylakexp-r0.3.9.so; LAPACK version 3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/Los_Angeles ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.73.1 ## [3] rtracklayer_1.65.0 BiocIO_1.15.2 ## [5] Biostrings_2.73.2 XVector_0.45.0 ## [7] epiregulon_1.3.4 scMultiome_1.5.7 ## [9] SingleCellExperiment_1.27.2 MultiAssayExperiment_1.31.5 ## [11] SummarizedExperiment_1.35.4 Biobase_2.65.1 ## [13] GenomicRanges_1.57.2 GenomeInfoDb_1.41.2 ## [15] IRanges_2.39.2 S4Vectors_0.43.2 ## [17] MatrixGenerics_1.17.0 matrixStats_1.4.1 ## [19] ExperimentHub_2.13.1 AnnotationHub_3.13.3 ## [21] BiocFileCache_2.13.2 dbplyr_2.5.0 ## [23] BiocGenerics_0.51.3 BiocStyle_2.33.1 ## ## loaded via a namespace (and not attached): ## [1] later_1.3.2 bitops_1.0-9 ## [3] filelock_1.0.3 R.oo_1.26.0 ## [5] tibble_3.2.1 XML_3.99-0.17 ## [7] DirichletMultinomial_1.47.0 lifecycle_1.0.4 ## [9] pwalign_1.1.0 edgeR_4.3.19 ## [11] processx_3.8.4 lattice_0.22-6 ## [13] backports_1.5.0 magrittr_2.0.3 ## [15] limma_3.61.12 sass_0.4.9 ## [17] rmarkdown_2.28 jquerylib_0.1.4 ## [19] yaml_2.3.10 metapod_1.13.0 ## [21] cowplot_1.1.3 chromote_0.3.1 ## [23] DBI_1.2.3 CNEr_1.41.0 ## [25] abind_1.4-8 zlibbioc_1.51.1 ## [27] R.utils_2.12.3 purrr_1.0.2 ## [29] RCurl_1.98-1.16 pracma_2.4.4 ## [31] rappdirs_0.3.3 GenomeInfoDbData_1.2.13 ## [33] ggrepel_0.9.6 irlba_2.3.5.1 ## [35] seqLogo_1.71.0 annotate_1.83.0 ## [37] dqrng_0.4.1 codetools_0.2-20 ## [39] DelayedArray_0.31.14 scuttle_1.15.4 ## [41] tidyselect_1.2.1 UCSC.utils_1.1.0 ## [43] farver_2.1.2 ScaledMatrix_1.13.0 ## [45] viridis_0.6.5 GenomicAlignments_1.41.0 ## [47] jsonlite_1.8.9 BiocNeighbors_1.99.2 ## [49] motifmatchr_1.27.0 scater_1.33.4 ## [51] tools_4.4.0 TFMPvalue_0.0.9 ## [53] Rcpp_1.0.13 glue_1.8.0 ## [55] gridExtra_2.3 SparseArray_1.5.44 ## [57] xfun_0.48 websocket_1.4.2 ## [59] dplyr_1.1.4 HDF5Array_1.33.8 ## [61] withr_3.0.1 BiocManager_1.30.25 ## [63] fastmap_1.2.0 rhdf5filters_1.17.0 ## [65] bluster_1.15.1 fansi_1.0.6 ## [67] caTools_1.18.3 digest_0.6.37 ## [69] rsvd_1.0.5 R6_2.5.1 ## [71] mime_0.12 colorspace_2.1-1 ## [73] GO.db_3.20.0 poweRlaw_0.80.0 ## [75] gtools_3.9.5 RSQLite_2.3.7 ## [77] R.methodsS3_1.8.2 utf8_1.2.4 ## [79] generics_0.1.3 httr_1.4.7 ## [81] S4Arrays_1.5.10 TFBSTools_1.43.0 ## [83] pkgconfig_2.0.3 gtable_0.3.5 ## [85] blob_1.2.4 htmltools_0.5.8.1 ## [87] bookdown_0.40 scales_1.3.0 ## [89] png_0.1-8 scran_1.33.2 ## [91] knitr_1.48 rstudioapi_0.16.0 ## [93] tzdb_0.4.0 reshape2_1.4.4 ## [95] rjson_0.2.23 checkmate_2.3.2 ## [97] curl_5.2.3 cachem_1.1.0 ## [99] rhdf5_2.49.0 stringr_1.5.1 ## [101] BiocVersion_3.20.0 parallel_4.4.0 ## [103] vipor_0.4.7 AnnotationDbi_1.67.0 ## [105] restfulr_0.0.15 pillar_1.9.0 ## [107] grid_4.4.0 vctrs_0.6.5 ## [109] promises_1.3.0 BiocSingular_1.21.4 ## [111] beachmat_2.21.6 xtable_1.8-4 ## [113] cluster_2.1.6 beeswarm_0.4.0 ## [115] evaluate_1.0.1 readr_2.1.5 ## [117] cli_3.6.3 locfit_1.5-9.10 ## [119] compiler_4.4.0 Rsamtools_2.21.2 ## [121] rlang_1.1.4 crayon_1.5.3 ## [123] labeling_0.4.3 ps_1.8.0 ## [125] plyr_1.8.9 ggbeeswarm_0.7.2 ## [127] stringi_1.8.4 viridisLite_0.4.2 ## [129] BiocParallel_1.39.0 munsell_0.5.1 ## [131] Matrix_1.7-0 hms_1.1.3 ## [133] bit64_4.5.2 ggplot2_3.5.1 ## [135] Rhdf5lib_1.27.0 KEGGREST_1.45.1 ## [137] statmod_1.5.0 highr_0.11 ## [139] beachmat.hdf5_1.3.3 igraph_2.0.3 ## [141] memoise_2.0.1 bslib_0.8.0 ## [143] bit_4.5.0 "],["advanced-workflow-with-multiassayexperiment.html", "4 Advanced workflow with MultiAssayExperiment 4.1 Data preparation 4.2 Retrieve bulk TF ChIP-seq binding sites 4.3 Link ATACseq peaks to target genes 4.4 Add TF motif binding to peaks 4.5 Generate regulons 4.6 Prune network 4.7 Add Weights 4.8 Calculate TF activity 4.9 Differential TF activity test 4.10 Visualizing TF activities 4.11 Geneset enrichment 4.12 Differential Network analysis 4.13 Session Info", " 4 Advanced workflow with MultiAssayExperiment In this chapter, we illustrate the epiregulon workflow starting from data in the form of SingleCellExperiment objects using the Wilcoxon weight estimation method. This is a dataset of hematopoiesis from the ArchR tutorial. Prior to using epiregulon, this dataset has been fully preprocessed in ArchR, and converted to a MultiAssayExperiment using epireglon.archr::archr2MAE. The MAE object was uploaded to scMultiome for full reproducibility. In this dataset, scRNAseq and scATACseq were unpaired and integrated by the ArchR::addGeneIntegrationMatrix function. 4.1 Data preparation Download the example dataset from scMultiome package mae &lt;- scMultiome::hematopoiesis() # Load peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # Load expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneIntegrationMatrix&quot;]] # Add gene symbols to rownames rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name # Transfer dimensionality reduction matrix to GeneExpression reducedDim(GeneExpressionMatrix, &quot;IterativeLSI&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;IterativeLSI&quot;) reducedDim(GeneExpressionMatrix, &quot;UMAP&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;UMAP&quot;) Visualize the data scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP&quot;, text_by = &quot;Clusters2&quot;, colour_by = &quot;Clusters2&quot;, point_size = 0.3, point_alpha = 0.3) 4.2 Retrieve bulk TF ChIP-seq binding sites First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq. Currently, human genomes hg19 and hg38 and mouse genome mm10 are available library(epiregulon) grl &lt;- getTFMotifInfo(genome = &quot;hg19&quot;) ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2761 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 10001-10446 * ## [2] chr1 877485-877780 * ## [3] chr1 919866-920161 * ## [4] chr1 2985496-2985846 * ## [5] chr1 2985975-2986514 * ## ... ... ... ... ## [2757] chrY 8333302-8333771 * ## [2758] chrY 13842450-13842966 * ## [2759] chrY 13868154-13868670 * ## [2760] chrY 21464547-21465020 * ## [2761] chrY 22147548-22147868 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 4.3 Link ATACseq peaks to target genes Next, we compute peak to gene correlations using a custom algorithm that has similar performance to ArchR’s P2G function. Wherever possible, use a multidimensional dimensionality reduction matrix such as LSI or PCA instead of UMAP or TSNE since the former provides a more accurate estimate of cell similarity. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;IterativeLSI&quot;)) ## Using epiregulon to compute peak to gene links... ## performing k means clustering to form metacells ## Computing correlation p2g ## DataFrame with 12952 rows and 8 columns ## idxATAC chr start end idxRNA target Correlation ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; ## 1 7 chr1 801002 801502 2 LINC00115 0.672342 ## 2 8 chr1 805039 805539 6 KLHL17 0.570329 ## 3 24 chr1 894453 894953 6 KLHL17 0.605406 ## 4 37 chr1 935289 935789 8 HES4 0.553607 ## 5 42 chr1 948574 949074 6 KLHL17 0.563872 ## ... ... ... ... ... ... ... ... ## 12948 146390 chr22 50980758 50981258 12082 ODF3B 0.818101 ## 12949 146390 chr22 50980758 50981258 12088 MAPK8IP2 0.606537 ## 12950 146403 chr22 51021154 51021654 12078 LMF2 0.505536 ## 12951 146403 chr22 51021154 51021654 12089 ARSA 0.587286 ## 12952 146412 chr22 51110826 51111326 12090 SHANK3 0.589347 ## distance ## &lt;integer&gt; ## 1 38099 ## 2 90427 ## 3 1013 ## 4 0 ## 5 52606 ## ... ... ## 12948 9749 ## 12949 57872 ## 12950 75018 ## 12951 44946 ## 12952 1743 4.4 Add TF motif binding to peaks The next step is to add the TF motif binding information by overlapping the regions of the peak matrix with the bulk chip-seq database. overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) ## Computing overlap... ## Success! head(overlap) ## idxATAC idxTF tf ## 1013 7 13 ARNT ## 1014 7 17 ATF2 ## 1015 7 21 ATF7 ## 1016 7 28 BCL6 ## 1017 7 30 BCOR ## 1018 7 32 BHLHE40 4.5 Generate regulons A long format dataframe, representing the inferred regulons, is then generated. The dataframe consists of three columns: tf (transcription factor) target gene peak to gene correlation between tf and target gene regulon &lt;- getRegulon(p2g, overlap, aggregate=FALSE) regulon ## DataFrame with 2040269 rows and 10 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 7 chr1 801002 801502 2 LINC00115 ## 2 7 chr1 801002 801502 2 LINC00115 ## 3 7 chr1 801002 801502 2 LINC00115 ## 4 7 chr1 801002 801502 2 LINC00115 ## 5 7 chr1 801002 801502 2 LINC00115 ## ... ... ... ... ... ... ... ## 2040265 146412 chr22 51110826 51111326 12090 SHANK3 ## 2040266 146412 chr22 51110826 51111326 12090 SHANK3 ## 2040267 146412 chr22 51110826 51111326 12090 SHANK3 ## 2040268 146412 chr22 51110826 51111326 12090 SHANK3 ## 2040269 146412 chr22 51110826 51111326 12090 SHANK3 ## distance idxTF tf corr ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 38099 13 ARNT 0.672342 ## 2 38099 17 ATF2 0.672342 ## 3 38099 21 ATF7 0.672342 ## 4 38099 28 BCL6 0.672342 ## 5 38099 30 BCOR 0.672342 ## ... ... ... ... ... ## 2040265 1743 1172 POLR2AphosphoS5 0.589347 ## 2040266 1743 1312 ZNF16 0.589347 ## 2040267 1743 1461 ZNF600 0.589347 ## 2040268 1743 1490 ZNF687 0.589347 ## 2040269 1743 1520 ZNF777 0.589347 4.6 Prune network Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the active category is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section on differential networks. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, regulon = regulon, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05, clusters = GeneExpressionMatrix$Clusters2) ## pruning network with chi.sq tests using a regulon cutoff of pval&lt;0.05 ## pruning regulons 4.7 Add Weights While the pruneRegulon function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the three measures: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, or 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Two measures (correlation and Wilcoxon) give both the magnitude and directionality of changes whereas mutational information is always positive. The correlation and mutual information statistics are computed on grouped pseudobulks by user-supplied cluster labels and yield a single weight across all clusters per each TF-RE-target triplet. In contrast, the Wilcoxon method group cells based on the joint expression of TF, RE and TG in each single cell or in cell aggregates. If cell labels are provided, we calculate cluster-specific weights in addition to estimating weights from all the cells. Cell aggregation uses a default value of 10 cells and can help overcome sparsity and speed up computation. If cluster labels are provided, we can obtain weights of individual clusters and all cells combined. In this example, we apply Wilcoxon test on cell aggregates of 10 cells. We use the Wilcoxon weight method because we are interested in computing cell type-specific weights. set.seed(1010) regulon.w &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$Clusters2, aggregateCells = TRUE, method = &quot;wilcox&quot;, useDim = &quot;IterativeLSI&quot;) ## adding weights using wilcoxon... ## performing pseudobulk using an average of 10 cells regulon.w ## DataFrame with 417041 rows and 14 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 732 chr1 8021367 8021867 95 UTS2 ## 2 891 chr1 9223922 9224422 107 H6PD ## 3 1154 chr1 11724524 11725024 135 FBXO6 ## 4 1476 chr1 16003338 16003838 181 DDI2 ## 5 2329 chr1 25237599 25238099 295 RUNX3 ## ... ... ... ... ... ... ... ## 417037 134071 chr19 41768840 41769340 9199 TGFB1 ## 417038 135998 chr19 54711800 54712300 9580 MBOAT7 ## 417039 144131 chr22 30838237 30838737 11838 SF3A1 ## 417040 144587 chr22 37297198 37297698 11901 CSF2RB ## 417041 144587 chr22 37297198 37297698 11904 MPST ## distance idxTF tf corr pval ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 48072 1030 ADNP 0.534911 1.11552e-06:1:0.00021207:... ## 2 70440 1030 ADNP 0.580146 2.42572e-53:1:1.00000000:... ## 3 373 1030 ADNP 0.504093 1.70871e-07:1:0.96772981:... ## 4 59384 1030 ADNP 0.701968 2.50344e-04:1:1.00000000:... ## 5 53512 1030 ADNP 0.859918 7.39278e-14:1:1.00000000:... ## ... ... ... ... ... ... ## 417037 90490 473 ZSCAN29 0.621256 7.23903e-01:1:1:... ## 417038 18066 473 ZSCAN29 0.797633 4.26510e-02:1:1:... ## 417039 85323 473 ZSCAN29 0.541202 2.76179e-05:1:1:... ## 417040 11976 473 ZSCAN29 0.676467 1.12773e-03:1:1:... ## 417041 117984 473 ZSCAN29 0.551815 1.81933e-02:1:1:... ## stats qval ## &lt;matrix&gt; &lt;matrix&gt; ## 1 23.7177:0:13.72100224:... 1.00000e+00:1:1:... ## 2 236.3764:0: 0.00000000:... 4.49763e-47:1:1:... ## 3 27.3374:0: 0.00163667:... 2.89349e-01:1:1:... ## 4 13.4096:0: 0.00000000:... 1.00000e+00:1:1:... ## 5 55.9609:0: 0.00000000:... 1.29743e-07:1:1:... ## ... ... ... ## 417037 0.124784:0:0:... 1:1:1:... ## 417038 4.109182:0:0:... 1:1:1:... ## 417039 17.575117:0:0:... 1:1:1:... ## 417040 10.605155:0:0:... 1:1:1:... ## 417041 5.577442:0:0:... 1:1:1:... ## weight ## &lt;matrix&gt; ## 1 0.110121:-0.1840694:0.132197:... ## 2 0.328729: 0.0954775:0.218160:... ## 3 0.142351: 0.1861417:0.180140:... ## 4 0.175202: 0.0000000:0.000000:... ## 5 0.455341: 0.0000000:0.302052:... ## ... ... ## 417037 0.124462: 0.182873:0:... ## 417038 0.226807:-0.109380:0:... ## 417039 0.256050:-0.198350:0:... ## 417040 0.250945: 0.000000:0:... ## 417041 0.275493: 0.000000:0:... 4.8 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging the weighted expressions of target genes linked to the TF weighted. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weight_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,…,n} \\(weight_i\\) is the weight of TF and target i score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;, exp_assay = &quot;normalizedCounts&quot;) ## calculating TF activity from regulon using weightedmean ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, regulon = ## regulon.w, : The weight column contains multiple subcolumns but no cluster ## information was provided. Using first column to compute activity... ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by the number of targets... head(score.combine[1:5,1:5]) ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 ## ADNP 0.15753057 0.2101894 ## AFF1 0.19542798 0.1939089 ## AFF4 0.11994675 0.3389850 ## AGO1 0.18243109 0.2156398 ## AGO2 0.08236242 0.3744209 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 ## ADNP 0.1741788 0.1582809 ## AFF1 0.5338244 0.1934617 ## AFF4 0.1341601 0.1989533 ## AGO1 0.1189042 0.1736376 ## AGO2 0.1113447 0.2071216 ## scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 ## ADNP 0.18664284 ## AFF1 0.20511278 ## AFF4 0.13569139 ## AGO1 0.21700829 ## AGO2 0.07640601 4.9 Differential TF activity test We can next determine which TFs exhibit differential activities across cell clusters/groups via the findDifferentialActivity function. This function depends on findMarkers function from scran package. library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = GeneExpressionMatrix$Clusters2, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) getSigGenes compiles the different test results into a single dataframe and enables user to supply their desired cutoffs for significance and variable to order by. markers.sig &lt;- getSigGenes(markers, topgenes = 3 ) ## Using a logFC cutoff of 0.2 for class B for direction equal to any ## Using a logFC cutoff of 0.4 for class CD4.M for direction equal to any ## Using a logFC cutoff of 0.4 for class CD4.N for direction equal to any ## Using a logFC cutoff of 0.2 for class CLP for direction equal to any ## Using a logFC cutoff of 0.3 for class Erythroid for direction equal to any ## Using a logFC cutoff of 0.2 for class GMP for direction equal to any ## Using a logFC cutoff of 0.8 for class Mono for direction equal to any ## Using a logFC cutoff of 0.4 for class NK for direction equal to any ## Using a logFC cutoff of 0.1 for class pDC for direction equal to any ## Using a logFC cutoff of 0.3 for class PreB for direction equal to any ## Using a logFC cutoff of 0.2 for class Progenitor for direction equal to any 4.10 Visualizing TF activities Epiregulon also provides multiple options for visualizing the inferred TF activities by reduced dimensional space tSNE or UMAP plots: options(ggrastr.default.dpi=300) tfs_interest &lt;- c(&quot;EBF1&quot;,&quot;PAX5&quot;, &quot;GATA3&quot;,&quot;SPI1&quot;) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP&quot;, nrow=2, ncol=2, point_size=0.1, rasterise = TRUE) We can compare the activity with gene expression of the same TFs. plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP&quot;, nrow=2, ncol=2, legend.label = &quot;Gex&quot;, colors = c(&quot;grey&quot;,&quot;blue&quot;), point_size=0.1, rasterise = TRUE) We can also plot violin plot to visualize TF activity. plotActivityViolin(activity_matrix = score.combine, tf = tfs_interest, clusters = GeneExpressionMatrix$Clusters2, legend.label = &quot;Gex&quot;, nrow=2, ncol=2) We plot violin plot to visualize TF gene expression. plotActivityViolin(activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, clusters = GeneExpressionMatrix$Clusters2, nrow=2, ncol=2, legend.label = &quot;gene expression&quot;) We can visualize the different TFs in a bubble plot: plotBubble(activity_matrix = score.combine, tf = tfs_interest, GeneExpressionMatrix$Clusters2, bubblesize = &quot;FDR&quot;) We visualize the top differential TFs based on activity. plotBubble(activity_matrix = score.combine, tf = markers.sig$tf, GeneExpressionMatrix$Clusters2, bubblesize = &quot;FDR&quot;) 4.11 Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. Here we first download Hallmark and C2 signatures from hallmark and then perform gene set enrichment of the known lineage factors. As expected, EBF1 is consistent with a B cell lineage factor, GATA3 and RUNX3 with lymphoid lineage and SPI1 with myeloid lineage. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot; ) C2 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C2&quot;, gene.id.type = &quot;SYMBOL&quot; ) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H, C2) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = tfs_interest, regulon = regulon.w, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## EBF1 ## ## PAX5 ## GATA3 ## SPI1 #plot results enrichPlot(results = enrichresults, ncol=2) 4.12 Differential Network analysis In addition to looking at the summed TF activity, a second approach to investigate differential TF activity is to compare and contrast target genes or network topology. In this example, we know that EBF1 is a B cell lineage factor. If we plot the differential network of EBF1 using the regulon with cluster-specific weights, we can see that EBF1 has many more targets in PreB cells than it has in CD4 memory T cells. plotDiffNetwork(regulon.w, cutoff = 0, tf = c(&quot;EBF1&quot;), weight = &quot;weight&quot;, clusters = c(&quot;PreB&quot;,&quot;CD4.M&quot;), layout = &quot;stress&quot;) ## Replacement of na values for weights with 0 ## Building graph using weight as edge weights Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of the targets genes for all the TFs and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to EBF1, and we successfully identify PAX5 as the most similar TF. Both PAX5 and EBF1 are important factors for B cell development (https://www.nature.com/articles/ni.2641). library(ggplot2) # construct a graph of the preB cells preB_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;PreB&quot;) ## Building graph using weight as edge weights # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(preB_network) # Focus on EBF1 similarity_score_EBF1 &lt;- similarity_score[, &quot;EBF1&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_EBF1, decreasing = TRUE),20), TF = names(head(sort(similarity_score_EBF1, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;EBF1 similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(preB_network, &quot;EBF1&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_EBF1),] diff_matrix &lt;- similarity_score_EBF1-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted EBF1 similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_EBF1})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## PAX5 IRF4 TCF3 RAG2 TCF12 POU2F2 NIPBL RB1 TCF4 RAG1 TRIM22 ## 0 0 0 0 0 0 0 0 0 0 0 ## MYB CREB1 EZH2 KDM2B FOXP1 CREM EP300 CREBBP FOXO1 ## 0 0 0 0 0 0 0 0 0 Next, we are interested to compare the networks of two cell types, in this case, CD4 memory T cells (CD4.M) vs Monocytes (mono) cells. We build an edge subtracted graph and then calculate the degree centrality of the subtracted graph. We normalize centrality using the default square root function. The top 5 most positive TFs represent lineage factors more active in NK cells whereas the bottom 5 TFs present lineage factors enriched in CD4. We successfully identified the myeloid factor SPI1 to be associated with monocytes and Th1 factor TBX21 to be associated with CD4 T cells. #regulon.w.2 &lt;- regulon.w #regulon.w &lt;- readRDS(&quot;/gstore/project/lineage/manuscript/epiregulon/OUTPUT/regulon.w.rds&quot;) # construct a graph of the CD4.M and NK cells respectively CD4.M_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;CD4.M&quot;) ## Building graph using weight as edge weights Mono_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;Mono&quot;) ## Building graph using weight as edge weights # construct a difference graph diff_graph &lt;- buildDiffGraph(Mono_network,CD4.M_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table, 10), tail(rank_table, 10)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5, max.overlaps = Inf) + theme_classic() + ggtitle (&quot;differential TFs (Mono-CD4.M) ranked by degree centrality&quot;) We can further explore interacting factors with the myeloid factor SPI1 using the same Jaccard similarity approach. We found CEBPA as the most similar TF as SPI1. SPI1 and CEBPA are known to be important for differentiation into myeloid cells (https://www.cell.com/cell-reports/pdfExtended/S2211-1247(18)30745-9). library(igraph) diff_graph_filter &lt;- subgraph.edges(diff_graph, E(diff_graph)[E(diff_graph)$weight&gt;0], del=TRUE) # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(diff_graph_filter) # Focus on SPI1 similarity_score_SPI1 &lt;- similarity_score[, &quot;SPI1&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_SPI1, decreasing = TRUE),20), TF = names(head(sort(similarity_score_SPI1, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to SPI1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;SPI1 similarity&quot;) + theme_classic() print(topTFplot) 4.13 Session Info sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Red Hat Enterprise Linux 8.6 (Ootpa) ## ## Matrix products: default ## BLAS/LAPACK: /apps/rocs/2020.08/cascadelake/software/OpenBLAS/0.3.9-GCC-9.3.0/lib/libopenblas_skylakexp-r0.3.9.so; LAPACK version 3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/Los_Angeles ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] igraph_2.0.3 ggplot2_3.5.1 ## [3] org.Hs.eg.db_3.20.0 AnnotationDbi_1.67.0 ## [5] msigdbr_7.5.1 epiregulon.extra_1.1.4 ## [7] epiregulon_1.3.4 scMultiome_1.5.7 ## [9] SingleCellExperiment_1.27.2 MultiAssayExperiment_1.31.5 ## [11] SummarizedExperiment_1.35.4 Biobase_2.65.1 ## [13] GenomicRanges_1.57.2 GenomeInfoDb_1.41.2 ## [15] IRanges_2.39.2 S4Vectors_0.43.2 ## [17] MatrixGenerics_1.17.0 matrixStats_1.4.1 ## [19] ExperimentHub_2.13.1 AnnotationHub_3.13.3 ## [21] BiocFileCache_2.13.2 dbplyr_2.5.0 ## [23] BiocGenerics_0.51.3 ## ## loaded via a namespace (and not attached): ## [1] splines_4.4.0 later_1.3.2 ggplotify_0.1.2 ## [4] bitops_1.0-9 filelock_1.0.3 R.oo_1.26.0 ## [7] tibble_3.2.1 polyclip_1.10-7 graph_1.83.0 ## [10] XML_3.99-0.17 lifecycle_1.0.4 edgeR_4.3.19 ## [13] processx_3.8.4 lattice_0.22-6 MASS_7.3-61 ## [16] backports_1.5.0 magrittr_2.0.3 limma_3.61.12 ## [19] sass_0.4.9 rmarkdown_2.28 jquerylib_0.1.4 ## [22] yaml_2.3.10 metapod_1.13.0 RColorBrewer_1.1-3 ## [25] cowplot_1.1.3 chromote_0.3.1 DBI_1.2.3 ## [28] abind_1.4-8 zlibbioc_1.51.1 R.utils_2.12.3 ## [31] purrr_1.0.2 ggraph_2.2.1 RCurl_1.98-1.16 ## [34] yulab.utils_0.1.7 tweenr_2.0.3 rappdirs_0.3.3 ## [37] GenomeInfoDbData_1.2.13 enrichplot_1.25.3 ggrepel_0.9.6 ## [40] irlba_2.3.5.1 tidytree_0.4.6 BiocStyle_2.33.1 ## [43] annotate_1.83.0 dqrng_0.4.1 codetools_0.2-20 ## [46] DelayedArray_0.31.14 DOSE_3.99.1 scuttle_1.15.4 ## [49] ggforce_0.4.2 tidyselect_1.2.1 aplot_0.2.3 ## [52] UCSC.utils_1.1.0 farver_2.1.2 ScaledMatrix_1.13.0 ## [55] viridis_0.6.5 jsonlite_1.8.9 BiocNeighbors_1.99.2 ## [58] tidygraph_1.3.1 scater_1.33.4 tools_4.4.0 ## [61] treeio_1.29.1 Rcpp_1.0.13 glue_1.8.0 ## [64] gridExtra_2.3 SparseArray_1.5.44 xfun_0.48 ## [67] qvalue_2.37.0 websocket_1.4.2 dplyr_1.1.4 ## [70] HDF5Array_1.33.8 withr_3.0.1 BiocManager_1.30.25 ## [73] fastmap_1.2.0 rhdf5filters_1.17.0 bluster_1.15.1 ## [76] fansi_1.0.6 digest_0.6.37 rsvd_1.0.5 ## [79] gridGraphics_0.5-1 R6_2.5.1 mime_0.12 ## [82] colorspace_2.1-1 GO.db_3.20.0 Cairo_1.6-2 ## [85] RSQLite_2.3.7 R.methodsS3_1.8.2 utf8_1.2.4 ## [88] tidyr_1.3.1 generics_0.1.3 data.table_1.16.2 ## [91] graphlayouts_1.2.0 httr_1.4.7 S4Arrays_1.5.10 ## [94] scatterpie_0.2.4 pkgconfig_2.0.3 gtable_0.3.5 ## [97] blob_1.2.4 XVector_0.45.0 shadowtext_0.1.4 ## [100] clusterProfiler_4.13.4 htmltools_0.5.8.1 fgsea_1.31.6 ## [103] bookdown_0.40 GSEABase_1.67.0 scales_1.3.0 ## [106] png_0.1-8 ggfun_0.1.7 scran_1.33.2 ## [109] knitr_1.48 rstudioapi_0.16.0 reshape2_1.4.4 ## [112] nlme_3.1-166 checkmate_2.3.2 curl_5.2.3 ## [115] cachem_1.1.0 rhdf5_2.49.0 stringr_1.5.1 ## [118] BiocVersion_3.20.0 parallel_4.4.0 vipor_0.4.7 ## [121] ggrastr_1.0.2 pillar_1.9.0 grid_4.4.0 ## [124] vctrs_0.6.5 promises_1.3.0 BiocSingular_1.21.4 ## [127] beachmat_2.21.6 xtable_1.8-4 cluster_2.1.6 ## [130] beeswarm_0.4.0 Rgraphviz_2.49.1 evaluate_1.0.1 ## [133] KEGGgraph_1.65.0 cli_3.6.3 locfit_1.5-9.10 ## [136] compiler_4.4.0 rlang_1.1.4 crayon_1.5.3 ## [139] labeling_0.4.3 ps_1.8.0 fs_1.6.4 ## [142] plyr_1.8.9 ggbeeswarm_0.7.2 stringi_1.8.4 ## [145] viridisLite_0.4.2 BiocParallel_1.39.0 babelgene_22.9 ## [148] munsell_0.5.1 Biostrings_2.73.2 lazyeval_0.2.2 ## [151] GOSemSim_2.31.2 Matrix_1.7-0 patchwork_1.3.0 ## [154] bit64_4.5.2 Rhdf5lib_1.27.0 KEGGREST_1.45.1 ## [157] statmod_1.5.0 highr_0.11 beachmat.hdf5_1.3.3 ## [160] memoise_2.0.1 bslib_0.8.0 ggtree_3.13.1 ## [163] fastmatch_1.1-4 bit_4.5.0 EnrichmentBrowser_2.35.1 ## [166] gson_0.1.0 ape_5.8 "],["archr-workflow-and-different-weight-methods.html", "5 ArchR workflow and different weight methods 5.1 Data preparation 5.2 Load ArchR project 5.3 Retrieve matrices from ArchR project 5.4 Retrieve bulk TF ChIP-seq binding sites 5.5 Link ATAC-seq peaks to target genes 5.6 Add TF motif binding to peaks 5.7 Generate regulons 5.8 (Optional) Annotate with TF motifs 5.9 Prune network 5.10 Add Weights 5.11 Calculate TF activity 5.12 Perform differential activity 5.13 Visualize the results 5.14 Differential network analysis 5.15 Session Info", " 5 ArchR workflow and different weight methods In this chapter, we illustrate the epiregulon workflow starting from an ArchR project and compare the different weight estimation methods. The dataset consists of unpaired scATACseq/scRNAseq of parental LNCaP cells treated with DMSO, Enzalutamide and Enza resistant cells. The dataset was taken from Taavitsainen et al GSE168667 and GSE168668. 5.1 Data preparation Please refer to the full ArchR manual for instructions Before running Epiregulon, the following analyses need to be completed: Obtain a peak matrix on scATACseq by using addGroupCoverages &gt; addReproduciblePeakSet &gt; addPeakMatrix. See chapter 10 from ArchR manual RNA-seq integration. For unpaired scATAC-seq, use addGeneIntegrationMatrix. See chapter 8 from ArchR manual For multiome data, use addGeneExpressionMatrix. See multiome tutorial Perform dimensionality reduction from with either single modalities or joint scRNAseq and scATACseq using addCombinedDims 5.2 Load ArchR project library(ArchR) archR_project_path &lt;- &quot;/gstore/project/lineage/prostate/GSE168667/OUTPUT/multiome/&quot; proj &lt;- loadArchRProject(path = archR_project_path, showLogo = FALSE) We verify that “GeneExpressionMatrix” and “PeakMatrix” are present for this tutorial. getAvailableMatrices(proj) ## [1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;MotifMatrix&quot; ## [4] &quot;PeakMatrix&quot; &quot;TileMatrix&quot; We will use the joint reducedDims - “LSI_Combined” and joint embeddings - “UMAP_Combined” head(getReducedDims(proj, reducedDims = &quot;iLSI_Combined&quot;)[,1:5]) ## LSI1 LSI2 LSI3 LSI4 ## SRR13927735#TTATGTCTCCAGGTAT-1 -2.713935 -0.3677949 -0.4484238 -0.30645138 ## SRR13927735#TATTGCTCATCAGAAA-1 -2.642781 -0.2767556 -0.9142714 -0.19675812 ## SRR13927735#TTCGATTGTAGGGTTG-1 -2.322865 -0.1543080 -1.4106049 -0.08891276 ## SRR13927735#CATTCATTCGGATGTT-1 -2.572976 -0.1917188 -1.0464294 -0.12660121 ## SRR13927735#ACGTTAGGTCAACTGT-1 -2.478552 -0.1776639 -1.1037295 -0.22976613 ## SRR13927735#AAATGCCCAGCAATGG-1 -2.595352 -0.3803464 -0.7770309 -0.52431765 ## LSI5 ## SRR13927735#TTATGTCTCCAGGTAT-1 -0.046845365 ## SRR13927735#TATTGCTCATCAGAAA-1 0.075746940 ## SRR13927735#TTCGATTGTAGGGTTG-1 0.019873276 ## SRR13927735#CATTCATTCGGATGTT-1 0.009947438 ## SRR13927735#ACGTTAGGTCAACTGT-1 -0.150097539 ## SRR13927735#AAATGCCCAGCAATGG-1 -0.243074591 head(getEmbedding(proj, embedding = &quot;UMAP_Combined&quot;)) ## iLSI_Combined#UMAP_Dimension_1 ## SRR13927735#TTATGTCTCCAGGTAT-1 -9.622903 ## SRR13927735#TATTGCTCATCAGAAA-1 -9.360211 ## SRR13927735#TTCGATTGTAGGGTTG-1 -8.617347 ## SRR13927735#CATTCATTCGGATGTT-1 -9.285448 ## SRR13927735#ACGTTAGGTCAACTGT-1 -8.809260 ## SRR13927735#AAATGCCCAGCAATGG-1 -9.261216 ## iLSI_Combined#UMAP_Dimension_2 ## SRR13927735#TTATGTCTCCAGGTAT-1 -0.2908237 ## SRR13927735#TATTGCTCATCAGAAA-1 -0.2892935 ## SRR13927735#TTCGATTGTAGGGTTG-1 -0.2154103 ## SRR13927735#CATTCATTCGGATGTT-1 -0.3267481 ## SRR13927735#ACGTTAGGTCAACTGT-1 -0.2168703 ## SRR13927735#AAATGCCCAGCAATGG-1 0.3200356 5.3 Retrieve matrices from ArchR project Retrieve gene expression and peak matrix from the ArchR project GeneExpressionMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;GeneIntegrationMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) PeakMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;PeakMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) If we extract the gene expression from matrix, it will be in the form of RangedSummarizedExperiment. We can make use of ArchRMatrix2SCE to convert gene expression matrix to SingleCellExperiment object. It’s also important to note that gene expression from ArchR is library size normalized (not logged) library(epiregulon.archr) ## Loading required package: SingleCellExperiment ## Loading required package: epiregulon ## ## Attaching package: &#39;epiregulon.archr&#39; ## The following objects are masked from &#39;package:epiregulon&#39;: ## ## addMotifScore, addTFMotifInfo, calculateP2G, getTFMotifInfo GeneExpressionMatrix &lt;- ArchRMatrix2SCE(GeneExpressionMatrix) rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name We rename the assay name of the PeakMatrix as counts PeakMatrix &lt;- ArchRMatrix2SCE(PeakMatrix, rename = &quot;counts&quot;) Transfer embeddings from ArchR project to singleCellExperiment for visualization reducedDim(GeneExpressionMatrix, &quot;UMAP_Combined&quot;) &lt;- getEmbedding(ArchRProj = proj, embedding = &quot;UMAP_Combined&quot;, returnDF = TRUE)[colnames(GeneExpressionMatrix),] # add cell label GeneExpressionMatrix$label &lt;- GeneExpressionMatrix$Cells GeneExpressionMatrix$label[GeneExpressionMatrix$Treatment == &quot;enzalutamide 48h&quot;] &lt;- &quot;LNCaP–ENZ48&quot; GeneExpressionMatrix$label &lt;- factor(GeneExpressionMatrix$label, levels = c(&quot;LNCaP&quot;, &quot;LNCaP–ENZ48&quot;, &quot;LNCaP RES-A&quot;, &quot;LNCaP RES-B&quot;)) Visualize singleCellExperiment by UMAP scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_Combined&quot;, text_by = &quot;label&quot;, colour_by = &quot;label&quot;) 5.4 Retrieve bulk TF ChIP-seq binding sites First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq. Currently, human genomes HG19 and HG38 and mouse mm10 are available. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 5.5 Link ATAC-seq peaks to target genes Next, we compute peak to gene correlations using the addPeak2GeneLinks function from the ArchR package. The user would need to supply a path to an ArchR project already containing peak and gene matrices, as well as Latent semantic indexing (LSI) dimensionality reduction. # path to ArchR project p2g &lt;- calculateP2G(ArchR_path = archR_project_path, useDim = &quot;iLSI_Combined&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, threads = 1) ## Setting ArchRLogging = FALSE ## Using ArchR to compute peak to gene links... ## 2025-01-15 22:36:34.979475 : Getting Available Matrices, 0 mins elapsed. ## 2025-01-15 22:36:48.491436 : Filtered Low Prediction Score Cells (0 of 15522, 0), 0.005 mins elapsed. ## 2025-01-15 22:36:48.754723 : Computing KNN, 0.009 mins elapsed. ## 2025-01-15 22:36:49.202162 : Identifying Non-Overlapping KNN pairs, 0.016 mins elapsed. ## 2025-01-15 22:36:50.565071 : Identified 497 Groupings!, 0.039 mins elapsed. ## 2025-01-15 22:36:50.623938 : Getting Group RNA Matrix, 0.04 mins elapsed. ## 2025-01-15 22:42:28.4399 : Getting Group ATAC Matrix, 5.67 mins elapsed. ## 2025-01-15 22:48:07.318852 : Normalizing Group Matrices, 11.318 mins elapsed. ## 2025-01-15 22:48:11.787014 : Finding Peak Gene Pairings, 11.393 mins elapsed. ## 2025-01-15 22:48:12.186549 : Computing Correlations, 11.4 mins elapsed. ## 2025-01-15 22:48:18.672235 : Completed Peak2Gene Correlations!, 11.508 mins elapsed. p2g ## DataFrame with 16883 rows and 8 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 15 chr1 912762 913262 7 NOC2L ## 2 25 chr1 920261 920761 7 NOC2L ## 3 25 chr1 920261 920761 8 KLHL17 ## 4 32 chr1 927728 928228 7 NOC2L ## 5 32 chr1 927728 928228 8 KLHL17 ## ... ... ... ... ... ... ... ## 16879 210643 chrX 154542721 154543221 23496 CH17-340M24.3 ## 16880 210643 chrX 154542721 154543221 23501 LAGE3 ## 16881 210643 chrX 154542721 154543221 23506 IKBKG ## 16882 210643 chrX 154542721 154543221 23509 DKC1 ## 16883 210665 chrX 154815200 154815700 23515 F8 ## Correlation distance ## &lt;numeric&gt; &lt;numeric&gt; ## 1 0.543478 46297 ## 2 0.602633 38798 ## 3 0.597510 40076 ## 4 0.660584 31331 ## 5 0.532240 32609 ## ... ... ... ## 16879 0.540888 114492 ## 16880 0.708942 63714 ## 16881 0.517261 1716 ## 16882 0.557412 219771 ## 16883 0.554537 211490 5.6 Add TF motif binding to peaks The next step is to add the TF motif binding information by overlapping the regions of the peak matrix with the bulk chip-seq database. The user can supply an archR project path and this function will retrieve the peak matrix, or a peakMatrix in the form of a Granges object or RangedSummarizedExperiment. overlap &lt;- addTFMotifInfo(archR_project_path = archR_project_path, grl = grl, p2g = p2g) ## Successfully loaded ArchRProject! ## Computing overlap... ## Success! 5.7 Generate regulons A long format data frame, representing the inferred regulons, is then generated. The data frame consists of three columns: tf (transcription factor) target gene peak to gene correlation between tf and target gene regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 2612934 rows and 10 columns ## idxATAC chr start end idxRNA target corr ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 15 chr1 912762 913262 7 NOC2L ## 2 15 chr1 912762 913262 7 NOC2L ## 3 15 chr1 912762 913262 7 NOC2L ## 4 15 chr1 912762 913262 7 NOC2L ## 5 15 chr1 912762 913262 7 NOC2L ## ... ... ... ... ... ... ... ... ## 2612930 210665 chrX 154815200 154815700 23515 F8 ## 2612931 210665 chrX 154815200 154815700 23515 F8 ## 2612932 210665 chrX 154815200 154815700 23515 F8 ## 2612933 210665 chrX 154815200 154815700 23515 F8 ## 2612934 210665 chrX 154815200 154815700 23515 F8 ## distance idxTF tf ## &lt;numeric&gt; &lt;integer&gt; &lt;character&gt; ## 1 46297 4 AGO1 ## 2 46297 11 ARID4B ## 3 46297 12 ARID5B ## 4 46297 30 BCOR ## 5 46297 36 BRD4 ## ... ... ... ... ## 2612930 211490 1146 NFRKB ## 2612931 211490 1175 POLR2H ## 2612932 211490 1273 ZBTB8A ## 2612933 211490 1456 ZNF589 ## 2612934 211490 1457 ZNF592 5.8 (Optional) Annotate with TF motifs So far the gene regulatory network was constructed from TF ChIP-seq exclusively. Some users would prefer to further annotate the regulatory elements with the presence of motifs. If motif annotation has been previously performed by ArchR, addMotifScore can retrieve this annotation from the ArchR project. If motifs are available for a factor and the RE contains a motif, we return 1. If motifs are available and the RE does not contain a motif, we return 0. If no motifs are known for this particular factor (as in the case of co-factors or chromatin modifiers), we return NA. If the user has not performed motif annotation with ArchR, we can also annotate the peaks with motifs using the Cisbp database (default) or user-provided PWMS. See ?addMotifScore It is important to note that filtering for the presence of motifs removes a large fraction of the target genes. Motifs are often present in a small subset of the ChIP-seq peaks (can be as low as 10%). Second, indirect TF binding, possibly through its interaction partners, may have a true biological function. In this example, we continue with regulons containing the motifs, regulon.motif. However, if the user prefers to retain all target genes including REs without the motifs, they should proceed with regulon. regulon.motif &lt;- addMotifScore(regulon = regulon, ArchProj = proj ) ## retrieving motif information from ArchR project # retain only TF-RE-TG triplets with motifs regulon.motif &lt;- regulon.motif[which(regulon.motif$motif ==1),] 5.9 Prune network Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the active category is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section on differential networks. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon = regulon.motif, clusters = GeneExpressionMatrix$label, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05) 5.10 Add Weights While the `pruneRegulon’ function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the three measures: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, or 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Two measures (correlation and Wilcoxon) give both the magnitude and directionality of changes whereas mutational information is always positive. The correlation and mutual information statistics are computed on grouped pseudobulks by user-supplied cluster labels and yield a single weight across all clusters per each TF-RE-target triplet. In contrast, the Wilcoxon method group cells based on the joint expression of TF, RE and TG in each single cell or in cell aggregates. If cell labels are provided, we calculate cluster-specific weights in addition to estimating weights from all the cells. Cell aggregation uses a default value of 10 cells and can help overcome sparsity and speed up computation. If cluster labels are provided, we can obtain weights of individual clusters and all cells combined. In the case of drug treatment, however, the activity of TF is suppressed often not by downregulation of the TF gene expression, but by direct interference of the TF protein function. In this dataset, the drug enzalutamide blocks the ligand binding domain of the androgen receptor and prevents it from binding to the chromatin. As a result, while the AR gene expression stays the same, the chromatin accessibility of AR, as computed by chromVar in the ArchR package, is greatly reduced by 48 hour treatment of enzalutamide. First, we visualize the AR expression and show that enzalutamide does not decrease AR expression. library(epiregulon.extra) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix), tf = &quot;AR&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;gene expression&quot;) Then we extract the chromVarMatrix from ArchR project and then visualize the chromatin accessibility at AR bound sites. We can see that 48 hour of enzalutamide treatment reduced chromatin accessibility at AR bound sites chromVarMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;MotifMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1 ) ## 2025-01-15 22:50:00.205308 : Organizing colData, 0.536 mins elapsed. ## 2025-01-15 22:50:00.291774 : Organizing rowData, 0.538 mins elapsed. ## 2025-01-15 22:50:00.293599 : Organizing rowRanges, 0.538 mins elapsed. ## 2025-01-15 22:50:00.297103 : Organizing Assays (1 of 2), 0.538 mins elapsed. ## 2025-01-15 22:50:00.396369 : Organizing Assays (2 of 2), 0.539 mins elapsed. ## 2025-01-15 22:50:00.496636 : Constructing SummarizedExperiment, 0.541 mins elapsed. ## 2025-01-15 22:50:01.285378 : Finished Matrix Creation, 0.554 mins elapsed. plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(chromVarMatrix, &quot;z&quot;), tf = &quot;AR_689&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;chromVar&quot;) Next, we are going to compare 3 different weight methods. In the first method, the wilcoxon test compares target gene expression in cells meeting both the TF expression and accessibility cutoffs vs cells failing either the TF expression or/and accessibility cutoffs. Next, we try out the correlation method which comes in two flavors. When tf_re.merge = FALSE, weight is computed on the correlation of target gene expression vs TF gene expression. When tf_re.merge = TRUE, weight is computed on the correlation of target gene expression vs the product of TF expression and chromatin accessibility at TF-bound regulatory elements. regulon.w.wilcox &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;wilcoxon&quot;) ## adding weights using wilcoxon... regulon.w.corr &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;) ## adding weights using corr... ## calculating average expression across clusters... ## computing weights... regulon.w.corr.re &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;, tf_re.merge = TRUE) ## adding weights using corr... ## calculating average expression across clusters... ## computing weights... 5.11 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging the weighted expressions of target genes linked to the TF. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weight_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,…,n} \\(weight_i\\) is the weight of TF and target i We calculate three different activities corresponding to the different weighted regulons score.combine.wilcox &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, regulon = regulon.w.wilcox, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## calculating TF activity from regulon using weightedmean ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = ## &quot;counts&quot;, : The weight column contains multiple subcolumns but no cluster ## information was provided. Using first column to compute activity... ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... score.combine.corr &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, regulon = regulon.w.corr, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## calculating TF activity from regulon using weightedmean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... score.combine.corr.re &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, regulon = regulon.w.corr.re, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## calculating TF activity from regulon using weightedmean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... We visualize the different activities side by side. library(epiregulon.extra) plotActivityViolin(activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by wilcoxon&quot;) plotActivityViolin(activity_matrix = score.combine.corr, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF vs TG&quot;) plotActivityViolin(activity_matrix = score.combine.corr.re, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF*RE vs TG&quot;) In this case, activity calculated from correlation based on TF and TG expression is clearly wrong because we see increased AR activity after Enzalutamide treatment despite it being an AR antagonist. Therefore, for drug treatment which often decouples TF gene expression and its activity, it is important to take into consideration both TF gene expression and RE chromatin accessibility; the latter may be a better indicator of TF function if the TF has an effect on the chromatin accessibility. In this case, the recommended methods are either wilcox or corr with tf_re.merge = TRUE. The astute users could however detect a difference in the prediction of the AR activity in the resistant clones “RES-A” and “RES-B” with respect to the parental “LNCaP” between the two methods. For example, the corr with tf_re.merge = TRUE shows increased AR activity in “RES-B” compared to “LNCaP” because “RES-B” shows increased AR expression. In contrast, the wilcoxon method did not predict an increase in AR activity in “RES-B” because “RES-B” still shows reduced chromatin accessibility compared to “LNCaP”. Since wilcoxon takes into account the co-occurrence of both TF gene expression and RE chromatin accessibility, this method does not predict an overall increase in AR activity. In the absence of the ground truth, it is difficult to judge which method is superior. Therefore, it is always crucial to validate key findings with additional empirical evidence. The most important disclaimer we wish to make is that all predictions by epiregulon should be robustly tested experimentally. 5.12 Perform differential activity For the remaining steps, we continue with activity derived from the wilcoxon method. markers &lt;- findDifferentialActivity(activity_matrix = score.combine.wilcox, clusters = GeneExpressionMatrix$label, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) Take the top differential TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) ## Using a logFC cutoff of 0 for class LNCaP for direction equal to any ## Using a logFC cutoff of 0 for class LNCaP–ENZ48 for direction equal to any ## Using a logFC cutoff of 0.1 for class LNCaP RES-A for direction equal to any ## Using a logFC cutoff of 0 for class LNCaP RES-B for direction equal to any 5.13 Visualize the results First visualize the known differential TFs by bubble plot plotBubble(activity_matrix = score.combine.wilcox, tf = c(&quot;AR&quot;,&quot;FOXA1&quot;, &quot;MYC&quot;,&quot;JUN&quot;), pval.type = &quot;some&quot;, direction = &quot;up&quot;, clusters = GeneExpressionMatrix$label) Then visualize the most differential TFs by clusters plotBubble(activity_matrix = score.combine.wilcox, tf = markers.sig$tf, pval.type = &quot;some&quot;, direction = &quot;up&quot;, clusters = GeneExpressionMatrix$label) Visualize the known differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize the newly discovered differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = c(&quot;SPDEF&quot;,&quot;HES4&quot;,&quot;ATF5&quot;,&quot;NR2F2&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize regulons by heatmap rowData(GeneExpressionMatrix) &lt;- NULL plotHeatmapRegulon(sce=GeneExpressionMatrix, tfs= c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon=regulon.w.wilcox, regulon_cutoff=0.1, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;counts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) plotHeatmapActivity(activity=score.combine.wilcox, sce=GeneExpressionMatrix, tfs=rownames(score.combine.wilcox), downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name = &quot;transcription factor activity&quot;, column_title_rot = 45) ## Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H,C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = c(&quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## AR ## ## FOXA1 ## MYC ## JUN #plot results enrichPlot(results = enrichresults, ncol = 2) We can visualize the genesets of known factors as a network plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) We can visualize the genesets of differential factors as a network enrichresults &lt;- regulonEnrich(TF = markers.sig$tf, regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## HES4 ## SPDEF ## NKX3-1 ## FOXP1 ## NFIB ## HES4 ## SPDEF ## NFYB ## NFIB ## CREB1 ## JUN ## NR2F2 ## SMARCC1 ## NR2F6 ## ATF5 plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) 5.14 Differential network analysis In addition to looking at the summed TF activity, a second approach to investigate differential TF activity is to compare and contrast target genes or network topology. In this example, we know that AR is downregulated in the Enzalutamide treated cells compared to parental LNCaP. plotDiffNetwork(regulon.w.wilcox, cutoff = 0, tf = c(&quot;AR&quot;), weight = &quot;weight&quot;, clusters = c(&quot;LNCaP&quot;,&quot;LNCaP–ENZ48&quot;), layout = &quot;stress&quot;) ## Building graph using weight as edge weights We perform edge subtracted graph between two conditions and rank TFs by degree centrality. In this example, positive centrality indicates higher activity in parental LNCaP and negative centrality indicates higher activity in Enzalutamide treated cells. # construct a graph of the parental and enzalutamide treated cells respectively LNCaP_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaP&quot;) ## Building graph using weight as edge weights ENZ_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaP–ENZ48&quot;) ## Building graph using weight as edge weights # construct a difference graph diff_graph &lt;- buildDiffGraph(LNCaP_network, ENZ_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table,5), tail(rank_table,5)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5) + theme_classic() + ggtitle (&quot;differential TFs (LNCaP-ENZ) ranked by degree centrality&quot;) Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of the targets genes for all the TFs and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to AR. library(igraph) ## ## Attaching package: &#39;igraph&#39; ## The following object is masked from &#39;package:nabor&#39;: ## ## knn ## The following object is masked from &#39;package:GenomicRanges&#39;: ## ## union ## The following object is masked from &#39;package:IRanges&#39;: ## ## union ## The following object is masked from &#39;package:S4Vectors&#39;: ## ## union ## The following objects are masked from &#39;package:BiocGenerics&#39;: ## ## normalize, path, union ## The following object is masked from &#39;package:gtools&#39;: ## ## permute ## The following objects are masked from &#39;package:stats&#39;: ## ## decompose, spectrum ## The following object is masked from &#39;package:base&#39;: ## ## union diff_graph_filter &lt;- subgraph.edges(diff_graph, E(diff_graph)[E(diff_graph)$weight&gt;0], del=TRUE) # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(diff_graph_filter) # Focus on AR similarity_score_AR &lt;- similarity_score[, &quot;AR&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_AR, decreasing = TRUE),20), TF = names(head(sort(similarity_score_AR, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to SPI1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;AR similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(diff_graph_filter, &quot;AR&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_AR),] diff_matrix &lt;- similarity_score_AR-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to AR topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted AR similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_AR})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## JUND MYC FOXA1 HOXB13 NFIC CEBPB MAZ XBP1 CEBPG GATA2 REST ## 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.01 0.00 0.00 0.01 ## CTCF FOXP1 NFIX ATF4 ZNF148 NFIB EHF ETV1 YY1 ## 0.00 0.01 0.00 0.03 0.02 0.00 0.00 0.00 0.00 5.15 Session Info sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Red Hat Enterprise Linux 8.6 (Ootpa) ## ## Matrix products: default ## BLAS/LAPACK: /apps/rocs/2020.08/cascadelake/software/OpenBLAS/0.3.9-GCC-9.3.0/lib/libopenblas_skylakexp-r0.3.9.so; LAPACK version 3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/Los_Angeles ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 grid stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] igraph_2.0.3 org.Hs.eg.db_3.20.0 ## [3] AnnotationDbi_1.67.0 msigdbr_7.5.1 ## [5] epiregulon.extra_1.1.4 nabor_0.5.0 ## [7] scMultiome_1.5.7 MultiAssayExperiment_1.31.5 ## [9] ExperimentHub_2.13.1 AnnotationHub_3.13.3 ## [11] BiocFileCache_2.13.2 dbplyr_2.5.0 ## [13] epiregulon.archr_0.99.5 epiregulon_1.3.4 ## [15] SingleCellExperiment_1.27.2 rhdf5_2.49.0 ## [17] SummarizedExperiment_1.35.4 Biobase_2.65.1 ## [19] RcppArmadillo_14.0.2-1 Rcpp_1.0.13 ## [21] Matrix_1.7-0 GenomicRanges_1.57.2 ## [23] GenomeInfoDb_1.41.2 IRanges_2.39.2 ## [25] S4Vectors_0.43.2 BiocGenerics_0.51.3 ## [27] sparseMatrixStats_1.17.2 MatrixGenerics_1.17.0 ## [29] matrixStats_1.4.1 data.table_1.16.2 ## [31] stringr_1.5.1 plyr_1.8.9 ## [33] magrittr_2.0.3 ggplot2_3.5.1 ## [35] gtable_0.3.5 gtools_3.9.5 ## [37] gridExtra_2.3 devtools_2.4.5 ## [39] usethis_3.0.0 ArchR_1.0.3 ## ## loaded via a namespace (and not attached): ## [1] fs_1.6.4 bitops_1.0-9 enrichplot_1.25.3 ## [4] httr_1.4.7 RColorBrewer_1.1-3 doParallel_1.0.17 ## [7] Rgraphviz_2.49.1 profvis_0.4.0 tools_4.4.0 ## [10] backports_1.5.0 utf8_1.2.4 R6_2.5.1 ## [13] lazyeval_0.2.2 rhdf5filters_1.17.0 GetoptLong_1.0.5 ## [16] urlchecker_1.0.1 withr_3.0.1 cli_3.6.3 ## [19] Cairo_1.6-2 scatterpie_0.2.4 labeling_0.4.3 ## [22] sass_0.4.9 KEGGgraph_1.65.0 yulab.utils_0.1.7 ## [25] gson_0.1.0 DOSE_3.99.1 R.utils_2.12.3 ## [28] scater_1.33.4 sessioninfo_1.2.2 limma_3.61.12 ## [31] rstudioapi_0.16.0 RSQLite_2.3.7 gridGraphics_0.5-1 ## [34] generics_0.1.3 shape_1.4.6.1 dplyr_1.1.4 ## [37] GO.db_3.20.0 ggbeeswarm_0.7.2 fansi_1.0.6 ## [40] abind_1.4-8 R.methodsS3_1.8.2 lifecycle_1.0.4 ## [43] yaml_2.3.10 edgeR_4.3.19 qvalue_2.37.0 ## [46] SparseArray_1.5.44 blob_1.2.4 promises_1.3.0 ## [49] dqrng_0.4.1 crayon_1.5.3 miniUI_0.1.1.1 ## [52] lattice_0.22-6 beachmat_2.21.6 cowplot_1.1.3 ## [55] annotate_1.83.0 chromote_0.3.1 KEGGREST_1.45.1 ## [58] magick_2.8.5 pillar_1.9.0 knitr_1.48 ## [61] ComplexHeatmap_2.21.1 metapod_1.13.0 fgsea_1.31.6 ## [64] rjson_0.2.23 codetools_0.2-20 fastmatch_1.1-4 ## [67] glue_1.8.0 ggfun_0.1.7 remotes_2.5.0 ## [70] treeio_1.29.1 vctrs_0.6.5 png_0.1-8 ## [73] cachem_1.1.0 xfun_0.48 S4Arrays_1.5.10 ## [76] mime_0.12 tidygraph_1.3.1 iterators_1.0.14 ## [79] statmod_1.5.0 bluster_1.15.1 ellipsis_0.3.2 ## [82] nlme_3.1-166 ggtree_3.13.1 bit64_4.5.2 ## [85] filelock_1.0.3 bslib_0.8.0 irlba_2.3.5.1 ## [88] vipor_0.4.7 colorspace_2.1-1 DBI_1.2.3 ## [91] tidyselect_1.2.1 processx_3.8.4 bit_4.5.0 ## [94] compiler_4.4.0 curl_5.2.3 graph_1.83.0 ## [97] BiocNeighbors_1.99.2 DelayedArray_0.31.14 shadowtext_0.1.4 ## [100] bookdown_0.40 checkmate_2.3.2 scales_1.3.0 ## [103] rappdirs_0.3.3 digest_0.6.37 rmarkdown_2.28 ## [106] XVector_0.45.0 htmltools_0.5.8.1 pkgconfig_2.0.3 ## [109] highr_0.11 fastmap_1.2.0 rlang_1.1.4 ## [112] GlobalOptions_0.1.2 htmlwidgets_1.6.4 UCSC.utils_1.1.0 ## [115] shiny_1.9.1 farver_2.1.2 jquerylib_0.1.4 ## [118] jsonlite_1.8.9 BiocParallel_1.39.0 R.oo_1.26.0 ## [121] GOSemSim_2.31.2 BiocSingular_1.21.4 RCurl_1.98-1.16 ## [124] ggplotify_0.1.2 scuttle_1.15.4 GenomeInfoDbData_1.2.13 ## [127] patchwork_1.3.0 Rhdf5lib_1.27.0 munsell_0.5.1 ## [130] ape_5.8 babelgene_22.9 viridis_0.6.5 ## [133] EnrichmentBrowser_2.35.1 stringi_1.8.4 ggraph_2.2.1 ## [136] zlibbioc_1.51.1 MASS_7.3-61 pkgbuild_1.4.4 ## [139] parallel_4.4.0 ggrepel_0.9.6 splines_4.4.0 ## [142] Biostrings_2.73.2 graphlayouts_1.2.0 circlize_0.4.16 ## [145] locfit_1.5-9.10 ps_1.8.0 reshape2_1.4.4 ## [148] ScaledMatrix_1.13.0 pkgload_1.4.0 BiocVersion_3.20.0 ## [151] XML_3.99-0.17 evaluate_1.0.1 scran_1.33.2 ## [154] BiocManager_1.30.25 foreach_1.5.2 tweenr_2.0.3 ## [157] httpuv_1.6.15 tidyr_1.3.1 purrr_1.0.2 ## [160] polyclip_1.10-7 clue_0.3-65 ggforce_0.4.2 ## [163] rsvd_1.0.5 xtable_1.8-4 tidytree_0.4.6 ## [166] later_1.3.2 viridisLite_0.4.2 tibble_3.2.1 ## [169] aplot_0.2.3 clusterProfiler_4.13.4 websocket_1.4.2 ## [172] memoise_2.0.1 beeswarm_0.4.0 cluster_2.1.6 ## [175] GSEABase_1.67.0 "],["single-modality-scrna-seq-only.html", "6 Single modality: scRNA-seq only 6.1 Load regulon 6.2 Load scRNA-seq data 6.3 Calculate activity 6.4 Perform differential activity 6.5 Visualize activity 6.6 Pathway enrichment 6.7 Session Info", " 6 Single modality: scRNA-seq only Epiregulon also supports transcription factor activity inference when users only have scRNA-seq. After all, multiome or scATAC-seq data is still relatively rare. To enable TF activity inference on scRNA-seq, users can supply a pre-constructed gene regulatory network. Dorothea provides both human and mouse pre-constructed gene regulatory networks based on curated experimental and computational data. In this vignette, we bypass the regulon construction step and go straight to calculate TF activity from a Dorothea GRN. 6.1 Load regulon Dorothea assigns confidence level to its regulons with A being the most confident (i.e. supported by multiple lines of evidence) and E being the least confident. library(dorothea) data(dorothea_mm, package = &quot;dorothea&quot;) regulon &lt;- dorothea_mm #known tfs genes_to_plot &lt;- c(&quot;Foxa1&quot;, &quot;Neurod1&quot;,&quot;Pdx1&quot;,&quot;Arx&quot;) 6.2 Load scRNA-seq data We download the raw counts of a mouse pancreas data set from scRNAseq. We add normalized logcounts, perform dimension reduction and visualize the embeddings using scater. library(scRNAseq) library(scater) sce &lt;- BaronPancreasData(&#39;mouse&#39;) sce &lt;- logNormCounts(sce) sce &lt;- runPCA(sce) sce &lt;- runUMAP(sce) plotUMAP(sce, colour_by = &quot;label&quot;, text_by = &quot;label&quot;) 6.3 Calculate activity Even though Dorothea provides weights under the mor column, we can achieve superior performance if we recompute the weights based on the correlation between tf and target gene expression based on our own data. We performed 2 steps, the first step is to add weights to the Dorothea regulons and the second step is to estimate the TF activity by taking the weighted average of the target gene expression. library(epiregulon) #Add weights to regulon. Default method (wilcoxon) cannot be used regulon.ms &lt;- addWeights(regulon = regulon, expMatrix = sce, clusters = sce$label, BPPARAM = BiocParallel::MulticoreParam(), method=&quot;corr&quot;) #Calculate activity score.combine &lt;- calculateActivity(sce, regulon = regulon.ms, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) 6.4 Perform differential activity library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = sce$label, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) Take the top TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) 6.5 Visualize activity Finally we visualize the TF activity by either UMAP, violin plots or bubble plots. We confirm the activity of known lineage factors Pdx1 and Neurod1 in beta cells, Arx in alpha cells and Foxa1 in ductal cells. # plot umap plotActivityDim(sce = sce, activity_matrix = score.combine, tf = genes_to_plot, legend.label = &quot;score&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2) # plot violin plot plotActivityViolin(score.combine, tf = genes_to_plot, clusters = sce$label) # plot bubble plot plotBubble(score.combine, tf = genes_to_plot, clusters = sce$label) Plot bubble plot of differential TFs plotBubble(score.combine, tf = markers.sig$tf, clusters = sce$label) We can adapt the epiregulon package to plot gene expression. When compared against TF activity, gene expression of Foxa1 and Arx has noisy signals and high dropout rates. Epiregulon enhances the signal to noise ratio of TF activity and better resolves lineage differences. # plot umap plotActivityDim(sce = sce, activity_matrix = logcounts(sce), tf = genes_to_plot, legend.label = &quot;gex&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2, colors = c(&quot;gray&quot;,&quot;blue&quot;), limit = c(0,2)) # plot violin plot plotActivityViolin(logcounts(sce), tf = genes_to_plot, clusters = sce$label, legend.label = &quot;gex&quot;) # plot Bubble plot plotBubble(logcounts(sce), tf = markers.sig$tf, clusters = sce$label, legend.label = &quot;gex&quot;) We can visualize the target genes for transcription factors of interest plotHeatmapRegulon(sce=sce, tfs=genes_to_plot, regulon=regulon.ms, regulon_cutoff=0.5, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;logcounts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) plotHeatmapActivity(activity_matrix = score.combine, sce=sce, tfs=genes_to_plot, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) 6.6 Pathway enrichment Sometimes it is useful to understand what pathways are enriched in the regulons. We take the highly correlated target genes of a regulon and perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H,C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs = x, genes = gs[[x]])})) enrichresults &lt;- regulonEnrich(genes_to_plot, regulon = regulon.ms, weight = &quot;weight&quot;, weight_cutoff = 0.5, genesets = gs.list) ## Foxa1 ## ## Neurod1 ## Pdx1 ## Arx #plot results enrichPlot(results = enrichresults, ncol = 1) 6.7 Session Info sessionInfo() ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Red Hat Enterprise Linux 8.6 (Ootpa) ## ## Matrix products: default ## BLAS/LAPACK: /apps/rocs/2020.08/cascadelake/software/OpenBLAS/0.3.9-GCC-9.3.0/lib/libopenblas_skylakexp-r0.3.9.so; LAPACK version 3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/Los_Angeles ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] org.Mm.eg.db_3.20.0 AnnotationDbi_1.67.0 ## [3] msigdbr_7.5.1 epiregulon.extra_1.1.4 ## [5] epiregulon_1.3.4 scater_1.33.4 ## [7] ggplot2_3.5.1 scuttle_1.15.4 ## [9] scRNAseq_2.19.1 SingleCellExperiment_1.27.2 ## [11] SummarizedExperiment_1.35.4 Biobase_2.65.1 ## [13] GenomicRanges_1.57.2 GenomeInfoDb_1.41.2 ## [15] IRanges_2.39.2 S4Vectors_0.43.2 ## [17] BiocGenerics_0.51.3 MatrixGenerics_1.17.0 ## [19] matrixStats_1.4.1 dorothea_1.17.0 ## ## loaded via a namespace (and not attached): ## [1] fs_1.6.4 ProtGenerics_1.37.1 bitops_1.0-9 ## [4] enrichplot_1.25.3 httr_1.4.7 RColorBrewer_1.1-3 ## [7] doParallel_1.0.17 Rgraphviz_2.49.1 tools_4.4.0 ## [10] backports_1.5.0 alabaster.base_1.5.9 utf8_1.2.4 ## [13] R6_2.5.1 HDF5Array_1.33.8 lazyeval_0.2.2 ## [16] uwot_0.2.2 rhdf5filters_1.17.0 GetoptLong_1.0.5 ## [19] withr_3.0.1 gridExtra_2.3 cli_3.6.3 ## [22] Cairo_1.6-2 scatterpie_0.2.4 alabaster.se_1.5.3 ## [25] labeling_0.4.3 sass_0.4.9 KEGGgraph_1.65.0 ## [28] yulab.utils_0.1.7 Rsamtools_2.21.2 gson_0.1.0 ## [31] DOSE_3.99.1 R.utils_2.12.3 bcellViper_1.41.0 ## [34] limma_3.61.12 rstudioapi_0.16.0 RSQLite_2.3.7 ## [37] FNN_1.1.4.1 gridGraphics_0.5-1 generics_0.1.3 ## [40] shape_1.4.6.1 BiocIO_1.15.2 dplyr_1.1.4 ## [43] GO.db_3.20.0 Matrix_1.7-0 ggbeeswarm_0.7.2 ## [46] fansi_1.0.6 abind_1.4-8 R.methodsS3_1.8.2 ## [49] lifecycle_1.0.4 yaml_2.3.10 edgeR_4.3.19 ## [52] qvalue_2.37.0 rhdf5_2.49.0 SparseArray_1.5.44 ## [55] BiocFileCache_2.13.2 grid_4.4.0 blob_1.2.4 ## [58] promises_1.3.0 dqrng_0.4.1 ExperimentHub_2.13.1 ## [61] crayon_1.5.3 lattice_0.22-6 beachmat_2.21.6 ## [64] cowplot_1.1.3 GenomicFeatures_1.57.1 annotate_1.83.0 ## [67] chromote_0.3.1 KEGGREST_1.45.1 magick_2.8.5 ## [70] pillar_1.9.0 knitr_1.48 ComplexHeatmap_2.21.1 ## [73] metapod_1.13.0 fgsea_1.31.6 rjson_0.2.23 ## [76] codetools_0.2-20 fastmatch_1.1-4 glue_1.8.0 ## [79] ggfun_0.1.7 data.table_1.16.2 treeio_1.29.1 ## [82] vctrs_0.6.5 png_0.1-8 gypsum_1.1.6 ## [85] gtable_0.3.5 cachem_1.1.0 xfun_0.48 ## [88] S4Arrays_1.5.10 tidygraph_1.3.1 iterators_1.0.14 ## [91] statmod_1.5.0 bluster_1.15.1 nlme_3.1-166 ## [94] ggtree_3.13.1 bit64_4.5.2 alabaster.ranges_1.5.2 ## [97] filelock_1.0.3 bslib_0.8.0 irlba_2.3.5.1 ## [100] vipor_0.4.7 colorspace_2.1-1 DBI_1.2.3 ## [103] tidyselect_1.2.1 processx_3.8.4 bit_4.5.0 ## [106] compiler_4.4.0 curl_5.2.3 httr2_1.0.5 ## [109] graph_1.83.0 BiocNeighbors_1.99.2 DelayedArray_0.31.14 ## [112] shadowtext_0.1.4 bookdown_0.40 rtracklayer_1.65.0 ## [115] checkmate_2.3.2 scales_1.3.0 rappdirs_0.3.3 ## [118] stringr_1.5.1 digest_0.6.37 alabaster.matrix_1.5.10 ## [121] rmarkdown_2.28 XVector_0.45.0 htmltools_0.5.8.1 ## [124] pkgconfig_2.0.3 highr_0.11 dbplyr_2.5.0 ## [127] fastmap_1.2.0 ensembldb_2.29.1 rlang_1.1.4 ## [130] GlobalOptions_0.1.2 UCSC.utils_1.1.0 farver_2.1.2 ## [133] jquerylib_0.1.4 jsonlite_1.8.9 BiocParallel_1.39.0 ## [136] R.oo_1.26.0 GOSemSim_2.31.2 BiocSingular_1.21.4 ## [139] RCurl_1.98-1.16 magrittr_2.0.3 ggplotify_0.1.2 ## [142] GenomeInfoDbData_1.2.13 patchwork_1.3.0 Rhdf5lib_1.27.0 ## [145] munsell_0.5.1 Rcpp_1.0.13 ape_5.8 ## [148] babelgene_22.9 viridis_0.6.5 EnrichmentBrowser_2.35.1 ## [151] stringi_1.8.4 alabaster.schemas_1.5.0 ggraph_2.2.1 ## [154] zlibbioc_1.51.1 MASS_7.3-61 AnnotationHub_3.13.3 ## [157] plyr_1.8.9 parallel_4.4.0 ggrepel_0.9.6 ## [160] splines_4.4.0 Biostrings_2.73.2 graphlayouts_1.2.0 ## [163] circlize_0.4.16 locfit_1.5-9.10 ps_1.8.0 ## [166] igraph_2.0.3 reshape2_1.4.4 ScaledMatrix_1.13.0 ## [169] BiocVersion_3.20.0 XML_3.99-0.17 evaluate_1.0.1 ## [172] scran_1.33.2 BiocManager_1.30.25 foreach_1.5.2 ## [175] tweenr_2.0.3 tidyr_1.3.1 purrr_1.0.2 ## [178] polyclip_1.10-7 clue_0.3-65 alabaster.sce_1.5.1 ## [181] ggforce_0.4.2 rsvd_1.0.5 xtable_1.8-4 ## [184] restfulr_0.0.15 AnnotationFilter_1.29.0 tidytree_0.4.6 ## [187] later_1.3.2 viridisLite_0.4.2 tibble_3.2.1 ## [190] aplot_0.2.3 clusterProfiler_4.13.4 websocket_1.4.2 ## [193] memoise_2.0.1 beeswarm_0.4.0 GenomicAlignments_1.41.0 ## [196] cluster_2.1.6 GSEABase_1.67.0 BiocStyle_2.33.1 "],["contact.html", "7 Contact", " 7 Contact The issues related to epiregulon suite of packages can be reported on the package GitHub repository page. epiregulon epiregulon.extra epiregulon.archr If you need more information on the package usage you can contact authors directly: Xiaosai Yao, yao.xiaosai@gene.com Tomasz Włodarczy, tomwlo@gmail.com "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
