[["index.html", "Epiregulon documentation Introduction", " Epiregulon documentation Xiaosai Yao, Tomasz Wodarczyk 2023-11-21 Introduction Gene regulatory networks model the underlying gene regulation hierarchies that drive gene expression and cell states. The main function of the epiregulon package is to construct gene regulatory networks and infer transcription factor (TF) activity in single cells by integration of scATAC-seq and scRNA-seq data and incorporation of public bulk TF ChIP-seq data. Epiregulon assigns regulatory elements (REs) to their putative target genes (TGs) if the chromatin accessibility and gene expressions are highly correlated across cell clusters. Each regulatory element is then interrogated for TF occupancy based on a compilation of public TF ChIP-seq binding sites from ChIP-Atlas and ENCODE TF ChIP-seq data. This maps out the preliminary TF-RE-TG regulatory relationships. Further pruning of the gene regulatory network is necessary to remove spurious gene regulatory relationships not supported by the data, especially because the public ChIP-seq data was most certainly obtained in different cell lines or treatment conditions. In this case, we want to identify the most likely TF-RE-TG triplets. Here we apply tests of independence (binomial or chi-square tests) which identify TF-RE-TG triplets jointly occurring at probabilities deviating from the expected probabilities if these three events occur independently. In other words, we assume that a TF-RE-TG regulatory relationship holds true if expression of the TG, chromatin accessibility at RE and expression of the TG tend to co-exist in the same cells. While we recognize that there could be time delays between chromatin accessibility and the expression of target genes in true RE-TG relationships, we want to be conservative in our inference and rule out unsubstantiated TF-RE-TG relationships. After network pruning, we would like to further estimate the strength of regulation. This can be achieved using one of the three methods: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, and 3) effect size of the Wilcoxon test between target gene expression in cells jointly expressing all 3 elements vs cells that do not. The activity of transcription factor is the weighted sum of all its target genes in which the weights correspond to the strength of regulation. The target genes of TFs can be queried against known pathways to predict the functions of TFs. We can also perform differential TF activity using two approaches: 1) differential total activity or 2) differential network topology. The first approach compares differences in the sum of the target genes. The second approach involves edge subtraction between two networks and the TFs are ranked by the degree centrality of the differential graphs. Epiregulon also allows identification of interaction partners by the degree of overlaps in the target genes between two TFs. Current prerequisites for running epiregulon include pre-computed peak matrix, gene expression matrix and dimensionality reduction. Epiregulon offers seamless integration with ArchR. Alternately, users can analyze their data using their favorite analysis tools and package their matrices into MultiAssayExperiment (See scMultiome package). The scATAC-seq experiment can be either paired or unpaired with the scRNA-seq dataset as long as they were already integrated. The final output of epiregulon is a matrix of TF activities where rows are individual TFs and columns are single cell indexes. "],["installation.html", "1 Installation", " 1 Installation All the epiregulon components are available on github. There are three separate epiregulon packages. The core epiregulon package supports input in the form of SingleCellExperiment objects. If the users would like to start from ArchR projects, they may choose to use epiregulon.archr package, which allows for the seamless integration with ArchR package through accepting its output to be used in the downstream workflow. # install devtools if(!require(devtools)) install.packages(&quot;devtools&quot;) # install basic epiregulon package devtools::install_github(repo=&#39;xiaosaiyao/epiregulon&#39;) # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.archr&#39;) Moreover, we provide a suite of tools for the enrichment analysis, visualization, and network analysis which can be run on the epireglon or epiregulon.archr output. # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.extra&#39;) "],["basic-workflow-with-multiassayexperiment.html", "2 Basic workflow with MultiAssayExperiment 2.1 Data preparation 2.2 Retrieve bulk TF ChIP-seq binding sites 2.3 Link ATAC-seq peaks to target genes 2.4 Add TF motif binding to peaks 2.5 Generate regulons 2.6 Network pruning (highly recommended) 2.7 Add Weights 2.8 (Optional) Annotate with TF motifs 2.9 Calculate TF activity 2.10 Perform differential activity 2.11 Visualize the results 2.12 Geneset enrichment 2.13 Network analysis 2.14 Session Info", " 2 Basic workflow with MultiAssayExperiment In this chapter, we illustrate the epiregulon workflow starting from data in the form of SingleCellExperiment objects using the correlation weight estimation method. This is a dataset generated by infecting LNCaP cells with NKX2-1, GATA6 and FOXA2 to examine the effects of these TFs on AR activity using a technique called reprogram-seq. 2.1 Data preparation Single cell preprocessing needs to performed by users favorite methods prior to using Epiregulon. The following components are required: 1. Peak matrix from scATAC-seq 2. Gene expression matrix from either paired or unpaired scRNA-seq. RNA-seq integration needs to be performed for unpaired dataset. 3. Dimensionality reduction matrix from with either single modalities or joint scRNA-seq and scATAC-seq In this case, we have preprocessed the data and converted the archR project into a MAE object using the function epiregulon.archr::archr2MAE and made the data available through the scMultiome package # load the MAE object library(scMultiome) mae &lt;- scMultiome::reprogramSeq() # peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name # dimensional reduction matrix reducedDimMatrix &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;LSI_ATAC&quot;) Visualize the SingleCellExperiment by UMAP # transfer UMAP_combined from TileMatrix to GeneExpressionMatrix reducedDim(GeneExpressionMatrix, &quot;UMAP_Combined&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;UMAP_Combined&quot;) scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_Combined&quot;, text_by = &quot;Clusters&quot;, colour_by = &quot;Clusters&quot;) 2.2 Retrieve bulk TF ChIP-seq binding sites First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq, which are available through the scMultiome package . Currently, human genomes hg19 and hg38 and mouse mm10 are available. library(epiregulon) grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache grl ## GRangesList object of length 1558: ## $`5-hmC` ## GRanges object with 24048 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 10000-10685 * ## [2] chr1 13362-13694 * ## [3] chr1 29631-29989 * ## [4] chr1 40454-40754 * ## [5] chr1 135395-135871 * ## ... ... ... ... ## [24044] chrY 56864377-56864627 * ## [24045] chrY 56876124-56876182 * ## [24046] chrM 84-2450 * ## [24047] chrM 13613-14955 * ## [24048] chrM 15134-16490 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 2.3 Link ATAC-seq peaks to target genes Next, we compute peak to gene correlations using a custom algorithm that has similar performance to ArchRs P2G function. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, reducedDim = reducedDimMatrix, exp_assay = &quot;normalizedCounts&quot;) ## Using epiregulon to compute peak to gene links... ## performing k means clustering to form metacells ## Computing correlation p2g ## DataFrame with 25693 rows and 8 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; ## 1 1 chr1 817121 817621 19 FAM41C ## 2 6 chr1 869650 870150 14 AL669831.2 ## 3 10 chr1 920987 921487 19 FAM41C ## 4 22 chr1 960317 960817 19 FAM41C ## 5 22 chr1 960317 960817 28 PERM1 ## ... ... ... ... ... ... ... ## 25689 126586 chrX 155071227 155071727 36422 MTCP1 ## 25690 126590 chrX 155228844 155229344 36426 CLIC2 ## 25691 126592 chrX 155334445 155334945 36426 CLIC2 ## 25692 126596 chrX 155820104 155820604 36436 VAMP7 ## 25693 126599 chrX 155897986 155898486 36436 VAMP7 ## Correlation distance ## &lt;matrix&gt; &lt;integer&gt; ## 1 0.505457 50578 ## 2 0.614009 108540 ## 3 0.662441 50587 ## 4 0.635411 89917 ## 5 0.614227 18210 ## ... ... ... ## 25689 0.504839 0 ## 25690 0.830640 103268 ## 25691 0.529991 0 ## 25692 0.629908 58739 ## 25693 0.505036 16442 2.4 Add TF motif binding to peaks The next step is to add the TF binding information by overlapping regions of the peak matrix with the bulk chip-seq database loaded in 2. The user can supply either an archR project path and this function will retrieve the peak matrix, or a peakMatrix in the form of a Granges object or RangedSummarizedExperiment. overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) ## Computing overlap... ## Success! head(overlap) ## idxATAC idxTF tf ## 1 1 2 5-mC ## 2 1 22 AML1-ETO ## 3 1 25 AR ## 4 1 49 ATF1 ## 5 1 50 ATF2 ## 6 1 51 ATF3 2.5 Generate regulons A long format data frame, representing the inferred regulons, is then generated. The data frame consists of three important columns: tf (transcription factor) target gene peak to gene correlation between tf and target gene regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 3187407 rows and 10 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 1 chr1 817121 817621 19 FAM41C ## 2 1 chr1 817121 817621 19 FAM41C ## 3 1 chr1 817121 817621 19 FAM41C ## 4 1 chr1 817121 817621 19 FAM41C ## 5 1 chr1 817121 817621 19 FAM41C ## ... ... ... ... ... ... ... ## 3187403 126599 chrX 155897986 155898486 36436 VAMP7 ## 3187404 126599 chrX 155897986 155898486 36436 VAMP7 ## 3187405 126599 chrX 155897986 155898486 36436 VAMP7 ## 3187406 126599 chrX 155897986 155898486 36436 VAMP7 ## 3187407 126599 chrX 155897986 155898486 36436 VAMP7 ## distance idxTF tf corr ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 50578 2 5-mC 0.505457 ## 2 50578 22 AML1-ETO 0.505457 ## 3 50578 25 AR 0.505457 ## 4 50578 49 ATF1 0.505457 ## 5 50578 50 ATF2 0.505457 ## ... ... ... ... ... ## 3187403 16442 436 HOXB13 0.505036 ## 3187404 16442 669 NANOG 0.505036 ## 3187405 16442 762 ONECUT2 0.505036 ## 3187406 16442 1044 SUMO2 0.505036 ## 3187407 16442 1116 TLE3 0.505036 2.6 Network pruning (highly recommended) Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the active category is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section on differential networks. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon, clusters = GeneExpressionMatrix$Clusters, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05 ) ## pruning network with chi.sq tests using a regulon cutoff of pval&lt;0.05 ## pruning regulons pruned.regulon ## DataFrame with 522788 rows and 13 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 22 chr1 960317 960817 28 PERM1 ## 2 56 chr1 1124416 1124916 40 AL390719.2 ## 3 122 chr1 1375717 1376217 61 CCNL2 ## 4 631 chr1 7961380 7961880 210 AL034417.4 ## 5 655 chr1 8061169 8061669 208 TNFRSF9 ## ... ... ... ... ... ... ... ## 522784 123295 chr9 127937015 127937515 34999 ENG ## 522785 123404 chr9 128829592 128830092 35051 NUP188 ## 522786 123437 chr9 129110677 129111177 35062 AL158151.3 ## 522787 124017 chr9 136847262 136847762 35226 TMEM141 ## 522788 125706 chrX 107206372 107206872 36012 NUP62CL ## distance idxTF tf corr pval ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 18210 5 ADNP 0.614227 0.106264786:0.8357430:1:... ## 2 42439 5 ADNP 0.582570 0.130376176:0.9242106:1:... ## 3 12724 5 ADNP 0.616679 0.189979998:0.0242908:1:... ## 4 27252 5 ADNP 0.552592 0.112531104:0.4154439:1:... ## 5 120104 5 ADNP 0.780316 0.000579039:0.1049407:1:... ## ... ... ... ... ... ... ## 522784 89649 1557 ZXDC 0.719295 5.28805e-04:0.9463687:1:... ## 522785 115605 1557 ZXDC 0.590378 8.86947e-03:0.0386721:1:... ## 522786 62628 1557 ZXDC 0.636463 3.89737e-06:0.8587396:1:... ## 522787 55719 1557 ZXDC 0.575078 4.78049e-02:0.2373499:1:... ## 522788 0 1557 ZXDC 0.608867 1.65029e-01:0.8157342:1:... ## stats qval ## &lt;matrix&gt; &lt;matrix&gt; ## 1 2.60891:0.04299061:0:... 1:1:1:... ## 2 2.28802:0.00904996:0:... 1:1:1:... ## 3 1.71777:5.07374677:0:... 1:1:1:... ## 4 2.51831:0.66316759:0:... 1:1:1:... ## 5 11.84218:2.62880407:0:... 1:1:1:... ## ... ... ... ## 522784 12.01125:0.00452493:0:... 1:1:1:... ## 522785 6.84892:4.27521247:0:... 1:1:1:... ## 522786 21.31467:0.03167648:0:... 1:1:1:... ## 522787 3.91683:1.39626547:0:... 1:1:1:... ## 522788 1.92753:0.05430531:0:... 1:1:1:... 2.7 Add Weights While the `pruneRegulon function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the three measures: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, or 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Two measures (correlation and Wilcoxon) give both the magnitude and directionality of changes whereas mutational information is always positive. The correlation and mutual information statistics are computed on grouped pseudobulks by user-supplied cluster labels and yield a single weight across all clusters per each TF-RE-target triplet. In contrast, the Wilcoxon method group cells based on the joint expression of TF, RE and TG in each single cell or in cell aggregates. If cell labels are provided, we calculate cluster-specific weights in addition to estimating weights from all the cells. Cell aggregation uses a default value of 10 cells and can help overcome sparsity and speed up computation. If cluster labels are provided, we can obtain weights of individual clusters and all cells combined. In this example, we apply Wilcoxon test on cell aggregates of 10 cells. In this example, we illustrate weight estimation using the correlation method. We chose correlation as the weight estimation because we reasoned that the increase in TF activity is driven by the overexpression of the TF, and thus its target genes should see a corresponding change in their expression. When tf_re.merge is set to TRUE, we compute weight based on the correlation between TG gene expression and the product of the TF gene expression and RE chromatin accessibility. If tf_re.merge is set to FALSE, we do not take into account the RE chromatin accessibility and the correlation is computed only based on the correlation between TG gene expression and TF gene expression. Here, we set tf_re.merge to TRUE because we are interested in target genes whose gene expression and chromatin accessibility at the regulatory elements change concordantly with the expression of their putative transcription factors. regulon.w &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$Clusters, block_factor = NULL, tf_re.merge = TRUE, method = &quot;corr&quot;) regulon.w 2.8 (Optional) Annotate with TF motifs So far the gene regulatory network was constructed from TF ChIP-seq exclusively. Some users would prefer to further annotate the regulatory elements with the presence of motifs. We provide an option to annotate peaks with motifs from the Cisbp database. If motifs are available for a factor and the RE contains a motif, we return 1. If motifs are available and the RE does not contain a motif, we return 0. If no motifs are known for this particular factor (as in the case of co-factors or chromatin modifiers), we return NA. In this example, while we illustrate the possibility of annotating regulons with motifs, we contain the remaining workflow with the full regulons regulon.w. It is important to note that filtering for the presence of motifs removes a large fraction of the target genes because motifs are often present in a small subset of the ChIP-seq peaks (can be as low as 10%). Second, indirect TF binding, possibly through its interaction partners, may have a true biological function. However, if the user would prefer to retain only target genes with REs containing the motif of the TFs, they should proceed with regulon.w.motif. regulon.w.motif &lt;- addMotifScore(regulon = regulon.w, peaks = rowRanges(PeakMatrix), species = &quot;human&quot;, genome = &quot;hg38&quot;) ## annotating peaks with motifs ## ## ## Attaching package: &#39;Biostrings&#39; ## The following object is masked from &#39;package:base&#39;: ## ## strsplit ## ## Attaching package: &#39;rtracklayer&#39; ## The following object is masked from &#39;package:BiocIO&#39;: ## ## FileForFormat ## The following object is masked from &#39;package:AnnotationHub&#39;: ## ## hubUrl # if desired, set weight to 0 if no motif is found regulon.w.motif$weight[regulon.w.motif$motif == 0] &lt;- 0 2.9 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging expressions of target genes linked to the TF weighted by the test statistics of choice, chosen from either correlation, mutual information or Wilcoxon test statistics. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weights_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,,n} \\(weights_i\\) is the weight of TF and target i score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;, exp_assay = &quot;normalizedCounts&quot;, normalize = FALSE) ## calculating TF activity from regulon using weightedmean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by the number of targets... 2.10 Perform differential activity library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, groups = GeneExpressionMatrix$hash_assignment, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) ## Warning: The `groups` argument of `findDifferentialActivity()` is deprecated as of ## epiregulon.extra 1.0.0. ## i Please use the `clusters` argument instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. Take the top TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) ## Using a logFC cutoff of 0 for class HTO1_FOXA2_v2 ## Using a logFC cutoff of 0.2 for class HTO10_GATA6_UTR ## Using a logFC cutoff of 0.2 for class HTO2_GATA6_v2 ## Using a logFC cutoff of 0 for class HTO3_NKX2.1_v2 ## Using a logFC cutoff of 0 for class HTO4_mFOXA1_v2 ## Using a logFC cutoff of 0 for class HTO5_NeonG_v2 ## Using a logFC cutoff of 0 for class HTO6_hFOXA1_UTR ## Using a logFC cutoff of 0 for class HTO8_NKX2.1_UTR 2.11 Visualize the results First visualize the known differential TFs by bubble plot plotBubble(activity_matrix = score.combine, tf = c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;), clusters = GeneExpressionMatrix$hash_assignment) Then visualize the most differential TFs by clusters plotBubble(activity_matrix = score.combine, tf = markers.sig$tf, clusters = GeneExpressionMatrix$hash_assignment) Visualize the known differential TFs by violin plot. plotActivityViolin(activity_matrix = score.combine, tf = c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;), clusters = GeneExpressionMatrix$hash_assignment) Visualize the known differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine, tf = c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;Clusters&quot;, point_size = 1, ncol = 3) In contrast, the gene expression of the TFs is very sparse plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = counts(GeneExpressionMatrix), tf = c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;Clusters&quot;, point_size = 1, ncol = 3, limit = c(0,2), colors = c(&quot;grey&quot;,&quot;blue&quot;), legend.label = &quot;GEX&quot;) Visualize the gene expression of the regulons by heatmap plotHeatmapRegulon(sce=GeneExpressionMatrix, tfs=c(&quot;GATA6&quot;,&quot;NKX2-1&quot;), regulon=regulon.w, regulon_cutoff=0.1, downsample=1000, cell_attributes=&quot;Clusters&quot;, col_gap=&quot;Clusters&quot;, exprs_values=&quot;counts&quot;, name=&quot;regulon heatmap&quot;) plotHeatmapActivity(activity=score.combine, sce=GeneExpressionMatrix, tfs=rownames(score.combine), downsample=5000, cell_attributes=&quot;Clusters&quot;, col_gap=&quot;Clusters&quot;, name = &quot;Activity&quot;) 2.12 Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot; ) C2 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C2&quot;, gene.id.type = &quot;SYMBOL&quot; ) C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot; ) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H, C2, C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = c(&quot;GATA6&quot;,&quot;NKX2-1&quot;), regulon = regulon.w, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## GATA6 ## NKX2-1 #plot results enrichPlot(results = enrichresults ) 2.13 Network analysis We can visualize the genesets as a network plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) 2.14 Session Info sessionInfo() ## R version 4.3.0 (2023-04-21) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/local/lib/R/lib/libRblas.so ## LAPACK: /usr/local/lib/R/lib/libRlapack.so; LAPACK version 3.11.0 ## ## locale: ## [1] LC_CTYPE=C LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] org.Hs.eg.db_3.18.0 AnnotationDbi_1.63.2 ## [3] msigdbr_7.5.1 epiregulon.extra_0.99.0 ## [5] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.69.1 ## [7] rtracklayer_1.61.2 BiocIO_1.11.0 ## [9] Biostrings_2.69.2 XVector_0.41.2 ## [11] DelayedArray_0.27.10 epiregulon_1.0.36 ## [13] HDF5Array_1.29.3 scMultiome_1.1.2 ## [15] SingleCellExperiment_1.23.0 MultiAssayExperiment_1.27.5 ## [17] SummarizedExperiment_1.31.1 Biobase_2.61.0 ## [19] GenomicRanges_1.53.3 GenomeInfoDb_1.37.7 ## [21] IRanges_2.35.3 S4Vectors_0.39.3 ## [23] MatrixGenerics_1.13.2 matrixStats_1.0.0 ## [25] ExperimentHub_2.9.1 AnnotationHub_3.9.2 ## [27] BiocFileCache_2.9.1 dbplyr_2.3.4 ## [29] BiocGenerics_0.47.1 ## ## loaded via a namespace (and not attached): ## [1] fs_1.6.2 bitops_1.0-7 ## [3] enrichplot_1.21.3 DirichletMultinomial_1.43.0 ## [5] TFBSTools_1.40.0 HDO.db_0.99.1 ## [7] httr_1.4.6 RColorBrewer_1.1-3 ## [9] doParallel_1.0.17 Rgraphviz_2.45.0 ## [11] tools_4.3.0 backports_1.4.1 ## [13] utf8_1.2.3 R6_2.5.1 ## [15] lazyeval_0.2.2 rhdf5filters_1.13.5 ## [17] GetoptLong_1.0.5 withr_2.5.0 ## [19] gridExtra_2.3 cli_3.6.1 ## [21] Cairo_1.6-1 scatterpie_0.2.1 ## [23] labeling_0.4.3 sass_0.4.6 ## [25] KEGGgraph_1.61.0 readr_2.1.4 ## [27] yulab.utils_0.1.0 Rsamtools_2.17.0 ## [29] gson_0.1.0 DOSE_3.27.3 ## [31] R.utils_2.12.2 scater_1.29.4 ## [33] limma_3.57.11 rstudioapi_0.15.0 ## [35] RSQLite_2.3.1 gridGraphics_0.5-1 ## [37] generics_0.1.3 shape_1.4.6 ## [39] gtools_3.9.4 dplyr_1.1.3 ## [41] GO.db_3.18.0 Matrix_1.6-3 ## [43] ggbeeswarm_0.7.2 fansi_1.0.4 ## [45] abind_1.4-5 R.methodsS3_1.8.2 ## [47] lifecycle_1.0.3 yaml_2.3.7 ## [49] edgeR_3.99.6 qvalue_2.33.0 ## [51] rhdf5_2.45.1 SparseArray_1.1.12 ## [53] grid_4.3.0 blob_1.2.4 ## [55] promises_1.2.0.1 dqrng_0.3.1 ## [57] crayon_1.5.2 lattice_0.22-5 ## [59] beachmat_2.17.17 cowplot_1.1.1 ## [61] annotate_1.79.0 KEGGREST_1.41.4 ## [63] magick_2.8.1 pillar_1.9.0 ## [65] knitr_1.44 ComplexHeatmap_2.17.0 ## [67] metapod_1.9.0 fgsea_1.27.1 ## [69] rjson_0.2.21 codetools_0.2-19 ## [71] fastmatch_1.1-4 glue_1.6.2 ## [73] ggfun_0.1.3 data.table_1.14.8 ## [75] treeio_1.25.4 vctrs_0.6.3 ## [77] png_0.1-8 gtable_0.3.4 ## [79] poweRlaw_0.70.6 cachem_1.0.8 ## [81] xfun_0.39 S4Arrays_1.1.6 ## [83] mime_0.12 tidygraph_1.2.3 ## [85] pracma_2.4.2 iterators_1.0.14 ## [87] statmod_1.5.0 bluster_1.11.4 ## [89] interactiveDisplayBase_1.39.0 ellipsis_0.3.2 ## [91] nlme_3.1-163 ggtree_3.9.1 ## [93] bit64_4.0.5 filelock_1.0.2 ## [95] bslib_0.5.1 irlba_2.3.5.1 ## [97] vipor_0.4.5 colorspace_2.1-0 ## [99] seqLogo_1.67.0 DBI_1.1.3 ## [101] tidyselect_1.2.0 bit_4.0.5 ## [103] compiler_4.3.0 curl_5.0.0 ## [105] graph_1.79.4 BiocNeighbors_1.19.0 ## [107] shadowtext_0.1.2 bookdown_0.36 ## [109] checkmate_2.2.0 scales_1.2.1 ## [111] caTools_1.18.2 rappdirs_0.3.3 ## [113] stringr_1.5.0 digest_0.6.31 ## [115] motifmatchr_1.23.0 rmarkdown_2.25 ## [117] htmltools_0.5.5 pkgconfig_2.0.3 ## [119] sparseMatrixStats_1.13.4 fastmap_1.1.1 ## [121] rlang_1.1.1 GlobalOptions_0.1.2 ## [123] shiny_1.7.5.1 DelayedMatrixStats_1.23.9 ## [125] farver_2.1.1 jquerylib_0.1.4 ## [127] jsonlite_1.8.7 BiocParallel_1.35.4 ## [129] GOSemSim_2.27.3 R.oo_1.25.0 ## [131] BiocSingular_1.17.1 RCurl_1.98-1.12 ## [133] magrittr_2.0.3 ggplotify_0.1.2 ## [135] scuttle_1.11.3 GenomeInfoDbData_1.2.11 ## [137] patchwork_1.1.3 Rhdf5lib_1.23.2 ## [139] munsell_0.5.0 Rcpp_1.0.11 ## [141] ape_5.7-1 babelgene_22.9 ## [143] viridis_0.6.4 EnrichmentBrowser_2.31.5 ## [145] stringi_1.7.12 ggraph_2.1.0 ## [147] MASS_7.3-60 zlibbioc_1.47.0 ## [149] plyr_1.8.9 HPO.db_0.99.2 ## [151] parallel_4.3.0 ggrepel_0.9.4 ## [153] CNEr_1.37.0 graphlayouts_1.0.1 ## [155] splines_4.3.0 hms_1.1.3 ## [157] circlize_0.4.15 locfit_1.5-9.8 ## [159] igraph_1.5.1 reshape2_1.4.4 ## [161] ScaledMatrix_1.9.1 TFMPvalue_0.0.9 ## [163] BiocVersion_3.18.0 XML_3.99-0.14 ## [165] evaluate_0.21 scran_1.29.3 ## [167] BiocManager_1.30.22 tweenr_2.0.2 ## [169] tzdb_0.4.0 foreach_1.5.2 ## [171] httpuv_1.6.11 polyclip_1.10-6 ## [173] tidyr_1.3.0 purrr_1.0.2 ## [175] clue_0.3-65 ggplot2_3.4.4 ## [177] ggforce_0.4.1 rsvd_1.0.5 ## [179] xtable_1.8-4 restfulr_0.0.15 ## [181] tidytree_0.4.5 MPO.db_0.99.7 ## [183] later_1.3.1 viridisLite_0.4.2 ## [185] tibble_3.2.1 aplot_0.2.2 ## [187] clusterProfiler_4.9.5 memoise_2.0.1 ## [189] beeswarm_0.4.0 GenomicAlignments_1.37.0 ## [191] cluster_2.1.4 GSEABase_1.63.0 ## [193] BiocStyle_2.29.2 "],["advanced-workflow-with-multiassayexperiment.html", "3 Advanced workflow with MultiAssayExperiment 3.1 Data preparation 3.2 Retrieve bulk TF ChIP-seq binding sites 3.3 Link ATACseq peaks to target genes 3.4 Add TF motif binding to peaks 3.5 Generate regulons 3.6 Prune network 3.7 Add Weights 3.8 Calculate TF activity 3.9 Differential TF activity test 3.10 Visualizing TF activities 3.11 Geneset enrichment 3.12 Differential Network analysis 3.13 Session Info", " 3 Advanced workflow with MultiAssayExperiment In this chapter, we illustrate the epiregulon workflow starting from data in the form of SingleCellExperiment objects using the Wilcoxon weight estimation method. This is a dataset of hematopoiesis from the ArchR tutorial. Prior to using epiregulon, this dataset has been fully preprocessed in ArchR, and converted to a MultiAssayExperiment using epireglon.archr::archr2MAE. The MAE object was uploaded to scMultiome for full reproducibility. In this dataset, scRNAseq and scATACseq were unpaired and integrated by the ArchR::addGeneIntegrationMatrix function. 3.1 Data preparation Download the example dataset from scMultiome package mae &lt;- scMultiome::hematopoiesis() # Load peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # Load expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneIntegrationMatrix&quot;]] # Add gene symbols to rownames rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name # Transfer dimensionality reduction matrix to GeneExpression reducedDim(GeneExpressionMatrix, &quot;IterativeLSI&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;IterativeLSI&quot;) reducedDim(GeneExpressionMatrix, &quot;UMAP&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;UMAP&quot;) Visualize the data scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP&quot;, text_by = &quot;Clusters2&quot;, colour_by = &quot;Clusters2&quot;, point_size = 0.3, point_alpha = 0.3) 3.2 Retrieve bulk TF ChIP-seq binding sites First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq. Currently, human genomes hg19 and hg38 and mouse genome mm10 are available library(epiregulon) grl &lt;- getTFMotifInfo(genome = &quot;hg19&quot;) ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache grl ## GRangesList object of length 1558: ## $`5-hmC` ## GRanges object with 22860 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 10001-10685 * ## [2] chr1 13362-13694 * ## [3] chr1 29631-29989 * ## [4] chr1 40454-40754 * ## [5] chr1 135395-135871 * ## ... ... ... ... ## [22856] chrM 15303-15326 * ## [22857] chrM 15328-16172 * ## [22858] chrM 16174-16183 * ## [22859] chrM 16186-16224 * ## [22860] chrM 16226-16492 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 3.3 Link ATACseq peaks to target genes Next, we compute peak to gene correlations using a custom algorithm that has similar performance to ArchRs P2G function. Wherever possible, use a multidimensional dimensionality reduction matrix such as LSI or PCA instead of UMAP or TSNE since the former provides a more accurate estimate of cell similarity. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;IterativeLSI&quot;)) ## Using epiregulon to compute peak to gene links... ## performing k means clustering to form metacells ## Computing correlation p2g ## DataFrame with 23711 rows and 8 columns ## idxATAC chr start end idxRNA target Correlation ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; ## 1 7 chr1 801002 801502 2 LINC00115 0.864244 ## 2 8 chr1 805039 805539 6 KLHL17 0.625471 ## 3 9 chr1 845326 845826 10 AGRN 0.545993 ## 4 10 chr1 846428 846928 10 AGRN 0.646209 ## 5 13 chr1 856263 856763 10 AGRN 0.549411 ## ... ... ... ... ... ... ... ... ## 23707 146403 chr22 51021154 51021654 12089 ARSA 0.655996 ## 23708 146412 chr22 51110826 51111326 12090 SHANK3 0.560404 ## 23709 146417 chr22 51143606 51144106 12090 SHANK3 0.500026 ## 23710 146421 chr22 51213512 51214012 12090 SHANK3 0.504567 ## 23711 146421 chr22 51213512 51214012 12091 ACR 0.557113 ## distance ## &lt;integer&gt; ## 1 36099 ## 2 88427 ## 3 107676 ## 4 106574 ## 5 96739 ## ... ... ## 23707 44747 ## 23708 0 ## 23709 30336 ## 23710 100242 ## 23711 36660 3.4 Add TF motif binding to peaks The next step is to add the TF motif binding information by overlapping the regions of the peak matrix with the bulk chip-seq database. overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) ## Computing overlap... ## Success! head(overlap) ## idxATAC idxTF tf ## 1018 7 35 ARNT ## 1019 7 50 ATF2 ## 1020 7 55 ATF7 ## 1021 7 76 BCL6 ## 1022 7 80 BCOR ## 1023 7 82 BHLHE40 3.5 Generate regulons A long format dataframe, representing the inferred regulons, is then generated. The dataframe consists of three columns: tf (transcription factor) target gene peak to gene correlation between tf and target gene regulon &lt;- getRegulon(p2g, overlap, aggregate=FALSE) regulon ## DataFrame with 3561693 rows and 10 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 7 chr1 801002 801502 2 LINC00115 ## 2 7 chr1 801002 801502 2 LINC00115 ## 3 7 chr1 801002 801502 2 LINC00115 ## 4 7 chr1 801002 801502 2 LINC00115 ## 5 7 chr1 801002 801502 2 LINC00115 ## ... ... ... ... ... ... ... ## 3561689 146421 chr22 51213512 51214012 12091 ACR ## 3561690 146421 chr22 51213512 51214012 12091 ACR ## 3561691 146421 chr22 51213512 51214012 12091 ACR ## 3561692 146421 chr22 51213512 51214012 12091 ACR ## 3561693 146421 chr22 51213512 51214012 12091 ACR ## distance idxTF tf corr ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 36099 35 ARNT 0.864244 ## 2 36099 50 ATF2 0.864244 ## 3 36099 55 ATF7 0.864244 ## 4 36099 76 BCL6 0.864244 ## 5 36099 80 BCOR 0.864244 ## ... ... ... ... ... ## 3561689 36660 1433 ZNF574 0.557113 ## 3561690 36660 1468 ZNF654 0.557113 ## 3561691 36660 1471 ZNF660 0.557113 ## 3561692 36660 1480 ZNF692 0.557113 ## 3561693 36660 1546 ZSCAN30 0.557113 3.6 Prune network Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the active category is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section on differential networks. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, regulon = regulon, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05, clusters = GeneExpressionMatrix$Clusters2) ## pruning network with chi.sq tests using a regulon cutoff of pval&lt;0.05 ## pruning regulons 3.7 Add Weights While the pruneRegulon function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the three measures: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, or 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Two measures (correlation and Wilcoxon) give both the magnitude and directionality of changes whereas mutational information is always positive. The correlation and mutual information statistics are computed on grouped pseudobulks by user-supplied cluster labels and yield a single weight across all clusters per each TF-RE-target triplet. In contrast, the Wilcoxon method group cells based on the joint expression of TF, RE and TG in each single cell or in cell aggregates. If cell labels are provided, we calculate cluster-specific weights in addition to estimating weights from all the cells. Cell aggregation uses a default value of 10 cells and can help overcome sparsity and speed up computation. If cluster labels are provided, we can obtain weights of individual clusters and all cells combined. In this example, we apply Wilcoxon test on cell aggregates of 10 cells. We use the Wilcoxon weight method because we are interested in computing cell type-specific weights. set.seed(1010) regulon.w &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$Clusters2, aggregateCells = TRUE, method = &quot;wilcox&quot;, useDim = &quot;IterativeLSI&quot;) ## adding weights using wilcoxon... ## performing pseudobulk using an average of 10 cells regulon.w ## DataFrame with 657594 rows and 14 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 732 chr1 8021367 8021867 95 UTS2 ## 2 891 chr1 9223922 9224422 107 H6PD ## 3 1153 chr1 11724014 11724514 135 FBXO6 ## 4 1154 chr1 11724524 11725024 135 FBXO6 ## 5 1476 chr1 16003338 16003838 181 DDI2 ## ... ... ... ... ... ... ... ## 657590 115554 chr16 47526755 47527255 6715 PHKB ## 657591 123738 chr17 57297651 57298151 7874 SKA2 ## 657592 137124 chr20 5654865 5655365 11011 GPCPD1 ## 657593 146371 chr22 50946298 50946798 12078 LMF2 ## 657594 146387 chr22 50977917 50978417 12078 LMF2 ## distance idxTF tf corr pval ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 46072 5 ADNP 0.611979 1.11552e-06:1:0.00021207:... ## 2 68440 5 ADNP 0.584584 2.42572e-53:1:1.00000000:... ## 3 0 5 ADNP 0.592732 4.93505e-07:1:0.96772981:... ## 4 174 5 ADNP 0.628880 1.70871e-07:1:0.96772981:... ## 5 59185 5 ADNP 0.814973 2.50344e-04:1:1.00000000:... ## ... ... ... ... ... ... ## 657590 31345 1554 ZSCAN9 0.677586 0.2147565:1:1:... ## 657591 62850 1554 ZSCAN9 0.579244 0.0222662:1:1:... ## 657592 61192 1554 ZSCAN9 0.567896 0.2157159:1:1:... ## 657593 0 1554 ZSCAN9 0.620394 0.0769296:1:1:... ## 657594 29781 1554 ZSCAN9 0.517633 0.0769296:1:1:... ## stats qval ## &lt;matrix&gt; &lt;matrix&gt; ## 1 23.7177:0:13.72100224:... 1.00000e+00:1:1:... ## 2 236.3764:0: 0.00000000:... 7.88534e-47:1:1:... ## 3 25.2890:0: 0.00163667:... 1.00000e+00:1:1:... ## 4 27.3374:0: 0.00163667:... 5.15668e-01:1:1:... ## 5 13.4096:0: 0.00000000:... 1.00000e+00:1:1:... ## ... ... ... ## 657590 1.53907:0:0:... 1:1:1:... ## 657591 5.22486:0:0:... 1:1:1:... ## 657592 1.53265:0:0:... 1:1:1:... ## 657593 3.12860:0:0:... 1:1:1:... ## 657594 3.12860:0:0:... 1:1:1:... ## weight ## &lt;matrix&gt; ## 1 0.110121:-0.1840694:0.132197:... ## 2 0.328729: 0.0954775:0.218160:... ## 3 0.141786: 0.0000000:0.163860:... ## 4 0.142351: 0.1861417:0.180140:... ## 5 0.175202: 0.0000000:0.000000:... ## ... ... ## 657590 0.05056956:0:0:... ## 657591 0.28572101:0:0:... ## 657592 -0.01610573:0:0:... ## 657593 -0.00410307:0:0:... ## 657594 0.02891813:0:0:... 3.8 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging the weighted expressions of target genes linked to the TF weighted. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weight_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,,n} \\(weight_i\\) is the weight of TF and target i score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;, exp_assay = &quot;normalizedCounts&quot;) ## calculating TF activity from regulon using weightedmean ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, regulon = ## regulon.w, : The weight column contains multiple subcolumns but no cluster ## information was provided. Using first column to compute activity... ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by the number of targets... head(score.combine[1:5,1:5]) ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 ## ADNP 0.12540975 0.1984176 ## AFF1 0.17697747 0.1920722 ## AFF4 0.11773447 0.3040020 ## AGO1 0.14920749 0.2183450 ## AGO2 0.08608048 0.3196278 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 ## ADNP 0.1406705 0.1528068 ## AFF1 0.4015928 0.1837701 ## AFF4 0.1335912 0.1905391 ## AGO1 0.1035857 0.1647813 ## AGO2 0.1104752 0.1816408 ## scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 ## ADNP 0.14890448 ## AFF1 0.19387846 ## AFF4 0.13224086 ## AGO1 0.17582525 ## AGO2 0.08222916 3.9 Differential TF activity test We can next determine which TFs exhibit differential activities across cell clusters/groups via the findDifferentialActivity function. This function depends on findMarkers function from scran package. library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = GeneExpressionMatrix$Clusters2, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) getSigGenes compiles the different test results into a single dataframe and enables user to supply their desired cutoffs for significance and variable to order by. markers.sig &lt;- getSigGenes(markers, topgenes = 3 ) ## Using a logFC cutoff of 0.1 for class B ## Using a logFC cutoff of 0.4 for class CD4.M ## Using a logFC cutoff of 0.2 for class CD4.N ## Using a logFC cutoff of 0.1 for class CLP ## Using a logFC cutoff of 0.2 for class Erythroid ## Using a logFC cutoff of 0.1 for class GMP ## Using a logFC cutoff of 0.6 for class Mono ## Using a logFC cutoff of 0.4 for class NK ## Using a logFC cutoff of 0.1 for class pDC ## Using a logFC cutoff of 0.2 for class PreB ## Using a logFC cutoff of 0.1 for class Progenitor 3.10 Visualizing TF activities Epiregulon also provides multiple options for visualizing the inferred TF activities by reduced dimensional space tSNE or UMAP plots: options(ggrastr.default.dpi=300) tfs_interest &lt;- c(&quot;EBF1&quot;,&quot;PAX5&quot;, &quot;GATA3&quot;,&quot;SPI1&quot;) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP&quot;, nrow=2, ncol=2, point_size=0.1, rasterise = TRUE) We can compare the activity with gene expression of the same TFs. plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP&quot;, nrow=2, ncol=2, legend.label = &quot;Gex&quot;, colors = c(&quot;grey&quot;,&quot;blue&quot;), point_size=0.1, rasterise = TRUE) We can also plot violin plot to visualize TF activity. plotActivityViolin(activity_matrix = score.combine, tf = tfs_interest, clusters = GeneExpressionMatrix$Clusters2, legend.label = &quot;Gex&quot;, nrow=2, ncol=2) We plot violin plot to visualize TF gene expression. plotActivityViolin(activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, clusters = GeneExpressionMatrix$Clusters2, nrow=2, ncol=2, legend.label = &quot;gene expression&quot;) We can visualize the different TFs in a bubble plot: plotBubble(activity_matrix = score.combine, tf = tfs_interest, GeneExpressionMatrix$Clusters2, bubblesize = &quot;FDR&quot;) We visualize the top differential TFs based on activity. plotBubble(activity_matrix = score.combine, tf = markers.sig$tf, GeneExpressionMatrix$Clusters2, bubblesize = &quot;FDR&quot;) 3.11 Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. Here we first download Hallmark and C2 signatures from hallmark and then perform gene set enrichment of the known lineage factors. As expected, EBF1 is consistent with a B cell lineage factor, GATA3 and RUNX3 with lymphoid lineage and SPI1 with myeloid lineage. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot; ) C2 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C2&quot;, gene.id.type = &quot;SYMBOL&quot; ) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H, C2) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = tfs_interest, regulon = regulon.w, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## EBF1 ## PAX5 ## GATA3 ## SPI1 #plot results enrichPlot(results = enrichresults, ncol=2) 3.12 Differential Network analysis In addition to looking at the summed TF activity, a second approach to investigate differential TF activity is to compare and contrast target genes or network topology. In this example, we know that EBF1 is a B cell lineage factor. If we plot the differential network of EBF1 using the regulon with cluster-specific weights, we can see that EBF1 has many more targets in PreB cells than it has in CD4 memory T cells. plotDiffNetwork(regulon.w, cutoff = 0, tf = c(&quot;EBF1&quot;), weight = &quot;weight&quot;, clusters = c(&quot;PreB&quot;,&quot;CD4.M&quot;), layout = &quot;stress&quot;) ## Replacement of na values for weights with 0 ## Building graph using weight as edge weights Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of the targets genes for all the TFs and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to EBF1, and we successfully identify PAX5 as the most similar TF. Both PAX5 and EBF1 are important factors for B cell development (https://www.nature.com/articles/ni.2641). library(ggplot2) # construct a graph of the preB cells preB_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;PreB&quot;) ## Building graph using weight as edge weights # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(preB_network) # Focus on EBF1 similarity_score_EBF1 &lt;- similarity_score[, &quot;EBF1&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_EBF1, decreasing = TRUE),20), TF = names(head(sort(similarity_score_EBF1, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;EBF1 similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(preB_network, &quot;EBF1&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_EBF1),] diff_matrix &lt;- similarity_score_EBF1-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted EBF1 similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_EBF1})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## PAX5 IRF4 TCF3 RAG2 TCF12 POU2F2 RB1 NIPBL TCF4 TRIM22 RAG1 ## 0 0 0 0 0 0 0 0 0 0 0 ## BCL11A RELB MEF2A CREM MYB EZH2 EP300 CDK9 CREBBP ## 0 0 0 0 0 0 0 0 0 Next, we are interested to compare the networks of two cell types, in this case, CD4 memory T cells (CD4.M) vs Monocytes (mono) cells. We build an edge subtracted graph and then calculate the degree centrality of the subtracted graph. We normalize centrality using the default square root function. The top 5 most positive TFs represent lineage factors more active in NK cells whereas the bottom 5 TFs present lineage factors enriched in CD4. We successfully identified the myeloid factor SPI1 to be associated with monocytes and Th1 factor TBX21 to be associated with CD4 T cells. #regulon.w.2 &lt;- regulon.w #regulon.w &lt;- readRDS(&quot;/gstore/project/lineage/manuscript/epiregulon/OUTPUT/regulon.w.rds&quot;) # construct a graph of the CD4.M and NK cells respectively CD4.M_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;CD4.M&quot;) ## Building graph using weight as edge weights Mono_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;Mono&quot;) ## Building graph using weight as edge weights # construct a difference graph diff_graph &lt;- buildDiffGraph(Mono_network,CD4.M_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table, 10), tail(rank_table, 10)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5, max.overlaps = Inf) + theme_classic() + ggtitle (&quot;differential TFs (Mono-CD4.M) ranked by degree centrality&quot;) We can further explore interacting factors with the myeloid factor SPI1 using the same Jaccard similarity approach. We found CEBPA as the most similar TF as SPI1. SPI1 and CEBPA are known to be important for differentiation into myeloid cells (https://www.cell.com/cell-reports/pdfExtended/S2211-1247(18)30745-9). library(igraph) diff_graph_filter &lt;- subgraph.edges(diff_graph, E(diff_graph)[E(diff_graph)$weight&gt;0], del=TRUE) # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(diff_graph_filter) # Focus on SPI1 similarity_score_SPI1 &lt;- similarity_score[, &quot;SPI1&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_SPI1, decreasing = TRUE),20), TF = names(head(sort(similarity_score_SPI1, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to SPI1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;SPI1 similarity&quot;) + theme_classic() print(topTFplot) 3.13 Session Info sessionInfo() ## R version 4.3.0 (2023-04-21) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/local/lib/R/lib/libRblas.so ## LAPACK: /usr/local/lib/R/lib/libRlapack.so; LAPACK version 3.11.0 ## ## locale: ## [1] LC_CTYPE=C LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] igraph_1.5.1 ggplot2_3.4.4 ## [3] org.Hs.eg.db_3.18.0 AnnotationDbi_1.63.2 ## [5] msigdbr_7.5.1 epiregulon.extra_0.99.0 ## [7] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.69.1 ## [9] rtracklayer_1.61.2 BiocIO_1.11.0 ## [11] Biostrings_2.69.2 XVector_0.41.2 ## [13] DelayedArray_0.27.10 epiregulon_1.0.36 ## [15] HDF5Array_1.29.3 scMultiome_1.1.2 ## [17] SingleCellExperiment_1.23.0 MultiAssayExperiment_1.27.5 ## [19] SummarizedExperiment_1.31.1 Biobase_2.61.0 ## [21] GenomicRanges_1.53.3 GenomeInfoDb_1.37.7 ## [23] IRanges_2.35.3 S4Vectors_0.39.3 ## [25] MatrixGenerics_1.13.2 matrixStats_1.0.0 ## [27] ExperimentHub_2.9.1 AnnotationHub_3.9.2 ## [29] BiocFileCache_2.9.1 dbplyr_2.3.4 ## [31] BiocGenerics_0.47.1 ## ## loaded via a namespace (and not attached): ## [1] fs_1.6.2 bitops_1.0-7 ## [3] enrichplot_1.21.3 DirichletMultinomial_1.43.0 ## [5] TFBSTools_1.40.0 HDO.db_0.99.1 ## [7] httr_1.4.6 RColorBrewer_1.1-3 ## [9] doParallel_1.0.17 Rgraphviz_2.45.0 ## [11] tools_4.3.0 backports_1.4.1 ## [13] utf8_1.2.3 R6_2.5.1 ## [15] lazyeval_0.2.2 rhdf5filters_1.13.5 ## [17] GetoptLong_1.0.5 withr_2.5.0 ## [19] gridExtra_2.3 cli_3.6.1 ## [21] Cairo_1.6-1 scatterpie_0.2.1 ## [23] labeling_0.4.3 sass_0.4.6 ## [25] KEGGgraph_1.61.0 readr_2.1.4 ## [27] yulab.utils_0.1.0 Rsamtools_2.17.0 ## [29] gson_0.1.0 DOSE_3.27.3 ## [31] R.utils_2.12.2 scater_1.29.4 ## [33] limma_3.57.11 rstudioapi_0.15.0 ## [35] RSQLite_2.3.1 gridGraphics_0.5-1 ## [37] generics_0.1.3 shape_1.4.6 ## [39] gtools_3.9.4 dplyr_1.1.3 ## [41] GO.db_3.18.0 Matrix_1.6-3 ## [43] ggbeeswarm_0.7.2 fansi_1.0.4 ## [45] abind_1.4-5 R.methodsS3_1.8.2 ## [47] lifecycle_1.0.3 yaml_2.3.7 ## [49] edgeR_3.99.6 qvalue_2.33.0 ## [51] rhdf5_2.45.1 SparseArray_1.1.12 ## [53] grid_4.3.0 blob_1.2.4 ## [55] promises_1.2.0.1 dqrng_0.3.1 ## [57] crayon_1.5.2 lattice_0.22-5 ## [59] beachmat_2.17.17 cowplot_1.1.1 ## [61] annotate_1.79.0 KEGGREST_1.41.4 ## [63] magick_2.8.1 pillar_1.9.0 ## [65] knitr_1.44 ComplexHeatmap_2.17.0 ## [67] metapod_1.9.0 fgsea_1.27.1 ## [69] rjson_0.2.21 codetools_0.2-19 ## [71] fastmatch_1.1-4 glue_1.6.2 ## [73] ggfun_0.1.3 data.table_1.14.8 ## [75] treeio_1.25.4 vctrs_0.6.3 ## [77] png_0.1-8 gtable_0.3.4 ## [79] poweRlaw_0.70.6 cachem_1.0.8 ## [81] xfun_0.39 S4Arrays_1.1.6 ## [83] mime_0.12 tidygraph_1.2.3 ## [85] pracma_2.4.2 iterators_1.0.14 ## [87] statmod_1.5.0 bluster_1.11.4 ## [89] interactiveDisplayBase_1.39.0 ellipsis_0.3.2 ## [91] nlme_3.1-163 ggtree_3.9.1 ## [93] bit64_4.0.5 filelock_1.0.2 ## [95] bslib_0.5.1 irlba_2.3.5.1 ## [97] vipor_0.4.5 colorspace_2.1-0 ## [99] seqLogo_1.67.0 DBI_1.1.3 ## [101] ggrastr_1.0.2 tidyselect_1.2.0 ## [103] bit_4.0.5 compiler_4.3.0 ## [105] curl_5.0.0 graph_1.79.4 ## [107] BiocNeighbors_1.19.0 shadowtext_0.1.2 ## [109] bookdown_0.36 checkmate_2.2.0 ## [111] scales_1.2.1 caTools_1.18.2 ## [113] rappdirs_0.3.3 stringr_1.5.0 ## [115] digest_0.6.31 motifmatchr_1.23.0 ## [117] rmarkdown_2.25 htmltools_0.5.5 ## [119] pkgconfig_2.0.3 sparseMatrixStats_1.13.4 ## [121] fastmap_1.1.1 rlang_1.1.1 ## [123] GlobalOptions_0.1.2 shiny_1.7.5.1 ## [125] DelayedMatrixStats_1.23.9 farver_2.1.1 ## [127] jquerylib_0.1.4 jsonlite_1.8.7 ## [129] BiocParallel_1.35.4 GOSemSim_2.27.3 ## [131] R.oo_1.25.0 BiocSingular_1.17.1 ## [133] RCurl_1.98-1.12 magrittr_2.0.3 ## [135] ggplotify_0.1.2 scuttle_1.11.3 ## [137] GenomeInfoDbData_1.2.11 patchwork_1.1.3 ## [139] Rhdf5lib_1.23.2 munsell_0.5.0 ## [141] Rcpp_1.0.11 ape_5.7-1 ## [143] babelgene_22.9 viridis_0.6.4 ## [145] EnrichmentBrowser_2.31.5 stringi_1.7.12 ## [147] ggraph_2.1.0 MASS_7.3-60 ## [149] zlibbioc_1.47.0 plyr_1.8.9 ## [151] HPO.db_0.99.2 parallel_4.3.0 ## [153] ggrepel_0.9.4 CNEr_1.37.0 ## [155] graphlayouts_1.0.1 splines_4.3.0 ## [157] hms_1.1.3 circlize_0.4.15 ## [159] locfit_1.5-9.8 reshape2_1.4.4 ## [161] ScaledMatrix_1.9.1 TFMPvalue_0.0.9 ## [163] BiocVersion_3.18.0 XML_3.99-0.14 ## [165] evaluate_0.21 scran_1.29.3 ## [167] BiocManager_1.30.22 tweenr_2.0.2 ## [169] tzdb_0.4.0 foreach_1.5.2 ## [171] httpuv_1.6.11 polyclip_1.10-6 ## [173] tidyr_1.3.0 purrr_1.0.2 ## [175] clue_0.3-65 ggforce_0.4.1 ## [177] rsvd_1.0.5 xtable_1.8-4 ## [179] restfulr_0.0.15 tidytree_0.4.5 ## [181] MPO.db_0.99.7 later_1.3.1 ## [183] viridisLite_0.4.2 tibble_3.2.1 ## [185] aplot_0.2.2 clusterProfiler_4.9.5 ## [187] memoise_2.0.1 beeswarm_0.4.0 ## [189] GenomicAlignments_1.37.0 cluster_2.1.4 ## [191] GSEABase_1.63.0 BiocStyle_2.29.2 "],["archr-workflow-and-different-weight-methods.html", "4 ArchR workflow and different weight methods 4.1 Data preparation 4.2 Load ArchR project 4.3 Retrieve matrices from ArchR project 4.4 Retrieve bulk TF ChIP-seq binding sites 4.5 Link ATAC-seq peaks to target genes 4.6 Add TF motif binding to peaks 4.7 Generate regulons 4.8 (Optional) Annotate with TF motifs 4.9 Prune network 4.10 Add Weights 4.11 Calculate TF activity 4.12 Perform differential activity 4.13 Visualize the results 4.14 Differential network analysis 4.15 Session Info", " 4 ArchR workflow and different weight methods In this chapter, we illustrate the epiregulon workflow starting from an ArchR project and compare the different weight estimation methods. The dataset consists of unpaired scATACseq/scRNAseq of parental LNCaP cells treated with DMSO, Enzalutamide and Enza resistant cells. The dataset was taken from Taavitsainen et al GSE168667 and GSE168668. 4.1 Data preparation Please refer to the full ArchR manual for instructions Before running Epiregulon, the following analyses need to be completed: Obtain a peak matrix on scATACseq by using addGroupCoverages &gt; addReproduciblePeakSet &gt; addPeakMatrix. See chapter 10 from ArchR manual RNA-seq integration. For unpaired scATAC-seq, use addGeneIntegrationMatrix. See chapter 8 from ArchR manual For multiome data, use addGeneExpressionMatrix. See multiome tutorial Perform dimensionality reduction from with either single modalities or joint scRNAseq and scATACseq using addCombinedDims 4.2 Load ArchR project library(ArchR) archR_project_path &lt;- &quot;/gstore/project/lineage/prostate/GSE168667/OUTPUT/multiome/&quot; proj &lt;- loadArchRProject(path = archR_project_path, showLogo = FALSE) We verify that GeneExpressionMatrix and PeakMatrix are present for this tutorial. getAvailableMatrices(proj) ## [1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;MotifMatrix&quot; ## [4] &quot;PeakMatrix&quot; &quot;TileMatrix&quot; We will use the joint reducedDims - LSI_Combined and joint embeddings - UMAP_Combined head(getReducedDims(proj, reducedDims = &quot;iLSI_Combined&quot;)[,1:5]) ## LSI1 LSI2 LSI3 LSI4 ## SRR13927735#TTATGTCTCCAGGTAT-1 -2.713935 -0.3677949 -0.4484238 -0.30645138 ## SRR13927735#TATTGCTCATCAGAAA-1 -2.642781 -0.2767556 -0.9142714 -0.19675812 ## SRR13927735#TTCGATTGTAGGGTTG-1 -2.322865 -0.1543080 -1.4106049 -0.08891276 ## SRR13927735#CATTCATTCGGATGTT-1 -2.572976 -0.1917188 -1.0464294 -0.12660121 ## SRR13927735#ACGTTAGGTCAACTGT-1 -2.478552 -0.1776639 -1.1037295 -0.22976613 ## SRR13927735#AAATGCCCAGCAATGG-1 -2.595352 -0.3803464 -0.7770309 -0.52431765 ## LSI5 ## SRR13927735#TTATGTCTCCAGGTAT-1 -0.046845365 ## SRR13927735#TATTGCTCATCAGAAA-1 0.075746940 ## SRR13927735#TTCGATTGTAGGGTTG-1 0.019873276 ## SRR13927735#CATTCATTCGGATGTT-1 0.009947438 ## SRR13927735#ACGTTAGGTCAACTGT-1 -0.150097539 ## SRR13927735#AAATGCCCAGCAATGG-1 -0.243074591 head(getEmbedding(proj, embedding = &quot;UMAP_Combined&quot;)) ## iLSI_Combined#UMAP_Dimension_1 ## SRR13927735#TTATGTCTCCAGGTAT-1 -9.622903 ## SRR13927735#TATTGCTCATCAGAAA-1 -9.360211 ## SRR13927735#TTCGATTGTAGGGTTG-1 -8.617347 ## SRR13927735#CATTCATTCGGATGTT-1 -9.285448 ## SRR13927735#ACGTTAGGTCAACTGT-1 -8.809260 ## SRR13927735#AAATGCCCAGCAATGG-1 -9.261216 ## iLSI_Combined#UMAP_Dimension_2 ## SRR13927735#TTATGTCTCCAGGTAT-1 -0.2908237 ## SRR13927735#TATTGCTCATCAGAAA-1 -0.2892935 ## SRR13927735#TTCGATTGTAGGGTTG-1 -0.2154103 ## SRR13927735#CATTCATTCGGATGTT-1 -0.3267481 ## SRR13927735#ACGTTAGGTCAACTGT-1 -0.2168703 ## SRR13927735#AAATGCCCAGCAATGG-1 0.3200356 4.3 Retrieve matrices from ArchR project Retrieve gene expression and peak matrix from the ArchR project GeneExpressionMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;GeneIntegrationMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) ## 2023-11-21 05:17:54.20121 : Organizing colData, 1.392 mins elapsed. ## 2023-11-21 05:17:54.34076 : Organizing rowData, 1.394 mins elapsed. ## 2023-11-21 05:17:54.344242 : Organizing rowRanges, 1.394 mins elapsed. ## 2023-11-21 05:17:54.348954 : Organizing Assays (1 of 1), 1.394 mins elapsed. ## 2023-11-21 05:17:59.428454 : Constructing SummarizedExperiment, 1.479 mins elapsed. ## 2023-11-21 05:18:01.834963 : Finished Matrix Creation, 1.519 mins elapsed. PeakMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;PeakMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) ## 2023-11-21 05:18:49.472702 : Organizing colData, 0.794 mins elapsed. ## 2023-11-21 05:18:49.605343 : Organizing rowData, 0.796 mins elapsed. ## 2023-11-21 05:18:49.613608 : Organizing rowRanges, 0.796 mins elapsed. ## 2023-11-21 05:18:49.624204 : Organizing Assays (1 of 1), 0.796 mins elapsed. ## 2023-11-21 05:18:51.399922 : Constructing SummarizedExperiment, 0.826 mins elapsed. ## 2023-11-21 05:19:05.163928 : Finished Matrix Creation, 1.055 mins elapsed. If we extract the gene expression from matrix, it will be in the form of RangedSummarizedExperiment. We can make use of ArchRMatrix2SCE to convert gene expression matrix to SingleCellExperiment object. Its also important to note that gene expression from ArchR is library size normalized (not logged) library(epiregulon.archr) ## ## Attaching package: &#39;epiregulon.archr&#39; ## The following objects are masked from &#39;package:epiregulon&#39;: ## ## addMotifScore, addTFMotifInfo, calculateP2G, getTFMotifInfo GeneExpressionMatrix &lt;- ArchRMatrix2SCE(GeneExpressionMatrix) rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name We rename the assay name of the PeakMatrix as counts assayNames(PeakMatrix) &lt;- &quot;counts&quot; Transfer embeddings from ArchR project to singleCellExperiment for visualization reducedDim(GeneExpressionMatrix, &quot;UMAP_Combined&quot;) &lt;- getEmbedding(ArchRProj = proj, embedding = &quot;UMAP_Combined&quot;, returnDF = TRUE)[colnames(GeneExpressionMatrix),] # add cell label GeneExpressionMatrix$label &lt;- GeneExpressionMatrix$Cells GeneExpressionMatrix$label[GeneExpressionMatrix$Treatment == &quot;enzalutamide 48h&quot;] &lt;- &quot;LNCaPENZ48&quot; GeneExpressionMatrix$label &lt;- factor(GeneExpressionMatrix$label, levels = c(&quot;LNCaP&quot;, &quot;LNCaPENZ48&quot;, &quot;LNCaP RES-A&quot;, &quot;LNCaP RES-B&quot;)) Visualize singleCellExperiment by UMAP scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_Combined&quot;, text_by = &quot;label&quot;, colour_by = &quot;label&quot;) 4.4 Retrieve bulk TF ChIP-seq binding sites First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq. Currently, human genomes HG19 and HG38 and mouse mm10 are available. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache grl ## GRangesList object of length 1558: ## $`5-hmC` ## GRanges object with 24048 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 10000-10685 * ## [2] chr1 13362-13694 * ## [3] chr1 29631-29989 * ## [4] chr1 40454-40754 * ## [5] chr1 135395-135871 * ## ... ... ... ... ## [24044] chrY 56864377-56864627 * ## [24045] chrY 56876124-56876182 * ## [24046] chrM 84-2450 * ## [24047] chrM 13613-14955 * ## [24048] chrM 15134-16490 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 4.5 Link ATAC-seq peaks to target genes Next, we compute peak to gene correlations using the addPeak2GeneLinks function from the ArchR package. The user would need to supply a path to an ArchR project already containing peak and gene matrices, as well as Latent semantic indexing (LSI) dimensionality reduction. # path to ArchR project p2g &lt;- calculateP2G(ArchR_path = archR_project_path, useDim = &quot;iLSI_Combined&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, threads = 1) ## Setting ArchRLogging = FALSE ## Using ArchR to compute peak to gene links... ## 2023-11-21 05:19:21.857822 : Getting Available Matrices, 0 mins elapsed. ## 2023-11-21 05:19:22.359464 : Filtered Low Prediction Score Cells (0 of 15522, 0), 0.001 mins elapsed. ## 2023-11-21 05:19:22.718377 : Computing KNN, 0.007 mins elapsed. ## 2023-11-21 05:19:23.924613 : Identifying Non-Overlapping KNN pairs, 0.028 mins elapsed. ## 2023-11-21 05:19:26.34549 : Identified 497 Groupings!, 0.068 mins elapsed. ## 2023-11-21 05:19:26.402316 : Getting Group RNA Matrix, 0.069 mins elapsed. ## 2023-11-21 05:21:42.553781 : Getting Group ATAC Matrix, 2.338 mins elapsed. ## 2023-11-21 05:24:01.986998 : Normalizing Group Matrices, 4.662 mins elapsed. ## 2023-11-21 05:24:09.654548 : Finding Peak Gene Pairings, 4.79 mins elapsed. ## 2023-11-21 05:24:10.143878 : Computing Correlations, 4.798 mins elapsed. ## 2023-11-21 05:24:18.101173 : Completed Peak2Gene Correlations!, 4.931 mins elapsed. p2g ## DataFrame with 16883 rows and 8 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 15 chr1 912762 913262 7 NOC2L ## 2 25 chr1 920261 920761 7 NOC2L ## 3 25 chr1 920261 920761 8 KLHL17 ## 4 32 chr1 927728 928228 7 NOC2L ## 5 32 chr1 927728 928228 8 KLHL17 ## ... ... ... ... ... ... ... ## 16879 210643 chrX 154542721 154543221 23496 CH17-340M24.3 ## 16880 210643 chrX 154542721 154543221 23501 LAGE3 ## 16881 210643 chrX 154542721 154543221 23506 IKBKG ## 16882 210643 chrX 154542721 154543221 23509 DKC1 ## 16883 210665 chrX 154815200 154815700 23515 F8 ## Correlation distance ## &lt;numeric&gt; &lt;numeric&gt; ## 1 0.543478 46297 ## 2 0.602633 38798 ## 3 0.597510 40076 ## 4 0.660584 31331 ## 5 0.532240 32609 ## ... ... ... ## 16879 0.540888 114492 ## 16880 0.708942 63714 ## 16881 0.517261 1716 ## 16882 0.557412 219771 ## 16883 0.554537 211490 4.6 Add TF motif binding to peaks The next step is to add the TF motif binding information by overlapping the regions of the peak matrix with the bulk chip-seq database. The user can supply an archR project path and this function will retrieve the peak matrix, or a peakMatrix in the form of a Granges object or RangedSummarizedExperiment. overlap &lt;- addTFMotifInfo(archR_project_path = archR_project_path, grl = grl, p2g = p2g) ## Successfully loaded ArchRProject! ## Computing overlap... ## Success! 4.7 Generate regulons A long format data frame, representing the inferred regulons, is then generated. The data frame consists of three columns: tf (transcription factor) target gene peak to gene correlation between tf and target gene regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 2622030 rows and 10 columns ## idxATAC chr start end idxRNA target corr ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 15 chr1 912762 913262 7 NOC2L ## 2 15 chr1 912762 913262 7 NOC2L ## 3 15 chr1 912762 913262 7 NOC2L ## 4 15 chr1 912762 913262 7 NOC2L ## 5 15 chr1 912762 913262 7 NOC2L ## ... ... ... ... ... ... ... ... ## 2622026 210665 chrX 154815200 154815700 23515 F8 ## 2622027 210665 chrX 154815200 154815700 23515 F8 ## 2622028 210665 chrX 154815200 154815700 23515 F8 ## 2622029 210665 chrX 154815200 154815700 23515 F8 ## 2622030 210665 chrX 154815200 154815700 23515 F8 ## distance idxTF tf ## &lt;numeric&gt; &lt;integer&gt; &lt;character&gt; ## 1 46297 10 AGO1 ## 2 46297 22 AML1-ETO ## 3 46297 32 ARID4A ## 4 46297 33 ARID4B ## 5 46297 34 ARID5B ## ... ... ... ... ## 2622026 211490 1214 ZBTB8A ## 2622027 211490 1366 ZNF395 ## 2622028 211490 1443 ZNF589 ## 2622029 211490 1444 ZNF592 ## 2622030 211490 1463 ZNF639 4.8 (Optional) Annotate with TF motifs So far the gene regulatory network was constructed from TF ChIP-seq exclusively. Some users would prefer to further annotate the regulatory elements with the presence of motifs. If motif annotation has been previously performed by ArchR, addMotifScore can retrieve this annotation from the ArchR project. If motifs are available for a factor and the RE contains a motif, we return 1. If motifs are available and the RE does not contain a motif, we return 0. If no motifs are known for this particular factor (as in the case of co-factors or chromatin modifiers), we return NA. If the user has not performed motif annotation with ArchR, we can also annotate the peaks with motifs using the Cisbp database (default) or user-provided PWMS. See ?addMotifScore It is important to note that filtering for the presence of motifs removes a large fraction of the target genes. Motifs are often present in a small subset of the ChIP-seq peaks (can be as low as 10%). Second, indirect TF binding, possibly through its interaction partners, may have a true biological function. In this example, we continue with regulons containing the motifs, regulon.motif. However, if the user prefers to retain all target genes including REs without the motifs, they should proceed with regulon. regulon.motif &lt;- addMotifScore(regulon = regulon, ArchProj = proj ) ## retrieving motif information from ArchR project # retain only TF-RE-TG triplets with motifs regulon.motif &lt;- regulon.motif[which(regulon.motif$motif ==1),] 4.9 Prune network Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the active category is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section on differential networks. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon = regulon.motif, clusters = GeneExpressionMatrix$label, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05) 4.10 Add Weights While the `pruneRegulon function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the three measures: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, or 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Two measures (correlation and Wilcoxon) give both the magnitude and directionality of changes whereas mutational information is always positive. The correlation and mutual information statistics are computed on grouped pseudobulks by user-supplied cluster labels and yield a single weight across all clusters per each TF-RE-target triplet. In contrast, the Wilcoxon method group cells based on the joint expression of TF, RE and TG in each single cell or in cell aggregates. If cell labels are provided, we calculate cluster-specific weights in addition to estimating weights from all the cells. Cell aggregation uses a default value of 10 cells and can help overcome sparsity and speed up computation. If cluster labels are provided, we can obtain weights of individual clusters and all cells combined. In the case of drug treatment, however, the activity of TF is suppressed often not by downregulation of the TF gene expression, but by direct interference of the TF protein function. In this dataset, the drug enzalutamide blocks the ligand binding domain of the androgen receptor and prevents it from binding to the chromatin. As a result, while the AR gene expression stays the same, the chromatin accessibility of AR, as computed by chromVar in the ArchR package, is greatly reduced by 48 hour treatment of enzalutamide. First, we visualize the AR expression and show that enzalutamide does not decrease AR expression. library(epiregulon.extra) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix), tf = &quot;AR&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;gene expression&quot;) Then we extract the chromVarMatrix from ArchR project and then visualize the chromatin accessibility at AR bound sites. We can see that 48 hour of enzalutamide treatment reduced chromatin accessibility at AR bound sites chromVarMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;MotifMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1 ) ## 2023-11-21 05:26:07.264099 : Organizing colData, 0.169 mins elapsed. ## 2023-11-21 05:26:07.401596 : Organizing rowData, 0.172 mins elapsed. ## 2023-11-21 05:26:07.404436 : Organizing rowRanges, 0.172 mins elapsed. ## 2023-11-21 05:26:07.409135 : Organizing Assays (1 of 2), 0.172 mins elapsed. ## 2023-11-21 05:26:07.49188 : Organizing Assays (2 of 2), 0.173 mins elapsed. ## 2023-11-21 05:26:07.571595 : Constructing SummarizedExperiment, 0.174 mins elapsed. ## 2023-11-21 05:26:10.796527 : Finished Matrix Creation, 0.228 mins elapsed. plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(chromVarMatrix, &quot;z&quot;), tf = &quot;AR_689&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;chromVar&quot;) Next, we are going to compare 3 different weight methods. In the first method, the wilcoxon test compares target gene expression in cells meeting both the TF expression and accessibility cutoffs vs cells failing either the TF expression or/and accessibility cutoffs. Next, we try out the correlation method which comes in two flavors. When tf_re.merge = FALSE, weight is computed on the correlation of target gene expression vs TF gene expression. When tf_re.merge = TRUE, weight is computed on the correlation of target gene expression vs the product of TF expression and chromatin accessibility at TF-bound regulatory elements. regulon.w.wilcox &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;wilcoxon&quot;) ## adding weights using wilcoxon... regulon.w.corr &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;) ## adding weights using corr... ## calculating average expression across clusters... ## computing weights... regulon.w.corr.re &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;, tf_re.merge = TRUE) ## adding weights using corr... ## calculating average expression across clusters... ## computing weights... 4.11 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging the weighted expressions of target genes linked to the TF. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weight_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,,n} \\(weight_i\\) is the weight of TF and target i We calculate three different activities corresponding to the different weighted regulons score.combine.wilcox &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, regulon = regulon.w.wilcox, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## calculating TF activity from regulon using weightedmean ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = ## &quot;counts&quot;, : The weight column contains multiple subcolumns but no cluster ## information was provided. Using first column to compute activity... ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... score.combine.corr &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, regulon = regulon.w.corr, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## calculating TF activity from regulon using weightedmean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... score.combine.corr.re &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, regulon = regulon.w.corr.re, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## calculating TF activity from regulon using weightedmean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... We visualize the different activities side by side. library(epiregulon.extra) plotActivityViolin(activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by wilcoxon&quot;) plotActivityViolin(activity_matrix = score.combine.corr, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF vs TG&quot;) plotActivityViolin(activity_matrix = score.combine.corr.re, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF*RE vs TG&quot;) In this case, activity calculated from correlation based on TF and TG expression is clearly wrong because we see increased AR activity after Enzalutamide treatment despite it being an AR antagonist. Therefore, for drug treatment which often decouples TF gene expression and its activity, it is important to take into consideration both TF gene expression and RE chromatin accessibility; the latter may be a better indicator of TF function if the TF has an effect on the chromatin accessibility. In this case, the recommended methods are either wilcox or corr with tf_re.merge = TRUE. The astute users could however detect a difference in the prediction of the AR activity in the resistant clones RES-A and RES-B with respect to the parental LNCaP between the two methods. For example, the corr with tf_re.merge = TRUE shows increased AR activity in RES-B compared to LNCaP because RES-B shows increased AR expression. In contrast, the wilcoxon method did not predict an increase in AR activity in RES-B because RES-B still shows reduced chromatin accessibility compared to LNCaP. Since wilcoxon takes into account the co-occurrence of both TF gene expression and RE chromatin accessibility, this method does not predict an overall increase in AR activity. In the absence of the ground truth, it is difficult to judge which method is superior. Therefore, it is always crucial to validate key findings with additional empirical evidence. The most important disclaimer we wish to make is that all predictions by epiregulon should be robustly tested experimentally. 4.12 Perform differential activity For the remaining steps, we continue with activity derived from the wilcoxon method. markers &lt;- findDifferentialActivity(activity_matrix = score.combine.wilcox, clusters = GeneExpressionMatrix$label, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) Take the top differential TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) ## Using a logFC cutoff of 0 for class LNCaP ## Using a logFC cutoff of 0 for class LNCaP&lt;U+2013&gt;ENZ48 ## Using a logFC cutoff of 0 for class LNCaP RES-A ## Using a logFC cutoff of 0 for class LNCaP RES-B 4.13 Visualize the results First visualize the known differential TFs by bubble plot plotBubble(activity_matrix = score.combine.wilcox, tf = c(&quot;AR&quot;,&quot;FOXA1&quot;, &quot;MYC&quot;,&quot;JUN&quot;), clusters = GeneExpressionMatrix$label) Then visualize the most differential TFs by clusters plotBubble(activity_matrix = score.combine.wilcox, tf = markers.sig$tf, clusters = GeneExpressionMatrix$label) Visualize the known differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize the newly discovered differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = c(&quot;SPDEF&quot;,&quot;HES4&quot;,&quot;ATF5&quot;,&quot;NR2F2&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize regulons by heatmap rowData(GeneExpressionMatrix) &lt;- NULL plotHeatmapRegulon(sce=GeneExpressionMatrix, tfs= c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon=regulon.w.wilcox, regulon_cutoff=0.1, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;counts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) plotHeatmapActivity(activity=score.combine.wilcox, sce=GeneExpressionMatrix, tfs=rownames(score.combine.wilcox), downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name = &quot;transcription factor activity&quot;, column_title_rot = 45) ## Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H,C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = c(&quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## AR ## FOXA1 ## MYC ## JUN #plot results enrichPlot(results = enrichresults, ncol = 2) We can visualize the genesets of known factors as a network plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) We can visualize the genesets of differential factors as a network enrichresults &lt;- regulonEnrich(TF = markers.sig$tf, regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## HES4 ## SPDEF ## NKX3-1 ## FOXP1 ## NFIB ## HES4 ## SPDEF ## NFYB ## NFIB ## CREB1 ## ATF5 ## BPTF ## SREBF1 ## JUN ## REST ## JUN ## NR2F2 ## SMARCC1 ## NR2F6 ## ATF5 plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) 4.14 Differential network analysis In addition to looking at the summed TF activity, a second approach to investigate differential TF activity is to compare and contrast target genes or network topology. In this example, we know that AR is downregulated in the Enzalutamide treated cells compared to parental LNCaP. plotDiffNetwork(regulon.w.wilcox, cutoff = 0, tf = c(&quot;AR&quot;), weight = &quot;weight&quot;, clusters = c(&quot;LNCaP&quot;,&quot;LNCaPENZ48&quot;), layout = &quot;stress&quot;) ## Building graph using weight as edge weights We perform edge subtracted graph between two conditions and rank TFs by degree centrality. In this example, positive centrality indicates higher activity in parental LNCaP and negative centrality indicates higher activity in Enzalutamide treated cells. # construct a graph of the parental and enzalutamide treated cells respectively LNCaP_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaP&quot;) ## Building graph using weight as edge weights ENZ_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaPENZ48&quot;) ## Building graph using weight as edge weights # construct a difference graph diff_graph &lt;- buildDiffGraph(LNCaP_network, ENZ_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table,5), tail(rank_table,5)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5) + theme_classic() + ggtitle (&quot;differential TFs (LNCaP-ENZ) ranked by degree centrality&quot;) Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of the targets genes for all the TFs and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to AR. library(igraph) diff_graph_filter &lt;- subgraph.edges(diff_graph, E(diff_graph)[E(diff_graph)$weight&gt;0], del=TRUE) # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(diff_graph_filter) # Focus on AR similarity_score_AR &lt;- similarity_score[, &quot;AR&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_AR, decreasing = TRUE),20), TF = names(head(sort(similarity_score_AR, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to SPI1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;AR similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(diff_graph_filter, &quot;AR&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_AR),] diff_matrix &lt;- similarity_score_AR-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to AR topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted AR similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_AR})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## JUND MYC FOXA1 HOXB13 NFIC CEBPB MAZ XBP1 CEBPG GATA2 REST ## 0.00 0.02 0.02 0.00 0.00 0.00 0.00 0.01 0.00 0.02 0.02 ## CTCF FOXP1 ZNF148 ATF4 NFIB NFIX EHF ETV1 NFE2L2 ## 0.02 0.02 0.00 0.01 0.00 0.02 0.01 0.00 0.01 4.15 Session Info sessionInfo() ## R version 4.3.0 (2023-04-21) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/local/lib/R/lib/libRblas.so ## LAPACK: /usr/local/lib/R/lib/libRlapack.so; LAPACK version 3.11.0 ## ## locale: ## [1] LC_CTYPE=C LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] grid stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] nabor_0.5.0 epiregulon.archr_0.99.0 ## [3] rhdf5_2.45.1 RcppArmadillo_0.12.6.4.0 ## [5] Rcpp_1.0.11 Matrix_1.6-3 ## [7] sparseMatrixStats_1.13.4 data.table_1.14.8 ## [9] stringr_1.5.0 plyr_1.8.9 ## [11] magrittr_2.0.3 gtable_0.3.4 ## [13] gtools_3.9.4 gridExtra_2.3 ## [15] devtools_2.4.5 usethis_2.1.6 ## [17] ArchR_1.0.3 igraph_1.5.1 ## [19] ggplot2_3.4.4 org.Hs.eg.db_3.18.0 ## [21] AnnotationDbi_1.63.2 msigdbr_7.5.1 ## [23] epiregulon.extra_0.99.0 BSgenome.Hsapiens.UCSC.hg38_1.4.5 ## [25] BSgenome_1.69.1 rtracklayer_1.61.2 ## [27] BiocIO_1.11.0 Biostrings_2.69.2 ## [29] XVector_0.41.2 DelayedArray_0.27.10 ## [31] epiregulon_1.0.36 HDF5Array_1.29.3 ## [33] scMultiome_1.1.2 SingleCellExperiment_1.23.0 ## [35] MultiAssayExperiment_1.27.5 SummarizedExperiment_1.31.1 ## [37] Biobase_2.61.0 GenomicRanges_1.53.3 ## [39] GenomeInfoDb_1.37.7 IRanges_2.35.3 ## [41] S4Vectors_0.39.3 MatrixGenerics_1.13.2 ## [43] matrixStats_1.0.0 ExperimentHub_2.9.1 ## [45] AnnotationHub_3.9.2 BiocFileCache_2.9.1 ## [47] dbplyr_2.3.4 BiocGenerics_0.47.1 ## ## loaded via a namespace (and not attached): ## [1] R.methodsS3_1.8.2 GSEABase_1.63.0 ## [3] urlchecker_1.0.1 poweRlaw_0.70.6 ## [5] vctrs_0.6.3 digest_0.6.31 ## [7] png_0.1-8 shape_1.4.6 ## [9] ggrepel_0.9.4 magick_2.8.1 ## [11] MASS_7.3-60 reshape2_1.4.4 ## [13] httpuv_1.6.11 foreach_1.5.2 ## [15] qvalue_2.33.0 withr_2.5.0 ## [17] ggrastr_1.0.2 xfun_0.39 ## [19] ggfun_0.1.3 ellipsis_0.3.2 ## [21] memoise_2.0.1 ggbeeswarm_0.7.2 ## [23] clusterProfiler_4.9.5 gson_0.1.0 ## [25] profvis_0.3.8 tidytree_0.4.5 ## [27] GlobalOptions_0.1.2 KEGGgraph_1.61.0 ## [29] R.oo_1.25.0 prettyunits_1.1.1 ## [31] KEGGREST_1.41.4 promises_1.2.0.1 ## [33] httr_1.4.6 restfulr_0.0.15 ## [35] rhdf5filters_1.13.5 ps_1.7.5 ## [37] rstudioapi_0.15.0 miniUI_0.1.1.1 ## [39] generics_0.1.3 DOSE_3.27.3 ## [41] processx_3.8.1 babelgene_22.9 ## [43] curl_5.0.0 zlibbioc_1.47.0 ## [45] ScaledMatrix_1.9.1 ggraph_2.1.0 ## [47] polyclip_1.10-6 GenomeInfoDbData_1.2.11 ## [49] SparseArray_1.1.12 interactiveDisplayBase_1.39.0 ## [51] xtable_1.8-4 pracma_2.4.2 ## [53] doParallel_1.0.17 evaluate_0.21 ## [55] S4Arrays_1.1.6 hms_1.1.3 ## [57] bookdown_0.36 irlba_2.3.5.1 ## [59] colorspace_2.1-0 filelock_1.0.2 ## [61] readr_2.1.4 Rgraphviz_2.45.0 ## [63] later_1.3.1 viridis_0.6.4 ## [65] ggtree_3.9.1 lattice_0.22-5 ## [67] XML_3.99-0.14 scuttle_1.11.3 ## [69] shadowtext_0.1.2 cowplot_1.1.1 ## [71] pillar_1.9.0 nlme_3.1-163 ## [73] iterators_1.0.14 caTools_1.18.2 ## [75] compiler_4.3.0 beachmat_2.17.17 ## [77] stringi_1.7.12 GenomicAlignments_1.37.0 ## [79] MPO.db_0.99.7 crayon_1.5.2 ## [81] abind_1.4-5 scater_1.29.4 ## [83] gridGraphics_0.5-1 locfit_1.5-9.8 ## [85] graphlayouts_1.0.1 bit_4.0.5 ## [87] dplyr_1.1.3 fastmatch_1.1-4 ## [89] codetools_0.2-19 BiocSingular_1.17.1 ## [91] bslib_0.5.1 GetoptLong_1.0.5 ## [93] mime_0.12 splines_4.3.0 ## [95] circlize_0.4.15 HDO.db_0.99.1 ## [97] EnrichmentBrowser_2.31.5 knitr_1.44 ## [99] blob_1.2.4 utf8_1.2.3 ## [101] clue_0.3-65 BiocVersion_3.18.0 ## [103] seqLogo_1.67.0 fs_1.6.2 ## [105] checkmate_2.2.0 DelayedMatrixStats_1.23.9 ## [107] pkgbuild_1.4.0 ggplotify_0.1.2 ## [109] tibble_3.2.1 callr_3.7.3 ## [111] statmod_1.5.0 tzdb_0.4.0 ## [113] tweenr_2.0.2 pkgconfig_2.0.3 ## [115] tools_4.3.0 cachem_1.0.8 ## [117] RSQLite_2.3.1 viridisLite_0.4.2 ## [119] DBI_1.1.3 fastmap_1.1.1 ## [121] rmarkdown_2.25 scales_1.2.1 ## [123] Rsamtools_2.17.0 sass_0.4.6 ## [125] patchwork_1.1.3 BiocManager_1.30.22 ## [127] graph_1.79.4 farver_2.1.1 ## [129] tidygraph_1.2.3 scatterpie_0.2.1 ## [131] yaml_2.3.7 cli_3.6.1 ## [133] purrr_1.0.2 motifmatchr_1.23.0 ## [135] lifecycle_1.0.3 bluster_1.11.4 ## [137] sessioninfo_1.2.2 backports_1.4.1 ## [139] BiocParallel_1.35.4 annotate_1.79.0 ## [141] rjson_0.2.21 parallel_4.3.0 ## [143] ape_5.7-1 limma_3.57.11 ## [145] jsonlite_1.8.7 edgeR_3.99.6 ## [147] TFBSTools_1.40.0 bitops_1.0-7 ## [149] HPO.db_0.99.2 bit64_4.0.5 ## [151] yulab.utils_0.1.0 BiocNeighbors_1.19.0 ## [153] CNEr_1.37.0 jquerylib_0.1.4 ## [155] metapod_1.9.0 GOSemSim_2.27.3 ## [157] dqrng_0.3.1 R.utils_2.12.2 ## [159] lazyeval_0.2.2 shiny_1.7.5.1 ## [161] htmltools_0.5.5 enrichplot_1.21.3 ## [163] GO.db_3.18.0 rappdirs_0.3.3 ## [165] glue_1.6.2 TFMPvalue_0.0.9 ## [167] RCurl_1.98-1.12 treeio_1.25.4 ## [169] scran_1.29.3 R6_2.5.1 ## [171] tidyr_1.3.0 labeling_0.4.3 ## [173] cluster_2.1.4 pkgload_1.3.2 ## [175] Rhdf5lib_1.23.2 aplot_0.2.2 ## [177] DirichletMultinomial_1.43.0 tidyselect_1.2.0 ## [179] vipor_0.4.5 ggforce_0.4.1 ## [181] rsvd_1.0.5 munsell_0.5.0 ## [183] BiocStyle_2.29.2 htmlwidgets_1.6.2 ## [185] fgsea_1.27.1 ComplexHeatmap_2.17.0 ## [187] RColorBrewer_1.1-3 rlang_1.1.1 ## [189] remotes_2.4.2 fansi_1.0.4 ## [191] Cairo_1.6-1 beeswarm_0.4.0 "],["single-modality-scrna-seq-only.html", "5 Single modality: scRNA-seq only 5.1 Load regulon 5.2 Load scRNA-seq data 5.3 Calculate activity 5.4 Perform differential activity 5.5 Visualize activity 5.6 Pathway enrichment 5.7 Session Info", " 5 Single modality: scRNA-seq only Epiregulon also supports transcription factor activity inference when users only have scRNA-seq. After all, multiome or scATAC-seq data is still relatively rare. To enable TF activity inference on scRNA-seq, users can supply a pre-constructed gene regulatory network. Dorothea provides both human and mouse pre-constructed gene regulatory networks based on curated experimental and computational data. In this vignette, we bypass the regulon construction step and go straight to calculate TF activity from a Dorothea GRN. 5.1 Load regulon Dorothea assigns confidence level to its regulons with A being the most confident (i.e.supported by multiple lines of evidence) and E being the least confident. library(dorothea) data(dorothea_mm, package = &quot;dorothea&quot;) regulon &lt;- dorothea_mm #known tfs genes_to_plot &lt;- c(&quot;Foxa1&quot;, &quot;Neurod1&quot;,&quot;Pdx1&quot;,&quot;Arx&quot;) 5.2 Load scRNA-seq data We download the raw counts of a mouse pancreas data set from scRNAseq. We add normalized logcounts, perform dimension reduction and visualize the embeddings using scater. library(scRNAseq) library(scater) sce &lt;- BaronPancreasData(&#39;mouse&#39;) sce &lt;- logNormCounts(sce) sce &lt;- runPCA(sce) sce &lt;- runUMAP(sce) plotUMAP(sce, colour_by = &quot;label&quot;, text_by = &quot;label&quot;) 5.3 Calculate activity Even though Dorothea provides weights under the mor column, we can achieve superior performance if we recompute the weights based on the correlation between tf and target gene expression based on our own data. We performed 2 steps, the first step is to add weights to the Dorothea regulons and the second step is to estimate the TF activity by taking the weighted average of the target gene expression. library(epiregulon) #Add weights to regulon. Default method (wilcoxon) cannot be used regulon.ms &lt;- addWeights(regulon = regulon, expMatrix = sce, clusters = sce$label, BPPARAM = BiocParallel::MulticoreParam(), method=&quot;corr&quot;) #Calculate activity score.combine &lt;- calculateActivity(sce, regulon = regulon.ms, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) 5.4 Perform differential activity library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = sce$label, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) Take the top TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) 5.5 Visualize activity Finally we visualize the TF activity by either UMAP, violin plots or bubble plots. We confirm the activity of known lineage factors Pdx1 and Neurod1 in beta cells, Arx in alpha cells and Foxa1 in ductal cells. # plot umap plotActivityDim(sce = sce, activity_matrix = score.combine, tf = genes_to_plot, legend.label = &quot;score&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2) # plot violin plot plotActivityViolin(score.combine, tf = genes_to_plot, clusters = sce$label) # plot bubble plot plotBubble(score.combine, tf = genes_to_plot, clusters = sce$label) Plot bubble plot of differential TFs plotBubble(score.combine, tf = markers.sig$tf, clusters = sce$label) We can adapt the epiregulon package to plot gene expression. When compared against TF activity, gene expression of Foxa1 and Arx has noisy signals and high dropout rates. Epiregulon enhances the signal to noise ratio of TF activity and better resolves lineage differences. # plot umap plotActivityDim(sce = sce, activity_matrix = logcounts(sce), tf = genes_to_plot, legend.label = &quot;gex&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2, colors = c(&quot;gray&quot;,&quot;blue&quot;), limit = c(0,2)) # plot violin plot plotActivityViolin(logcounts(sce), tf = genes_to_plot, clusters = sce$label, legend.label = &quot;gex&quot;) # plot Bubble plot plotBubble(logcounts(sce), tf = markers.sig$tf, clusters = sce$label, legend.label = &quot;gex&quot;) We can visualize the target genes for transcription factors of interest plotHeatmapRegulon(sce=sce, tfs=genes_to_plot, regulon=regulon.ms, regulon_cutoff=0.5, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;logcounts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) plotHeatmapActivity(activity_matrix = score.combine, sce=sce, tfs=genes_to_plot, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) 5.6 Pathway enrichment Sometimes it is useful to understand what pathways are enriched in the regulons. We take the highly correlated target genes of a regulon and perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H,C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs = x, genes = gs[[x]])})) enrichresults &lt;- regulonEnrich(genes_to_plot, regulon = regulon.ms, weight = &quot;weight&quot;, weight_cutoff = 0.5, genesets = gs.list) ## Foxa1 ## Neurod1 ## Pdx1 ## Arx #plot results enrichPlot(results = enrichresults, ncol = 1) 5.7 Session Info sessionInfo() ## R version 4.3.0 (2023-04-21) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/local/lib/R/lib/libRblas.so ## LAPACK: /usr/local/lib/R/lib/libRlapack.so; LAPACK version 3.11.0 ## ## locale: ## [1] LC_CTYPE=C LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] grid stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] org.Mm.eg.db_3.18.0 scater_1.29.4 ## [3] scuttle_1.11.3 scRNAseq_2.15.0 ## [5] dorothea_1.13.0 nabor_0.5.0 ## [7] epiregulon.archr_0.99.0 rhdf5_2.45.1 ## [9] RcppArmadillo_0.12.6.4.0 Rcpp_1.0.11 ## [11] Matrix_1.6-3 sparseMatrixStats_1.13.4 ## [13] data.table_1.14.8 stringr_1.5.0 ## [15] plyr_1.8.9 magrittr_2.0.3 ## [17] gtable_0.3.4 gtools_3.9.4 ## [19] gridExtra_2.3 devtools_2.4.5 ## [21] usethis_2.1.6 ArchR_1.0.3 ## [23] igraph_1.5.1 ggplot2_3.4.4 ## [25] org.Hs.eg.db_3.18.0 AnnotationDbi_1.63.2 ## [27] msigdbr_7.5.1 epiregulon.extra_0.99.0 ## [29] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.69.1 ## [31] rtracklayer_1.61.2 BiocIO_1.11.0 ## [33] Biostrings_2.69.2 XVector_0.41.2 ## [35] DelayedArray_0.27.10 epiregulon_1.0.36 ## [37] HDF5Array_1.29.3 scMultiome_1.1.2 ## [39] SingleCellExperiment_1.23.0 MultiAssayExperiment_1.27.5 ## [41] SummarizedExperiment_1.31.1 Biobase_2.61.0 ## [43] GenomicRanges_1.53.3 GenomeInfoDb_1.37.7 ## [45] IRanges_2.35.3 S4Vectors_0.39.3 ## [47] MatrixGenerics_1.13.2 matrixStats_1.0.0 ## [49] ExperimentHub_2.9.1 AnnotationHub_3.9.2 ## [51] BiocFileCache_2.9.1 dbplyr_2.3.4 ## [53] BiocGenerics_0.47.1 ## ## loaded via a namespace (and not attached): ## [1] R.methodsS3_1.8.2 GSEABase_1.63.0 ## [3] progress_1.2.2 urlchecker_1.0.1 ## [5] poweRlaw_0.70.6 vctrs_0.6.3 ## [7] digest_0.6.31 png_0.1-8 ## [9] shape_1.4.6 ggrepel_0.9.4 ## [11] bcellViper_1.37.0 magick_2.8.1 ## [13] MASS_7.3-60 reshape2_1.4.4 ## [15] httpuv_1.6.11 foreach_1.5.2 ## [17] qvalue_2.33.0 withr_2.5.0 ## [19] ggrastr_1.0.2 xfun_0.39 ## [21] ggfun_0.1.3 ellipsis_0.3.2 ## [23] memoise_2.0.1 ggbeeswarm_0.7.2 ## [25] clusterProfiler_4.9.5 gson_0.1.0 ## [27] profvis_0.3.8 tidytree_0.4.5 ## [29] GlobalOptions_0.1.2 KEGGgraph_1.61.0 ## [31] R.oo_1.25.0 prettyunits_1.1.1 ## [33] KEGGREST_1.41.4 promises_1.2.0.1 ## [35] httr_1.4.6 restfulr_0.0.15 ## [37] rhdf5filters_1.13.5 ps_1.7.5 ## [39] rstudioapi_0.15.0 miniUI_0.1.1.1 ## [41] generics_0.1.3 DOSE_3.27.3 ## [43] processx_3.8.1 babelgene_22.9 ## [45] curl_5.0.0 zlibbioc_1.47.0 ## [47] ScaledMatrix_1.9.1 ggraph_2.1.0 ## [49] polyclip_1.10-6 GenomeInfoDbData_1.2.11 ## [51] SparseArray_1.1.12 interactiveDisplayBase_1.39.0 ## [53] xtable_1.8-4 pracma_2.4.2 ## [55] doParallel_1.0.17 evaluate_0.21 ## [57] S4Arrays_1.1.6 hms_1.1.3 ## [59] bookdown_0.36 irlba_2.3.5.1 ## [61] colorspace_2.1-0 filelock_1.0.2 ## [63] readr_2.1.4 Rgraphviz_2.45.0 ## [65] later_1.3.1 viridis_0.6.4 ## [67] ggtree_3.9.1 lattice_0.22-5 ## [69] XML_3.99-0.14 shadowtext_0.1.2 ## [71] cowplot_1.1.1 pillar_1.9.0 ## [73] nlme_3.1-163 iterators_1.0.14 ## [75] caTools_1.18.2 compiler_4.3.0 ## [77] beachmat_2.17.17 stringi_1.7.12 ## [79] GenomicAlignments_1.37.0 MPO.db_0.99.7 ## [81] crayon_1.5.2 abind_1.4-5 ## [83] gridGraphics_0.5-1 locfit_1.5-9.8 ## [85] graphlayouts_1.0.1 bit_4.0.5 ## [87] dplyr_1.1.3 fastmatch_1.1-4 ## [89] codetools_0.2-19 BiocSingular_1.17.1 ## [91] bslib_0.5.1 GetoptLong_1.0.5 ## [93] mime_0.12 splines_4.3.0 ## [95] circlize_0.4.15 HDO.db_0.99.1 ## [97] EnrichmentBrowser_2.31.5 knitr_1.44 ## [99] blob_1.2.4 utf8_1.2.3 ## [101] clue_0.3-65 BiocVersion_3.18.0 ## [103] seqLogo_1.67.0 AnnotationFilter_1.25.0 ## [105] fs_1.6.2 checkmate_2.2.0 ## [107] DelayedMatrixStats_1.23.9 pkgbuild_1.4.0 ## [109] ggplotify_0.1.2 tibble_3.2.1 ## [111] callr_3.7.3 statmod_1.5.0 ## [113] tzdb_0.4.0 tweenr_2.0.2 ## [115] pkgconfig_2.0.3 tools_4.3.0 ## [117] cachem_1.0.8 RSQLite_2.3.1 ## [119] viridisLite_0.4.2 DBI_1.1.3 ## [121] fastmap_1.1.1 rmarkdown_2.25 ## [123] scales_1.2.1 Rsamtools_2.17.0 ## [125] sass_0.4.6 FNN_1.1.3.2 ## [127] patchwork_1.1.3 BiocManager_1.30.22 ## [129] graph_1.79.4 farver_2.1.1 ## [131] tidygraph_1.2.3 scatterpie_0.2.1 ## [133] yaml_2.3.7 cli_3.6.1 ## [135] purrr_1.0.2 motifmatchr_1.23.0 ## [137] lifecycle_1.0.3 uwot_0.1.16 ## [139] bluster_1.11.4 sessioninfo_1.2.2 ## [141] backports_1.4.1 BiocParallel_1.35.4 ## [143] annotate_1.79.0 rjson_0.2.21 ## [145] parallel_4.3.0 ape_5.7-1 ## [147] limma_3.57.11 jsonlite_1.8.7 ## [149] edgeR_3.99.6 TFBSTools_1.40.0 ## [151] bitops_1.0-7 HPO.db_0.99.2 ## [153] bit64_4.0.5 yulab.utils_0.1.0 ## [155] BiocNeighbors_1.19.0 CNEr_1.37.0 ## [157] jquerylib_0.1.4 metapod_1.9.0 ## [159] GOSemSim_2.27.3 dqrng_0.3.1 ## [161] R.utils_2.12.2 lazyeval_0.2.2 ## [163] shiny_1.7.5.1 htmltools_0.5.5 ## [165] enrichplot_1.21.3 GO.db_3.18.0 ## [167] rappdirs_0.3.3 ensembldb_2.25.1 ## [169] glue_1.6.2 TFMPvalue_0.0.9 ## [171] RCurl_1.98-1.12 treeio_1.25.4 ## [173] scran_1.29.3 R6_2.5.1 ## [175] tidyr_1.3.0 labeling_0.4.3 ## [177] GenomicFeatures_1.53.3 cluster_2.1.4 ## [179] pkgload_1.3.2 Rhdf5lib_1.23.2 ## [181] aplot_0.2.2 DirichletMultinomial_1.43.0 ## [183] ProtGenerics_1.33.1 tidyselect_1.2.0 ## [185] vipor_0.4.5 xml2_1.3.5 ## [187] ggforce_0.4.1 rsvd_1.0.5 ## [189] munsell_0.5.0 BiocStyle_2.29.2 ## [191] htmlwidgets_1.6.2 fgsea_1.27.1 ## [193] ComplexHeatmap_2.17.0 RColorBrewer_1.1-3 ## [195] biomaRt_2.57.1 rlang_1.1.1 ## [197] remotes_2.4.2 fansi_1.0.4 ## [199] Cairo_1.6-1 beeswarm_0.4.0 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
