[["index.html", "Epiregulon documentation Introduction", " Epiregulon documentation Xiaosai Yao, Tomasz Włodarczyk 2025-12-12 Introduction Gene regulatory networks model the underlying gene regulation hierarchies that drive gene expression and cell states. The main function of the epiregulon package is to construct gene regulatory networks and infer transcription factor (TF) activity in single cells by integration of scATAC-seq and scRNA-seq data and incorporation of public bulk TF ChIP-seq data. Epiregulon assigns regulatory elements (REs) to their putative target genes (TGs) if the chromatin accessibility and gene expressions are highly correlated across cell clusters. Each regulatory element is then interrogated for TF occupancy based on a compilation of public TF ChIP-seq binding sites from ChIP-Atlas and ENCODE TF ChIP-seq data. This maps out the preliminary TF-RE-TG regulatory relationships. Further pruning of the gene regulatory network is necessary to remove spurious gene regulatory relationships not supported by the data, especially because the public ChIP-seq data was most certainly obtained in different cell lines or treatment conditions. In this case, we want to identify the most likely TF-RE-TG triplets. Here we apply tests of independence (binomial or chi-square tests) which identify TF-RE-TG triplets jointly occurring at probabilities deviating from the expected probabilities if these three events occur independently. In other words, we assume that a TF-RE-TG regulatory relationship holds true if expression of the TG, chromatin accessibility at RE and expression of the TG tend to co-exist in the same cells. While we recognize that there could be time delays between chromatin accessibility and the expression of target genes in true RE-TG relationships, we want to be conservative in our inference and rule out unsubstantiated TF-RE-TG relationships. After network pruning, we would like to further estimate the strength of regulation. This can be achieved using one of the three methods: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, and 3) effect size of the Wilcoxon test between target gene expression in cells jointly expressing all 3 elements vs cells that do not. The activity of transcription factor is the weighted sum of all its target genes in which the weights correspond to the strength of regulation. The target genes of TFs can be queried against known pathways to predict the functions of TFs. We can also perform differential TF activity using two approaches: 1) differential total activity or 2) differential network topology. The first approach compares differences in the sum of the target genes. The second approach involves edge subtraction between two networks and the TFs are ranked by the degree centrality of the differential graphs. Epiregulon also allows identification of interaction partners by the degree of overlaps in the target genes between two TFs. Current prerequisites for running epiregulon include pre-computed peak matrix, gene expression matrix and dimensionality reduction. Epiregulon offers seamless integration with ArchR. Alternately, users can analyze their data using their favorite analysis tools and package their matrices into MultiAssayExperiment (See scMultiome package). The scATAC-seq experiment can be either paired or unpaired with the scRNA-seq dataset as long as they were already integrated. The final output of epiregulon is a matrix of TF activities where rows are individual TFs and columns are single cell indexes. This documentation presents epiregulon v2. Review NEWS file to learn about the changes introduced with the version 2. Check out our publication: Włodarczyk T, Lun A, Wu D, Shi M, Ye X, Menon S, Toneyan S, Seidel K, Wang L, Tan J, Chen S-Y, Keyes T, Chlebowski A, Waddell A, Zhou W, Wang Y, Yuan Q, Guo Y, Chen L-F, Daniel B, Hafner A, He M, Chibly A, Liang Y, Duren Z, Metcalfe C, Hafner M, Siebel C, Corces M. R, Yauch R, Xie S, Yao X (2025) Epiregulon: Single-cell transcription factor activity inference to predict drug response and drivers of cell states. Nature Communications 16: 7118. doi:10.1038/s41467-025-62252-5 "],["installation.html", "1 Installation 1.1 Install from GitHub 1.2 Install from Bioconductor", " 1 Installation 1.1 Install from GitHub All the epiregulon components are available on GitHub. There are three separate epiregulon packages. The core epiregulon package supports input in the form of SingleCellExperiment objects. If the users would like to start from ArchR projects, they may choose to use epiregulon.archr package, which allows for the seamless integration with ArchR package through accepting its output to be used in the downstream workflow. # install devtools if(!require(devtools)) install.packages(&quot;devtools&quot;) # install basic epiregulon package devtools::install_github(repo=&#39;xiaosaiyao/epiregulon&#39;) # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.archr&#39;) Moreover, we provide a suite of tools for the enrichment analysis, visualization, and network analysis which can be run on the epireglon or epiregulon.archr output. # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.extra&#39;) The data package scMultiome is for storing TF ChIP-seq data and pre-processed datasets. # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/scMultiome&#39;) 1.2 Install from Bioconductor Epiregulon is now available through Bioconductor. if (!require(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;epiregulon&quot;) BiocManager::install(&quot;epiregulon.extra&quot;) BiocManager::install(&quot;scMultiome&quot;) "],["quick-start.html", "2 Quick start 2.1 Prepare data 2.2 Retrieve bulk TF ChIP-seq binding sites 2.3 Link ATAC-seq peaks to target genes 2.4 Add TF motif binding to peaks 2.5 Generate regulons 2.6 Prune network (recommended) 2.7 Annotate regulon 2.8 Calculate TF activity", " 2 Quick start In this chapter, we illustrate the epiregulon workflow, using the PBMC dataset which can be downloaded from the scMultiome package. 2.1 Prepare data Prior to using epiregulon, single cell preprocessing needs to be performed by user’s favorite methods. The following components are required: 1. Peak matrix from scATAC-seq containing the chromatin accessibility information 2. Gene expression matrix from either paired or unpaired scRNA-seq. RNA-seq integration needs to be performed for unpaired dataset. 3. Dimensionality reduction matrix from with either single modalities or joint scRNA-seq and scATAC-seq # load the MAE object library(scMultiome) library(epiregulon) # Download the example dataset mae &lt;- scMultiome::PBMC_10x() # Load peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # Load expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] Visualize singleCellExperiment by UMAP scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_RNA&quot;, text_by = &quot;cell_type&quot;, colour_by = &quot;cell_type&quot;, point_size = 0.3, point_alpha = 0.3) 2.2 Retrieve bulk TF ChIP-seq binding sites First, we retrieve a GRangesList object containing the binding sites of all the transcription factors and co-regulators. These binding sites are derived from bulk ChIP-seq data in the ChIP-Atlas and ENCODE databases. For the same transcription factor, multiple ChIP-seq files from different cell lines or tissues are merged. For further information on how these peaks are derived, please refer to ?epiregulon::getTFMotifInfo. Currently, human genomes hg19 and hg38 and mouse mm10 are supported. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) grl ## GRangesList object of length 1377: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1376 more elements&gt; 2.3 Link ATAC-seq peaks to target genes Next, we try to link ATAC-seq peaks to their putative target genes. We assign a peak to a gene within a size window (default ±250kb) if the chromatin accessibility of the peak and expression of the target genes are highly correlated (default threshold 0.5). To compute correlations, we first create cell aggregates by performing k-means clustering on the reduced dimensionality matrix. To estimate the optimal number of cells per cluster we will run the function optimizeMetacellNumber. set.seed(1010) cellNum &lt;- optimizeMetacellNumber(expMatrix = GeneExpressionMatrix, peakMatrix = PeakMatrix, exp_assay = &quot;normalizedCounts&quot;, peak_assay = &quot;counts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), BPPARAM = BiocParallel::SerialParam(progressbar = FALSE)) cellNum object is now provided as an argument to calculateP2G. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), exp_assay = &quot;normalizedCounts&quot;, peak_assay = &quot;counts&quot;) ## Using epiregulon to compute peak to gene links... ## Value of the paramater &#39;cellNum&#39; has not been optimized. Considerrunning function &#39;optimizeMetacellNumber&#39; and use output to set&#39;cellNum&#39;. ## Creating metacells... ## Looking for regulatory elements near target genes... ## Computing correlations... ## | | | 0% | |== | 2% | |=== | 5% | |===== | 7% | |====== | 9% | |======== | 11% | |========== | 14% | |=========== | 16% | |============= | 18% | |============== | 20% | |================ | 23% | |================== | 25% | |=================== | 27% | |===================== | 30% | |====================== | 32% | |======================== | 34% | |========================= | 36% | |=========================== | 39% | |============================= | 41% | |============================== | 43% | |================================ | 45% | |================================= | 48% | |=================================== | 50% | |===================================== | 52% | |====================================== | 55% | |======================================== | 57% | |========================================= | 59% | |=========================================== | 61% | |============================================= | 64% | |============================================== | 66% | |================================================ | 68% | |================================================= | 70% | |=================================================== | 73% | |==================================================== | 75% | |====================================================== | 77% | |======================================================== | 80% | |========================================================= | 82% | |=========================================================== | 84% | |============================================================ | 86% | |============================================================== | 89% | |================================================================ | 91% | |================================================================= | 93% | |=================================================================== | 95% | |==================================================================== | 98% | |======================================================================| 100% ## ## | | | 0% | |============== | 20% | |============================ | 40% | |========================================== | 60% | |======================================================== | 80% | |======================================================================| 100% p2g ## DataFrame with 67644 rows and 10 columns ## idxATAC chr start end idxRNA target Correlation ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; ## 1 1 chr1 817086 817586 17 LINC00115 0.487936 ## 2 10 chr1 897218 897718 30 HES4 0.464881 ## 3 27 chr1 955434 955934 30 HES4 0.552958 ## 4 27 chr1 955434 955934 33 AGRN 0.498275 ## 5 29 chr1 959712 960212 31 ISG15 -0.398968 ## ... ... ... ... ... ... ... ... ## 67640 159255 chrX 154799001 154799501 36414 DKC1 -0.378386 ## 67641 159255 chrX 154799001 154799501 36415 MPP1 0.644579 ## 67642 159255 chrX 154799001 154799501 36419 F8A1 -0.395646 ## 67643 159256 chrX 154800772 154801272 36415 MPP1 0.610599 ## 67644 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 ## p_val_peak_gene FDR_peak_gene distance ## &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; ## 1 0.0397870 0.616636 9934 ## 2 0.0456846 0.625393 102261 ## 3 0.0248449 0.566187 44045 ## 4 0.0366621 0.603988 64184 ## 5 0.0247077 0.566187 40924 ## ... ... ... ... ## 67640 0.0295832 0.578736 36259 ## 67641 0.0118173 0.506844 5894 ## 67642 0.0252025 0.566187 86846 ## 67643 0.0158884 0.532984 4123 ## 67644 0.0257158 0.568362 85075 2.4 Add TF motif binding to peaks The next step is to add the TF binding information by overlapping regions of the peak matrix with the bulk chip-seq database. The output is a data frame object with three columns: idxATAC - index of the peak in the peak matrix idxTF - index in the gene expression matrix corresponding to the transcription factor tf - name of the transcription factor overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) ## Computing overlap... ## Success! head(overlap) ## idxATAC idxTF tf ## 1 1 16 ATF1 ## 2 1 17 ATF2 ## 3 1 18 ATF3 ## 4 1 21 ATF7 ## 5 1 35 BRCA2 ## 6 1 36 BRD4 2.5 Generate regulons A data frame representing the inferred regulons is then generated. The data frame consists of several columns, including those indicating target genes, transcription factors, and regulatory elements indexed by their corresponding rows in the PeakMatrix. regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 8418612 rows and 12 columns ## idxATAC chr start end idxRNA target corr ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; ## 1 1 chr1 817086 817586 17 LINC00115 0.487936 ## 2 1 chr1 817086 817586 17 LINC00115 0.487936 ## 3 1 chr1 817086 817586 17 LINC00115 0.487936 ## 4 1 chr1 817086 817586 17 LINC00115 0.487936 ## 5 1 chr1 817086 817586 17 LINC00115 0.487936 ## ... ... ... ... ... ... ... ... ## 8418608 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 ## 8418609 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 ## 8418610 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 ## 8418611 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 ## 8418612 159256 chrX 154800772 154801272 36419 F8A1 -0.393617 ## p_val_peak_gene FDR_peak_gene distance idxTF tf ## &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 0.039787 0.616636 9934 16 ATF1 ## 2 0.039787 0.616636 9934 17 ATF2 ## 3 0.039787 0.616636 9934 18 ATF3 ## 4 0.039787 0.616636 9934 21 ATF7 ## 5 0.039787 0.616636 9934 35 BRCA2 ## ... ... ... ... ... ... ## 8418608 0.0257158 0.568362 85075 979 MNT ## 8418609 0.0257158 0.568362 85075 991 NFIA ## 8418610 0.0257158 0.568362 85075 1018 POLR2A ## 8418611 0.0257158 0.568362 85075 1020 POLR2AphosphoS5 ## 8418612 0.0257158 0.568362 85075 1335 ZNF766 2.6 Prune network (recommended) Since our regulon is quite large, and likely contains many false connections, we will pass it through the pruning function. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05 ) pruned.regulon 2.7 Annotate regulon Apart from pruning, the regulon can be annotated with metrics useful for further refinement. One such metric is the log fold change of gene expression in a specified group of cells compared to all other or a selected group. Before running addLogFC function we need to log-transform gene expression counts. # add &#39;logcounts&#39; assay GeneExpressionMatrix &lt;- scuttle::logNormCounts(GeneExpressionMatrix) regulon.FC &lt;- addLogFC(expMatrix = GeneExpressionMatrix, clusters = GeneExpressionMatrix$cell_type, regulon = pruned.regulon, pval.type = &quot;any&quot;, sig_type = &quot;FDR&quot;, assay.type = &quot;logcounts&quot;, logFC_condition=c(&#39;Naive CD4+ T&#39;) ) regulon.FC Another way to annotate the regulon is to add information about the presence of a motif at the regulatory element. By default, a new column named motif will be appended to the regulon, with 1s in rows where a motif has been found that matches the declared transcription factor. regulon.motif &lt;- addMotifScore(regulon = pruned.regulon, peaks = rowRanges(PeakMatrix), species = &quot;human&quot;, genome = &quot;hg38&quot;) regulon.motif 2.8 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging expressions of target genes linked to the TF weighted by the test statistics of choice. Using the method argument to the addWeights function, the user may choose among correlation, mutual information, or Wilcoxon as the test statistic. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weights_i\\] where \\(y\\) is the activity of a TF for a cell, \\(n\\) is the total number of targets for a TF, \\(x_i\\) is the log count expression of target \\(i\\) where \\(i\\) in {1,2,…,n} and \\(weights_i\\) is the weight of TF - target \\(i\\), calculated by running addWeights function. regulon.w &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;) ## adding weights using wilcoxon... score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;, exp_assay = &quot;normalizedCounts&quot;, normalize = FALSE) ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, regulon = ## regulon.w, : Argument &#39;method&#39; to calculateActivity was deprecated as of ## epiregulon version 2.0.0 ## calculating TF activity from regulon using weightedMean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by the number of targets... score.combine[1:5,1:5] ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## PBMC_10k#GGTTGCATCCTGGCTT-1 PBMC_10k#GGTTGCGGTAAACAAG-1 ## ADNP 0.11379320 0.09052355 ## AEBP2 0.03488950 0.06604866 ## AFF1 0.09373167 0.08967789 ## AFF4 0.11164763 0.10782789 ## AGO1 0.09017644 0.07779564 ## PBMC_10k#TGTTCCTCATAAGTTC-1 PBMC_10k#CGACTAAGTAACGGGA-1 ## ADNP 0.11310774 0.07767001 ## AEBP2 0.06581493 0.07258739 ## AFF1 0.10807508 0.06184494 ## AFF4 0.13602988 0.07292949 ## AGO1 0.08892206 0.05903171 ## PBMC_10k#CTGCTCCCAAGGTCCT-1 ## ADNP 0.1201884 ## AEBP2 0.0780261 ## AFF1 0.1136837 ## AFF4 0.1392258 ## AGO1 0.0889592 "],["data-preparation.html", "3 Data preparation 3.1 Construct a SingleCellExperiment object 3.2 Start from an ArchR object 3.3 Start from a Seurat/Signac object 3.4 Start from AnnData 3.5 Start from 10x data formats 3.6 Read directly from CSV 3.7 Important points", " 3 Data preparation Epiregulon operates on the SingleCellExperiment class. We assume that gene expression, chromatin accessibility and dimension reduction have been obtained by users’ favorite packages prior to the use of Epiregulon. This chapter provides instructions on how to convert gene expression matrix and peak matrix into SingleCellExperiment objects from other formats including ArchR project, Seurat objects, AnnData and 10x genomics output. The first section provides a quick primer on the components of a SingleCellExperiment object necessary to run Epiregulon. It is thus recommended for all users to go through it. 3.1 Construct a SingleCellExperiment object Let’s construct a GeneExpressionMatrix from scratch. First we will create the count matrix. library(SingleCellExperiment) counts &lt;- matrix(rpois(100000, lambda = 2), ncol=1000, nrow=100) GeneExpressionMatrix &lt;- SingleCellExperiment(list(counts=counts)) rownames(GeneExpressionMatrix) &lt;- paste(&quot;Gene&quot;,1:100, sep=&quot;-&quot;) colnames(GeneExpressionMatrix) &lt;- paste(&quot;Cell&quot;,1:1000, sep=&quot;-&quot;) It is important (and efficient) to convert the count matrix to dgCMatrix format at the beginning of the workflow. library(Matrix) ## ## Attaching package: &#39;Matrix&#39; ## The following object is masked from &#39;package:S4Vectors&#39;: ## ## expand counts(GeneExpressionMatrix) &lt;- as(counts(GeneExpressionMatrix), &quot;dgCMatrix&quot;) Next we will add the cell information to colData colData(GeneExpressionMatrix) &lt;- DataFrame(Cluster = paste(&quot;cluster&quot;, sample(1:3,1000, TRUE))) For the purpose of Epiregulon, it is important to provide the start and end position of the genes so that we can link genes to the peak regions. seqnames &lt;- paste0(&quot;chr&quot;, sample(1:2, 100, TRUE)) start &lt;- sample(1:100000, 100, TRUE) end &lt;- start + sample(100:500, 100, TRUE) strand &lt;- sample(c(&quot;+&quot;, &quot;-&quot;, &quot;*&quot;), 100, TRUE) gr &lt;- GRanges( seqnames = seqnames, ranges = IRanges(start = start, end = end), strand = strand ) Next we provide additional information about the genes. We can add them into the mcols as DataFrame. The GRanges become the rowRanges of the GeneExpressionMatrix. mcols(gr) &lt;- DataFrame(name = paste(&quot;Gene&quot;, 1:100, sep=&quot;-&quot;), ID = paste0(&quot;ID&quot;, 1:100)) rowRanges(GeneExpressionMatrix) &lt;- gr rowRanges(GeneExpressionMatrix) ## GRanges object with 100 ranges and 2 metadata columns: ## seqnames ranges strand | name ID ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## [1] chr1 84756-84878 * | Gene-1 ID1 ## [2] chr2 62792-63002 - | Gene-2 ID2 ## [3] chr1 70586-71071 * | Gene-3 ID3 ## [4] chr1 40856-41031 + | Gene-4 ID4 ## [5] chr2 34127-34534 - | Gene-5 ID5 ## ... ... ... ... . ... ... ## [96] chr2 91230-91581 * | Gene-96 ID96 ## [97] chr1 45345-45716 - | Gene-97 ID97 ## [98] chr2 86249-86388 + | Gene-98 ID98 ## [99] chr1 51039-51145 - | Gene-99 ID99 ## [100] chr1 57524-57636 - | Gene-100 ID100 ## ------- ## seqinfo: 2 sequences from an unspecified genome; no seqlengths The additional information about the genes will also appear in rowData rowData(GeneExpressionMatrix) ## DataFrame with 100 rows and 2 columns ## name ID ## &lt;character&gt; &lt;character&gt; ## 1 Gene-1 ID1 ## 2 Gene-2 ID2 ## 3 Gene-3 ID3 ## 4 Gene-4 ID4 ## 5 Gene-5 ID5 ## ... ... ... ## 96 Gene-96 ID96 ## 97 Gene-97 ID97 ## 98 Gene-98 ID98 ## 99 Gene-99 ID99 ## 100 Gene-100 ID100 Finally we add some reduced dimension data which is needed for clustering reducedDim(GeneExpressionMatrix, &quot;PCA&quot;) &lt;- matrix(data=rnorm(20000), nrow=1000, ncol=20) GeneExpressionMatrix ## class: SingleCellExperiment ## dim: 100 1000 ## metadata(0): ## assays(1): counts ## rownames: NULL ## rowData names(2): name ID ## colnames: NULL ## colData names(1): Cluster ## reducedDimNames(1): PCA ## mainExpName: NULL ## altExpNames(0): Repeat the process to create a PeakMatrix # add counts counts &lt;- matrix(rpois(1000000, lambda = 1), ncol=1000, nrow=1000) PeakMatrix &lt;- SingleCellExperiment(list(counts=counts)) rownames(PeakMatrix) &lt;- paste(&quot;Peak&quot;,1:1000, sep=&quot;-&quot;) colnames(PeakMatrix) &lt;- paste(&quot;Cell&quot;,1:1000, sep=&quot;-&quot;) # convert count matrix to dgCMatrix counts(PeakMatrix) &lt;- as(counts(PeakMatrix), &quot;dgCMatrix&quot;) # add rowRanges seqnames &lt;- paste0(&quot;chr&quot;, sample(1:2, 1000, TRUE)) start &lt;- sample(1:100000, 1000, TRUE) end &lt;- start + sample(100:500, 1000, TRUE) strand &lt;- sample(c(&quot;+&quot;, &quot;-&quot;, &quot;*&quot;), 1000, TRUE) gr &lt;- GRanges( seqnames = seqnames, ranges = IRanges(start = start, end = end), strand = strand ) # add rowData mcols(gr) &lt;- DataFrame(name = paste(&quot;Peak&quot;, 1:1000, sep=&quot;-&quot;)) rowRanges(PeakMatrix) &lt;- gr # add reduced dimensionality matrix reducedDim(PeakMatrix, &quot;ATAC_LSI&quot;) &lt;- matrix(data=rnorm(20000), nrow=1000, ncol=20) PeakMatrix ## class: SingleCellExperiment ## dim: 1000 1000 ## metadata(0): ## assays(1): counts ## rownames: NULL ## rowData names(1): name ## colnames(1000): Cell-1 Cell-2 ... Cell-999 Cell-1000 ## colData names(0): ## reducedDimNames(1): ATAC_LSI ## mainExpName: NULL ## altExpNames(0): For more information on SingleCellExperiment, please refer to the documentation on bioconductor. For a real example of a properly formatted SingleCellExperiment object, check out datasets from the scMultiome package. Both the GeneExpressionMatrix and PeakMatrix are combined into a MultiAssayExperiment object. mae &lt;- scMultiome::reprogramSeq() ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache Inspect the gene expression matrix GeneExpressMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] GeneExpressMatrix ## class: SingleCellExperiment ## dim: 36438 3903 ## metadata(1): .internal ## assays(2): counts normalizedCounts ## rownames(36438): MIR1302-2HG FAM138A ... IL9R WASIR1 ## rowData names(2): name strand.1 ## colnames(3903): reprogram#TTAGGAACAAGGTACG-1 ## reprogram#GAGCGGTCAACCTGGT-1 ... reprogram#GGTTACTAGACACCGC-1 ## reprogram#CGCTATGAGTGAACAG-1 ## colData names(23): BlacklistRatio DoubletEnrichment ... ReadsInPeaks ## FRIP ## reducedDimNames(2): LSI_RNA UMAP_RNA ## mainExpName: NULL ## altExpNames(0): Inspect the peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] PeakMatrix ## class: SingleCellExperiment ## dim: 126602 3903 ## metadata(1): .internal ## assays(1): counts ## rownames: NULL ## rowData names(1): idx ## colnames(3903): reprogram#TTAGGAACAAGGTACG-1 ## reprogram#GAGCGGTCAACCTGGT-1 ... reprogram#GGTTACTAGACACCGC-1 ## reprogram#CGCTATGAGTGAACAG-1 ## colData names(23): BlacklistRatio DoubletEnrichment ... ReadsInPeaks ## FRIP ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): 3.2 Start from an ArchR object Epiregulon is designed to work seamlessly with ArchR. GeneExpressionMatrix and PeakMatrix can be easily exported from ArchR using ArchR’s build-in function. Download a test ArchR project library(ArchR) archr.proj &lt;- getTestProject() Check available matrices in ArchR project getAvailableMatrices(ArchRProj = archr.proj) ## [1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;MotifMatrix&quot; ## [4] &quot;PeakMatrix&quot; &quot;TileMatrix&quot; Export the GeneExpressionMatrix and PeakMatrix from the ArchR project. GeneExpressionMatrix &lt;- getMatrixFromProject(ArchRProj = archr.proj, useMatrix = &quot;GeneIntegrationMatrix&quot;) PeakMatrix &lt;- getMatrixFromProject(ArchRProj = archr.proj, useMatrix = &quot;PeakMatrix&quot;) GeneExpressionMatrix ## class: SummarizedExperiment ## dim: 2051 127 ## metadata(0): ## assays(1): GeneIntegrationMatrix ## rownames: NULL ## rowData names(6): seqnames start ... name idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un PeakMatrix ## class: RangedSummarizedExperiment ## dim: 2142 127 ## metadata(0): ## assays(1): PeakMatrix ## rownames: NULL ## rowData names(1): idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un The GeneExpressionMatrix and PeakMatrix exported from ArchR project are in the form of SummarizedExperiment and RangedSummarizedExperiment respectively. We provide a helper function to convert both to SingleCellExperiment class. Furthermore, the genomic location of the genes are transferred from rowData in the RangedSummarizedExperiment to the rowRanges of the SingleCellExperiment. Please note that GeneExpressionMatrix extracted from ArchR project contain normalized counts (not logged) and for clarity, we rename the assay as “normalizedCounts” library(epiregulon.archr) ## ## Attaching package: &#39;epiregulon.archr&#39; ## The following objects are masked from &#39;package:epiregulon&#39;: ## ## addMotifScore, addTFMotifInfo, calculateP2G, getTFMotifInfo GeneExpressionMatrix &lt;- ArchRMatrix2SCE(rse = GeneExpressionMatrix, rename = &quot;normalizedCounts&quot;) GeneExpressionMatrix ## class: SingleCellExperiment ## dim: 2051 127 ## metadata(0): ## assays(1): normalizedCounts ## rownames: NULL ## rowData names(2): name idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): We can also transform the counts to logcounts. This will add a new assay and we name it as “logcounts”. GeneExpressionMatrix &lt;- ArchRMatrix2SCE(rse = GeneExpressionMatrix, transform = TRUE, transform_method = &quot;log&quot;, log_name = &quot;logcounts&quot;) GeneExpressionMatrix ## class: SingleCellExperiment ## dim: 2051 127 ## metadata(0): ## assays(2): counts logcounts ## rownames: NULL ## rowData names(2): name idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): Check that rowRanges have been transferred rowRanges(GeneExpressionMatrix) ## GRanges object with 2051 ranges and 2 metadata columns: ## seqnames ranges strand | name idx ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;integer&gt; ## [1] chr11 126987-139152 - | LINC01001 1 ## [2] chr11 193080-194573 + | SCGB1C1 2 ## [3] chr11 196761-200258 + | ODF3 3 ## [4] chr11 202924-207422 - | BET1L 4 ## [5] chr11 208530-215110 + | RIC8A 5 ## ... ... ... ... . ... ... ## [2047] chr5 180551357-180552304 - | OR2V1 827 ## [2048] chr5 180581943-180582890 + | OR2V2 828 ## [2049] chr5 180620924-180632177 - | TRIM7 829 ## [2050] chr5 180650263-180662808 + | TRIM41 830 ## [2051] chr5 180683386-180688119 - | TRIM52 831 ## ------- ## seqinfo: 2 sequences from an unspecified genome; no seqlengths We next convert the PeakMatrix to a SingleCellExperiment object. The counts exported from ArchR are raw counts and thus we rename the assay as “counts” PeakMatrix &lt;- ArchRMatrix2SCE(PeakMatrix, rename = &quot;counts&quot;) PeakMatrix ## class: SingleCellExperiment ## dim: 2142 127 ## metadata(0): ## assays(1): counts ## rownames: NULL ## rowData names(1): idx ## colnames(127): PBSmall#B.43 PBSmall#T.24 ... PBSmall#B.37 PBSmall#B.4 ## colData names(20): BlacklistRatio nDiFrags ... predictedGroup_Un ## predictedScore_Un ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): Neither SummarizedExperiment object or RangedSummarizedExperiment object contains reduced dimension, so we must extract the reduced dimensionality matrix from the ArchR project and add it to GeneExpressionMatrix and/or PeakMatrix reducedDim(PeakMatrix, &quot;IterativeLSI&quot;) &lt;- getReducedDims(ArchRProj = archr.proj, reducedDims = &quot;IterativeLSI&quot;) Refer to ArchR manual for full documentation. 3.3 Start from a Seurat/Signac object We download an example multimodel dataset from SeuratData. devtools::install_github(&#39;satijalab/seurat-data&#39;) library(SeuratData) InstallData(&quot;pbmcMultiome&quot;) This is a PBMC dataset consisting of both RNAseq and ATACseq data and we load each modality as a separate Seurat object library(Seurat) library(Signac) library(SeuratData) pbmc.rna &lt;- LoadData(&quot;pbmcMultiome&quot;, &quot;pbmc.rna&quot;) pbmc.atac &lt;- LoadData(&quot;pbmcMultiome&quot;, &quot;pbmc.atac&quot;) We first convert the RNA Seurat object to GeneExpressionMatrix SingleCellExperiment class. GeneExpressionMatrix &lt;- as.SingleCellExperiment(pbmc.rna, assay=&quot;RNA&quot;) Because these genes are missing genomic positions, we must first annotate them with a genomic database, for example ensembl library(AnnotationHub) ah &lt;- AnnotationHub() edb &lt;- ah[[&quot;AH98047&quot;]] #&quot;EnsDb.Hsapiens.v105&quot; ## loading from cache ## require(&quot;ensembldb&quot;) gr &lt;- genes(edb, columns = c(&quot;gene_id&quot;, &quot;gene_name&quot;)) We retain only the genes that have genomic positions. The genomic positions are necessary to link peak positions to the nearby target genes. common_genes &lt;- na.omit(intersect(gr$gene_name, rownames(GeneExpressionMatrix))) GeneExpressionMatrix &lt;- GeneExpressionMatrix[common_genes,] rowRanges(GeneExpressionMatrix) &lt;- gr[match(common_genes, gr$gene_name)] rowRanges(GeneExpressionMatrix) ## GRanges object with 23644 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; ## ENSG00000243485 1 29554-31109 + | ENSG00000243485 ## ENSG00000237613 1 34554-36081 - | ENSG00000237613 ## ENSG00000186092 1 65419-71585 + | ENSG00000186092 ## ENSG00000284733 1 450740-451678 - | ENSG00000284733 ## ENSG00000284662 1 685716-686654 - | ENSG00000284662 ## ... ... ... ... . ... ## ENSG00000228296 Y 25063083-25099892 - | ENSG00000228296 ## ENSG00000223641 Y 25182277-25213389 - | ENSG00000223641 ## ENSG00000228786 Y 25378300-25394719 - | ENSG00000228786 ## ENSG00000172288 Y 25622162-25624902 + | ENSG00000172288 ## ENSG00000231141 Y 25728490-25733388 + | ENSG00000231141 ## gene_name ## &lt;character&gt; ## ENSG00000243485 MIR1302-2HG ## ENSG00000237613 FAM138A ## ENSG00000186092 OR4F5 ## ENSG00000284733 OR4F29 ## ENSG00000284662 OR4F16 ## ... ... ## ENSG00000228296 TTTY4C ## ENSG00000223641 TTTY17C ## ENSG00000228786 LINC00266-4P ## ENSG00000172288 CDY1 ## ENSG00000231141 TTTY3 ## ------- ## seqinfo: 456 sequences (1 circular) from GRCh38 genome We then convert ATAC matrix to PeakMatrix. After conversion to SingleCellExperiment, the peak positions appear as rownames and must be converted to GRanges. PeakMatrix &lt;- as.SingleCellExperiment(pbmc.atac, assay=&quot;ATAC&quot;) peak_position &lt;- strsplit(rownames(PeakMatrix), split = &quot;-&quot;) gr &lt;- GRanges( seqnames = sapply(peak_position,&quot;[&quot;,1), ranges = IRanges(start = as.numeric(sapply(peak_position,&quot;[&quot;,2)), end = as.numeric(sapply(peak_position,&quot;[&quot;,3))) ) rowRanges(PeakMatrix) &lt;- gr PeakMatrix ## class: SingleCellExperiment ## dim: 108377 11909 ## metadata(0): ## assays(2): counts logcounts ## rownames: NULL ## rowData names(0): ## colnames(11909): AAACAGCCAAGGAATC-1 AAACAGCCAATCCCTT-1 ... ## TTTGTTGGTTGGTTAG-1 TTTGTTGGTTTGCAGA-1 ## colData names(5): orig.ident nCount_ATAC nFeature_ATAC ## seurat_annotations ident ## reducedDimNames(0): ## mainExpName: ATAC ## altExpNames(0): For more information, refer to Signac tutorial 3.4 Start from AnnData We download an example PBMC anndata dataset from scglue. We first import the GeneExpressionMatrix. library(zellkonverter) ## Registered S3 method overwritten by &#39;zellkonverter&#39;: ## method from ## py_to_r.pandas.core.arrays.categorical.Categorical reticulate library(GenomicRanges) library(SingleCellExperiment) url &lt;- &quot;http://download.gao-lab.org/GLUE/dataset/10x-Multiome-Pbmc10k-RNA.h5ad&quot; destfile &lt;- tempfile(fileext = &quot;.h5ad&quot;) # Download the file download.file(url, destfile, mode = &quot;wb&quot;) GeneExpressionMatrix &lt;- readH5AD(destfile, version=&quot;0.10.6&quot;) ## For native R and reading and writing of H5AD files, an R &lt;AnnData&gt; object, and ## conversion to &lt;SingleCellExperiment&gt; or &lt;Seurat&gt; objects, check out the ## anndataR package: ## ℹ Install it from Bioconductor with `BiocManager::install(&quot;anndataR&quot;)` ## ℹ See more at &lt;https://bioconductor.org/packages/anndataR/&gt; ## This message is displayed once per session. The field “chrom” “chromStart” “chromEnd” correspond to genomic positions of the genes. rowData(GeneExpressionMatrix) ## DataFrame with 29095 rows and 26 columns ## gene_ids feature_types genome chrom chromStart ## &lt;character&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt; ## AL627309.1 ENSG00000238009 Gene Expression GRCh38 chr1 89294 ## AL627309.5 ENSG00000241860 Gene Expression GRCh38 chr1 141473 ## AL627309.4 ENSG00000241599 Gene Expression GRCh38 chr1 160445 ## AP006222.2 ENSG00000286448 Gene Expression GRCh38 chr1 266854 ## AL669831.2 ENSG00000229905 Gene Expression GRCh38 chr1 760910 ## ... ... ... ... ... ... ## AC004556.3 ENSG00000276345 Gene Expression GRCh38 KI270721.1 2584 ## AC233755.2 ENSG00000277856 Gene Expression GRCh38 KI270726.1 26240 ## AC233755.1 ENSG00000275063 Gene Expression GRCh38 KI270726.1 41443 ## AC007325.1 ENSG00000276017 Gene Expression GRCh38 KI270734.1 72410 ## AC007325.4 ENSG00000278817 Gene Expression GRCh38 KI270734.1 131493 ## chromEnd name score strand thickStart thickEnd ## &lt;numeric&gt; &lt;character&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 133723 ENSG00000238009 . - . . ## AL627309.5 173862 ENSG00000241860 . - . . ## AL627309.4 161525 ENSG00000241599 . + . . ## AP006222.2 268655 ENSG00000286448 . + . . ## AL669831.2 761989 ENSG00000229905 . + . . ## ... ... ... ... ... ... ... ## AC004556.3 11802 ENSG00000276345 . + . . ## AC233755.2 26534 ENSG00000277856 . + . . ## AC233755.1 41876 ENSG00000275063 . + . . ## AC007325.1 74814 ENSG00000276017 . + . . ## AC007325.4 137392 ENSG00000278817 . + . . ## itemRgb blockCount blockSizes blockStarts gene_type gene_name ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 . . . . lncRNA AL627309.1 ## AL627309.5 . . . . lncRNA AL627309.5 ## AL627309.4 . . . . lncRNA AL627309.4 ## AP006222.2 . . . . lncRNA AP006222.2 ## AL669831.2 . . . . lncRNA AL669831.2 ## ... ... ... ... ... ... ... ## AC004556.3 . . . . protein_coding AC004556.3 ## AC233755.2 . . . . protein_coding AC233755.2 ## AC233755.1 . . . . protein_coding AC233755.1 ## AC007325.1 . . . . protein_coding AC007325.1 ## AC007325.4 . . . . protein_coding AC007325.4 ## hgnc_id havana_gene tag n_counts ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt; ## AL627309.1 NA OTTHUMG00000001096.2 overlapping_locus 70 ## AL627309.5 NA OTTHUMG00000002480.4 ncRNA_host 442 ## AL627309.4 NA OTTHUMG00000002525.1 NA 44 ## AP006222.2 NA OTTHUMG00000194680.1 NA 1 ## AL669831.2 NA OTTHUMG00000002408.1 NA 10 ## ... ... ... ... ... ## AC004556.3 NA NA NA 320 ## AC233755.2 NA NA NA 1 ## AC233755.1 NA NA NA 1 ## AC007325.1 NA NA NA 3 ## AC007325.4 NA NA NA 43 ## highly_variable highly_variable_rank means variances ## &lt;logical&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AL627309.1 FALSE NaN 0.007268196 0.008462225 ## AL627309.5 FALSE NaN 0.045893469 0.050853072 ## AL627309.4 FALSE NaN 0.004568581 0.004755865 ## AP006222.2 FALSE NaN 0.000103831 0.000103831 ## AL669831.2 FALSE NaN 0.001038314 0.001037343 ## ... ... ... ... ... ## AC004556.3 FALSE NaN 0.033226041 0.035448356 ## AC233755.2 FALSE NaN 0.000103831 0.000103831 ## AC233755.1 FALSE NaN 0.000103831 0.000103831 ## AC007325.1 FALSE NaN 0.000311494 0.000311429 ## AC007325.4 FALSE NaN 0.004464749 0.004445277 ## variances_norm ## &lt;numeric&gt; ## AL627309.1 0.971895 ## AL627309.5 0.888672 ## AL627309.4 0.891707 ## AP006222.2 0.999904 ## AL669831.2 0.933916 ## ... ... ## AC004556.3 0.856870 ## AC233755.2 0.999904 ## AC233755.1 0.999904 ## AC007325.1 0.975766 ## AC007325.4 0.854162 They must be renamed to “seqnames” “start” and “end” before conversion to GRanges index_to_rename &lt;- match(c(&quot;chrom&quot;, &quot;chromStart&quot;, &quot;chromEnd&quot;), colnames(rowData(GeneExpressionMatrix))) colnames(rowData(GeneExpressionMatrix))[index_to_rename] &lt;- c(&quot;seqnames&quot;, &quot;start&quot;, &quot;end&quot;) rowRanges(GeneExpressionMatrix) &lt;- GRanges(rowData(GeneExpressionMatrix)) rowRanges(GeneExpressionMatrix) ## GRanges object with 29095 ranges and 22 metadata columns: ## seqnames ranges strand | gene_ids feature_types ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt; ## AL627309.1 chr1 89294-133723 - | ENSG00000238009 Gene Expression ## AL627309.5 chr1 141473-173862 - | ENSG00000241860 Gene Expression ## AL627309.4 chr1 160445-161525 + | ENSG00000241599 Gene Expression ## AP006222.2 chr1 266854-268655 + | ENSG00000286448 Gene Expression ## AL669831.2 chr1 760910-761989 + | ENSG00000229905 Gene Expression ## ... ... ... ... . ... ... ## AC004556.3 KI270721.1 2584-11802 + | ENSG00000276345 Gene Expression ## AC233755.2 KI270726.1 26240-26534 + | ENSG00000277856 Gene Expression ## AC233755.1 KI270726.1 41443-41876 + | ENSG00000275063 Gene Expression ## AC007325.1 KI270734.1 72410-74814 + | ENSG00000276017 Gene Expression ## AC007325.4 KI270734.1 131493-137392 + | ENSG00000278817 Gene Expression ## genome name score thickStart thickEnd itemRgb ## &lt;factor&gt; &lt;character&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 GRCh38 ENSG00000238009 . . . . ## AL627309.5 GRCh38 ENSG00000241860 . . . . ## AL627309.4 GRCh38 ENSG00000241599 . . . . ## AP006222.2 GRCh38 ENSG00000286448 . . . . ## AL669831.2 GRCh38 ENSG00000229905 . . . . ## ... ... ... ... ... ... ... ## AC004556.3 GRCh38 ENSG00000276345 . . . . ## AC233755.2 GRCh38 ENSG00000277856 . . . . ## AC233755.1 GRCh38 ENSG00000275063 . . . . ## AC007325.1 GRCh38 ENSG00000276017 . . . . ## AC007325.4 GRCh38 ENSG00000278817 . . . . ## blockCount blockSizes blockStarts gene_type gene_name ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## AL627309.1 . . . lncRNA AL627309.1 ## AL627309.5 . . . lncRNA AL627309.5 ## AL627309.4 . . . lncRNA AL627309.4 ## AP006222.2 . . . lncRNA AP006222.2 ## AL669831.2 . . . lncRNA AL669831.2 ## ... ... ... ... ... ... ## AC004556.3 . . . protein_coding AC004556.3 ## AC233755.2 . . . protein_coding AC233755.2 ## AC233755.1 . . . protein_coding AC233755.1 ## AC007325.1 . . . protein_coding AC007325.1 ## AC007325.4 . . . protein_coding AC007325.4 ## hgnc_id havana_gene tag n_counts ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;numeric&gt; ## AL627309.1 NA OTTHUMG00000001096.2 overlapping_locus 70 ## AL627309.5 NA OTTHUMG00000002480.4 ncRNA_host 442 ## AL627309.4 NA OTTHUMG00000002525.1 NA 44 ## AP006222.2 NA OTTHUMG00000194680.1 NA 1 ## AL669831.2 NA OTTHUMG00000002408.1 NA 10 ## ... ... ... ... ... ## AC004556.3 NA NA NA 320 ## AC233755.2 NA NA NA 1 ## AC233755.1 NA NA NA 1 ## AC007325.1 NA NA NA 3 ## AC007325.4 NA NA NA 43 ## highly_variable highly_variable_rank means variances ## &lt;logical&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AL627309.1 FALSE NaN 0.007268196 0.008462225 ## AL627309.5 FALSE NaN 0.045893469 0.050853072 ## AL627309.4 FALSE NaN 0.004568581 0.004755865 ## AP006222.2 FALSE NaN 0.000103831 0.000103831 ## AL669831.2 FALSE NaN 0.001038314 0.001037343 ## ... ... ... ... ... ## AC004556.3 FALSE NaN 0.033226041 0.035448356 ## AC233755.2 FALSE NaN 0.000103831 0.000103831 ## AC233755.1 FALSE NaN 0.000103831 0.000103831 ## AC007325.1 FALSE NaN 0.000311494 0.000311429 ## AC007325.4 FALSE NaN 0.004464749 0.004445277 ## variances_norm ## &lt;numeric&gt; ## AL627309.1 0.971895 ## AL627309.5 0.888672 ## AL627309.4 0.891707 ## AP006222.2 0.999904 ## AL669831.2 0.933916 ## ... ... ## AC004556.3 0.856870 ## AC233755.2 0.999904 ## AC233755.1 0.999904 ## AC007325.1 0.975766 ## AC007325.4 0.854162 ## ------- ## seqinfo: 34 sequences from an unspecified genome; no seqlengths We next import the PeakMatrix. The rownames are already in the format of seqnames:start-end, so rowRanges can be extracted directly from rowData. library(zellkonverter) url &lt;- &quot;http://download.gao-lab.org/GLUE/dataset/10x-Multiome-Pbmc10k-ATAC.h5ad&quot; destfile &lt;- tempfile(fileext = &quot;.h5ad&quot;) # Download the file download.file(url, destfile, mode = &quot;wb&quot;) PeakMatrix &lt;- readH5AD(destfile, version=&quot;0.10.6&quot;) rowRanges(PeakMatrix) &lt;- GRanges(rowData(PeakMatrix)) rowRanges(PeakMatrix) ## GRanges object with 107194 ranges and 3 metadata columns: ## seqnames ranges strand | feature_types ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; ## chr1:816881-817647 chr1 816881-817647 * | Peaks ## chr1:819912-823500 chr1 819912-823500 * | Peaks ## chr1:825827-825889 chr1 825827-825889 * | Peaks ## chr1:826612-827979 chr1 826612-827979 * | Peaks ## chr1:841243-843059 chr1 841243-843059 * | Peaks ## ... ... ... ... . ... ## KI270713.1:20444-22615 KI270713.1 20444-22615 * | Peaks ## KI270713.1:27118-28927 KI270713.1 27118-28927 * | Peaks ## KI270713.1:29485-30706 KI270713.1 29485-30706 * | Peaks ## KI270713.1:31511-32072 KI270713.1 31511-32072 * | Peaks ## KI270713.1:37129-37638 KI270713.1 37129-37638 * | Peaks ## genome n_counts ## &lt;factor&gt; &lt;numeric&gt; ## chr1:816881-817647 GRCh38 1025 ## chr1:819912-823500 GRCh38 1384 ## chr1:825827-825889 GRCh38 20 ## chr1:826612-827979 GRCh38 4555 ## chr1:841243-843059 GRCh38 555 ## ... ... ... ## KI270713.1:20444-22615 GRCh38 12640 ## KI270713.1:27118-28927 GRCh38 533 ## KI270713.1:29485-30706 GRCh38 622 ## KI270713.1:31511-32072 GRCh38 207 ## KI270713.1:37129-37638 GRCh38 388 ## ------- ## seqinfo: 32 sequences from an unspecified genome; no seqlengths This example SingleCellExperiment dataset is missing the dimensionality reduction information. Users should have been this precalculated. Refer to the section on how to import from csv files, or refer to OSCA book on how to perform dimensionality reduction. 3.5 Start from 10x data formats 3.5.1 Read from .h5 file We first download the publicly available PBMC data from 10x Genomics url &lt;- &quot;https://cf.10xgenomics.com/samples/cell-arc/1.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5&quot; destfile &lt;- tempfile(fileext = &quot;.h5&quot;) # Download the file download.file(url, destfile, mode = &quot;wb&quot;) This .h5 file contains both genes and peak regions as features, so we read in all the features into a single SingleCellExperiment, and we can specify “Gene Expression” as the main experiment and “Peaks” as the alternative experiment. We then split this single object into 2 separate SingleCellExperiment objects for consistency with other sections. library(DropletUtils) sce10x &lt;- read10xCounts(destfile) sce10x &lt;- splitAltExps(sce10x, f=rowData(sce10x)$Type, ref=&quot;Gene Expression&quot;) peakMatrix &lt;- altExp(sce10x) rowRanges(peakMatrix) &lt;- GRanges(rownames(peakMatrix)) GeneExpressionMatrix &lt;- removeAltExps(sce10x) 3.5.2 Read directly from a 10x directory We can also create a SingleCellExperiment object from a directory containing “matrix.mtx.gz”, “barcodes.tsv.gz” and “features.tsv.gz” example(write10xCounts) list.files(tmpdir) sce10x &lt;- read10xCounts(tmpdir) Refer to the section on Constructing a SingleCellExperiment object on how to construct SingleCellExperiment, add colData, rowData and reduced dimensions. 3.6 Read directly from CSV If the count matrices are in the form of csv files, read in the count matrix as a sparse matrix and convert it to a dgCMatrix. library(SparseArray) counts &lt;- readSparseCSV(&quot;counts.csv&quot;) counts &lt;- as(counts, &quot;dgCMatrix&quot;) Then read in the genomic positions as data.frame and convert it to a GRanges. peak_position &lt;- read.csv(&quot;peaks.csv&quot;) peak_position &lt;- data.frame(peak_position) gr &lt;- GenomicRanges::makeGRangesFromDataFrame(peak_position) Refer to the section on Constructing a SingleCellExperiment object on how to construct SingleCellExperiment, add colData, rowData and reduced dimensions. 3.7 Important points Finally, we would like to emphasize again the importance of converting all count matrices to dgCMatrix for speed and compatibility. Both gene expression and peak matrices require rowRanges to indicate genomic positions of target gene position and peak position. "],["construction.html", "4 Construction of the gene regulatory network 4.1 Download and format dataset 4.2 Retrieve TF occupancy data 4.3 Link ATACseq peaks to target genes 4.4 Add TF occupancy to peaks 4.5 Generate regulons", " 4 Construction of the gene regulatory network This chapter outlines the basic steps for constructing a gene regulatory network, which takes the form of a tripartite graph: TF → RE → TG. In brief, TF occupancy data—derived from either ChIP-seq or motif information—are used to map transcription factors onto genomic regions (here, ATAC-seq peaks). These regions are then linked to their target genes by leveraging the assumption that chromatin accessibility and gene expression are highly correlated. 4.1 Download and format dataset We will make use of the PBMC data set from 10x Genomics. The MAE object was uploaded to scMultiome for full reproducibility. # Download the example dataset mae &lt;- scMultiome::PBMC_10x() # Load peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # Load expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] Visualize the data. scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_RNA&quot;, text_by = &quot;cell_type&quot;, colour_by = &quot;cell_type&quot;, point_size = 0.3, point_alpha = 0.3) 4.2 Retrieve TF occupancy data We recommend using ChIP-seq data—rather than motifs—as the proxy for TF occupancy. The gold standard in the field is to use sample-matched ChIP-seq for TF binding. To support this, we provide both sample-specific and tissue-specific ChIP-seq peak sets. However, sample-matched or tissue-matched ChIP-seq data are not available for many factors. To address this, we include a set of pan-tissue ChIP-seq peaks, generated by merging data across multiple samples and lineages; this serves as the default TF occupancy source. Benchmarking in our manuscript demonstrates that pan-tissue ChIP-seq still outperforms motif-based annotations for TF activity inference and target-gene recovery. In addition, ChIP-seq offers a key advantage over motifs in enabling GRN inference for transcriptional co-regulators that lack known motifs. One limitation of ChIP-seq–based occupancy is that its accuracy depends on the underlying experimental quality. We applied several quality-control filters to the ChIP-seq data included (see Methods in the manuscript), but some factors still exhibit very large numbers of binding sites (&gt;100k). This may reflect true biology or simply false positives. In such cases, filtering TF occupancy based on the intersection of ChIP-seq peaks and motif sites (see next chapter) can be helpful. 4.2.1 ChIP-seq data We retrieve a GRangesList object containing the binding sites of all the transcription factors and co-regulators. These binding sites are derived from bulk ChIP-seq data in the ChIP-Atlas and ENCODE databases, and merged across multiple cell lines or tissues. Currently, human genomes hg19 and hg38 and mouse mm10 are supported. All ChIP-seq and motif binding sites are hosted on ExperimentHub. The initial download may take some time, but the data are cached for subsequent use. library(epiregulon) grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; For both ChIP-Atlas and ENCODE data, we also provide sample-specific TF binding sites. They are retrieved as a list of GrangesList objects, by specifying atlas.sample or encode.sample in the source argument. grl_list_sample_atlas &lt;- getTFMotifInfo(genome = &quot;hg38&quot;, source = &quot;atlas.sample&quot;) head(names(grl_list_sample_atlas)) ## [1] &quot;ML-2&quot; &quot;hTERT RPE-1&quot; &quot;DLD-1&quot; &quot;293&quot; &quot;HeLa&quot; ## [6] &quot;MCF-7&quot; Then we need to access a specific list element by providing the sample of interest. Here we choose \"Peripheral blood mononuclear cells\". grl_list_sample_atlas[[&quot;Peripheral blood mononuclear cells&quot;]] ## GRangesList object of length 2: ## $EZH2 ## GRanges object with 14399 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9949-10539 * ## [2] chr1 28949-29442 * ## [3] chr1 180750-181044 * ## [4] chr1 199296-200054 * ## [5] chr1 629280-630005 * ## ... ... ... ... ## [14395] chrUn_KI270435v1 91984-92197 * ## [14396] chrUn_KI270512v1 252-395 * ## [14397] chr15_KI270727v1_ran.. 80081-80345 * ## [14398] chr1_KI270706v1_random 165426-165601 * ## [14399] chrUn_KI270743v1 152955-153105 * ## ------- ## seqinfo: 89 sequences from an unspecified genome; no seqlengths ## ## $HIF1A ## GRanges object with 2199 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 10009-10248 * ## [2] chr1 10359-10460 * ## [3] chr1 180748-180991 * ## [4] chr1 631239-631293 * ## [5] chr1 631989-632060 * ## ... ... ... ... ## [2195] chrY 56826777-56826855 * ## [2196] chrY 56847169-56847217 * ## [2197] chrY 56850383-56850460 * ## [2198] chrY 56850790-56850873 * ## [2199] chrY 56851105-56851159 * ## ------- ## seqinfo: 89 sequences from an unspecified genome; no seqlengths Alternatively, we might retrieve chip-seq data for \"K562\" cells present in the ENCODE database. grl_list_sample_encode &lt;- getTFMotifInfo(genome = &quot;hg38&quot;, source = &quot;encode.sample&quot;) grl_list_sample_encode[[&quot;K562&quot;]] ## GRangesList object of length 468: ## $PYGO2 ## GRanges object with 6664 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr3 3110104-3110423 * ## [2] chr3 4225236-4225599 * ## [3] chr3 4350776-4351095 * ## [4] chr3 4467164-4467483 * ## [5] chr3 4533816-4534135 * ## ... ... ... ... ## [6660] chr13 99053615-99053934 * ## [6661] chr13 109707096-109707415 * ## [6662] chr13 110874168-110874531 * ## [6663] chr13 110963556-110963834 * ## [6664] chr13 112711615-112711978 * ## ------- ## seqinfo: 54 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;467 more elements&gt; The tissue-specific chip-seq data are also available. They were compiled from the ChIP-Atlas database. grl_list_tissue &lt;- getTFMotifInfo(genome = &quot;hg38&quot;, source = &quot;atlas.tissue&quot;) grl_list_tissue[[&quot;Blood&quot;]] ## GRangesList object of length 770: ## $`MLL-AF6` ## GRanges object with 477 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 4303013-4303150 * ## [2] chr1 71928076-71928393 * ## [3] chr1 87300735-87300856 * ## [4] chr1 91387234-91387457 * ## [5] chr1 108771977-108772126 * ## ... ... ... ... ## [473] chrY 56838883-56839022 * ## [474] chrY 56843654-56843767 * ## [475] chrY 56848774-56848878 * ## [476] chrY 56850362-56850481 * ## [477] chrY 56851423-56851611 * ## ------- ## seqinfo: 183 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;769 more elements&gt; The advantage of using tissue- or sample-specific ChIP-seq data is that they accurately reflect TF binding sites that are characteristic of a given cell type or cell line. The downside is the small number of factors and peaks due to the limited number of experiments used to compile the data. # calculate the total number of factors contained in each grl # pan-tissue length(grl) ## [1] 1558 # blood tissue length(grl_list_tissue[[&quot;Blood&quot;]]) ## [1] 770 # Peripheral blood mononuclear cells sample length(grl_list_sample_atlas[[&quot;Peripheral blood mononuclear cells&quot;]]) ## [1] 2 # K562 cell line sample length(grl_list_sample_encode[[&quot;K562&quot;]]) ## [1] 468 # calculate the total number of regions contained in each grl # pan-tissue format(sum(unlist(lapply(grl, length))), big.mark=&quot;,&quot;) ## [1] &quot;54,501,169&quot; # blood tissue format(sum(unlist(lapply(grl_list_tissue[[&quot;Blood&quot;]], length))), big.mark=&quot;,&quot;) ## [1] &quot;18,684,867&quot; # Peripheral blood mononuclear cells sample format(sum(unlist(lapply(grl_list_sample_atlas[[&quot;Peripheral blood mononuclear cells&quot;]], length))), big.mark=&quot;,&quot;) ## [1] &quot;16,598&quot; # K562 cell line sample format(sum(unlist(lapply(grl_list_sample_encode[[&quot;K562&quot;]], length))), big.mark=&quot;,&quot;) ## [1] &quot;6,352,422&quot; Lastly, users can always supply their custom ChIP-seq data and convert them into GrangesList. 4.2.2 Motif information While ChIP-seq data provide experimentally determined TF biding sites, some users might prefer to start from motif sequences as positions of TF occupancy. If motif is chosen for mode, getTFMotifInfo retrieves the motif information from the CIS_BP database and scans the peak regions for presence of motifs. grl_motif &lt;- getTFMotifInfo(genome = &quot;hg38&quot;, mode = &quot;motif&quot;, peaks = rowRanges(PeakMatrix)) 4.3 Link ATACseq peaks to target genes Next, we link ATAC-seq peaks to their putative target genes. We assign a peak to a gene if it falls within a size window (default ±250kb) and if the chromatin accessibility of the peak and expression of the target gene is highly correlated across cell aggregates. To calculate correlations, we create cell aggregates (or metacells) by performing deterministic k-means clustering on the reduced dimensionality matrix (for description of the algorithm description, see https://ltla.github.io/CppKmeans/classkmeans_1_1InitializeVariancePartition.html. Then we aggregate the counts for the gene expression and peak matrices and normalize them by the number of cells. Correlations are thus computed on the averaged gene expression and chromatin accessibility. 4.3.1 Optimize the number of metacells (optional) It is important to pick the correct value for the cellNum parameter, which controls the number of metacells used for aggregation. Too few metacells can obscure biologically meaningful variation, while overly fine-grained aggregation may fail to sufficiently stabilize the signal, leaving substantial noise arising from data sparsity, technical bias, or biologically irrelevant fluctuations. In practice, we aim to strike a balance between these extremes and identify an optimal metacell number. This is the motivation behind the introduction of the new function optimizeMetacellNumber, released with epiregulon v2.0.0. The function computes mean empirical p-values across a range of metacell numbers, then fits a quadratic model that regresses these p-values against the square root of the mean number of cells per metacell. Squaring the value of \\(x_{min}\\) yields the estimated optimal mean number of cells per metacell. set.seed(1010) cellNum &lt;- optimizeMetacellNumber(expMatrix = GeneExpressionMatrix, peakMatrix = PeakMatrix, exp_assay = &quot;normalizedCounts&quot;, peak_assay = &quot;counts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), BPPARAM = BiocParallel::SerialParam(progressbar = FALSE)) cellNum ## A CellNumSol object. ## Estimated optimal number of cells per cluster: 355.89 ## Evaluation points: 4.47213595499958, 11.1403077174484, 14.4743935986728, 17.8084794798972, 21.1425653611216, 24.4766512423461, 27.8107371235705, 31.1448230047949 ## Mean p-values: 0.471653227222363, 0.463506475168375, 0.462227101701293, 0.463629568404436, 0.461326242635391, 0.463491875442245, 0.46758445654325, 0.467161192360535 We can check specifically the estimated optimal number of cells per cluster (mean metacell size) by computing the square of the solution slot. cellNum@solution^2 ## [1] 355.886 The plot function allows for visualization of the function performance at different evaluation points. The estimated optimum is marked by a red dashed line. plot(cellNum) The object returned by optimizeMetacellNumber can be passed to calculateP2G as the cellNum parameter. User might also provide a numeric to directly set the mean number of cells per cluster. 4.3.2 Find peak-target gene links within a defined distance The default method for linking regulatory elements to target genes is to compute correlations at the metacell level. A null distribution is generated by correlating randomly selected peak–gene pairs located on different chromosomes. Correlations are then calculated for all peak–gene pairs within a specified genomic distance (default ±250 kb). By default, only links with a p-value &lt; 0.05 are retained, although this behavior can be modified via the cutoff_sig argument. Although the algorithm for identifying metacell clusters is deterministic, reproducibility still requires setting a random seed because the null distribution is estimated from randomly sampled peak–gene pairs. To reduce the stochasticity introduced by this random sampling, one may increase the nRandConn parameter, which controls the number of random connections drawn. If cluster labels are provided, peak–gene correlations are also computed within each cluster. A peak–gene link is retained if it passes the p-value threshold in any cluster. The resulting expanded list of links captures both inter- and intra-cluster variation. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), cellNum = cellNum, BPPARAM = BiocParallel::SerialParam(progressbar = FALSE)) ## Using epiregulon to compute peak to gene links... ## Creating metacells... ## Looking for regulatory elements near target genes... ## Computing correlations... p2g ## DataFrame with 72838 rows and 10 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; ## 1 7 chr1 860832 861332 16 FAM87B ## 2 9 chr1 869608 870108 20 AL645608.6 ## 3 10 chr1 897218 897718 30 HES4 ## 4 13 chr1 904517 905017 18 LINC01128 ## 5 23 chr1 941054 941554 29 AL645608.7 ## ... ... ... ... ... ... ... ## 72834 159273 chrX 155094423 155094923 36424 VBP1 ## 72835 159278 chrX 155216170 155216670 36424 VBP1 ## 72836 159279 chrX 155242243 155242743 36426 CLIC2 ## 72837 159283 chrX 155334892 155335392 36426 CLIC2 ## 72838 159285 chrX 155611289 155611789 36434 TMLHE ## Correlation p_val_peak_gene FDR_peak_gene distance ## &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; ## 1 0.836218 0.00984125 0.471797 43461 ## 2 -0.526697 0.03642875 0.552536 34724 ## 3 0.657448 0.04814514 0.591177 102261 ## 4 0.702887 0.03395543 0.547711 76919 ## 5 -0.545817 0.03044073 0.540428 56495 ## ... ... ... ... ... ## 72834 0.747270 0.02415580 0.526717 102082 ## 72835 0.754892 0.02247051 0.518898 19163 ## 72836 0.807040 0.01373198 0.488274 91869 ## 72837 0.939910 0.00189335 0.417877 278 ## 72838 0.807340 0.01369036 0.488274 1086 4.3.3 Link peaks to the nearest genes Alternatively, we can identify the downstream targets of each regulatory region by assigning them to their nearest gene. The maxDist argument specifies the maximum allowed distance between a regulatory element and a gene for a link to be made. As before, correlations are computed and only those exceeding the threshold are retained. set.seed(1010) p2g_nearest &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;LSI_RNA&quot;), assignment_method = &quot;nearest&quot;, BPPARAM = BiocParallel::SerialParam(progressbar = FALSE) ) ## Using epiregulon to compute peak to gene links... ## Value of the paramater &#39;cellNum&#39; has not been optimized. Considerrunning function &#39;optimizeMetacellNumber&#39; and use output to set&#39;cellNum&#39;. ## Creating metacells... ## Looking for regulatory elements near target genes... ## Computing correlations... 4.3.4 Filter peak-target gene links The number of possible links between target genes and regulatory elements can be large. Therefore, we need to reduce this number, keeping only those links for which we have support in our data. By default, calculateP2G uses a p-value threshold to pinpoint putative connections between target genes and regulatory regions. However, users may also choose to use FDR or rely directly on the correlation. This behavior is controlled by the cutoff_stat argument. If Correlation is specified, the default threshold of 0.5 is used, as defined by cor_cutoff. Note that only links with correlation greater than this threshold will be kept, potentially ignoring meaningful highly negative correlations. Additionally, the correlation distribution might vary with dataset size, resulting in different FDRs for the same correlation threshold. Threshold for p_val and FDR is set by the cutoff_sig argument. 4.4 Add TF occupancy to peaks The next step is to add TF binding information to peak regions. overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) ## Computing overlap... ## Success! head(overlap) ## idxATAC idxTF tf ## 711 7 12 ARID5B ## 712 7 91 ELF3 ## 713 7 150 HEY1 ## 714 7 159 HNF4A ## 715 7 160 HNF4G ## 716 7 217 MAX 4.5 Generate regulons A DataFrame, representing the inferred regulons, is then generated. The DataFrame object consists of the following columns: idxATAC - index of the peak in the peak matrix chr - chromosome number start - start position of the peak end - end position of the peak idxRNA - index in the gene expression matrix corresponding to the target gene target - name of the target gene corr - correlation between target gene expression and the chromatin accessibility at the peak. If cluster labels are provided, this field is a matrix with columns names corresponding to correlation across all cells and for each of the clusters. p_val_peak_gene - empirical p-value of the correlation between peak and target gene. If cluster labels are provided, this field is a matrix with columns names corresponding to p-value for all cells and for each of the clusters. FDR_peak_gene - false discovery rates calculated based on the empirical p-value of the correlations between peaks and target genes. If cluster labels are provided, this field is a matrix with columns names corresponding to FDR for all cells and for each of the clusters. distance - distance between the transcription start site of the target gene and the middle of the peak idxTF - index in the gene expression matrix corresponding to the transcription factor tf - name of the transcription factor regulon &lt;- getRegulon(p2g, overlap, aggregate=FALSE) regulon ## DataFrame with 9254974 rows and 12 columns ## idxATAC chr start end idxRNA target corr ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; ## 1 7 chr1 860832 861332 16 FAM87B 0.836218 ## 2 7 chr1 860832 861332 16 FAM87B 0.836218 ## 3 7 chr1 860832 861332 16 FAM87B 0.836218 ## 4 7 chr1 860832 861332 16 FAM87B 0.836218 ## 5 7 chr1 860832 861332 16 FAM87B 0.836218 ## ... ... ... ... ... ... ... ... ## 9254970 159285 chrX 155611289 155611789 36434 TMLHE 0.80734 ## 9254971 159285 chrX 155611289 155611789 36434 TMLHE 0.80734 ## 9254972 159285 chrX 155611289 155611789 36434 TMLHE 0.80734 ## 9254973 159285 chrX 155611289 155611789 36434 TMLHE 0.80734 ## 9254974 159285 chrX 155611289 155611789 36434 TMLHE 0.80734 ## p_val_peak_gene FDR_peak_gene distance idxTF tf ## &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 0.00984125 0.471797 43461 12 ARID5B ## 2 0.00984125 0.471797 43461 91 ELF3 ## 3 0.00984125 0.471797 43461 150 HEY1 ## 4 0.00984125 0.471797 43461 159 HNF4A ## 5 0.00984125 0.471797 43461 160 HNF4G ## ... ... ... ... ... ... ## 9254970 0.0136904 0.488274 1086 348 SMARCC1 ## 9254971 0.0136904 0.488274 1086 360 SPI1 ## 9254972 0.0136904 0.488274 1086 432 ZBTB7A ## 9254973 0.0136904 0.488274 1086 630 GFP ## 9254974 0.0136904 0.488274 1086 785 MYH11 "],["refinement.html", "5 Refinement of gene regulatory network 5.1 Network pruning 5.2 Annotate with TF motifs 5.3 Annotate with log fold changes", " 5 Refinement of gene regulatory network The regulon object constructed in the previous chapter contains all possible links between transcription factors and target genes. As a result, the GRN can be large and may contain some false connections. To refine it, we need to apply filters that retain only those connections supported by our dataset. One such filter has already been applied in the calculateP2G function, which not only searches for regulatory elements within a specified distance from each target gene, but also computes the empirical p-value of the correlation for each target gene–regulatory element pair. Pairs are retained if their p-value is below the threshold specified by the cutoff_sig argument. In this chapter, we introduce three additional filters. The pruneRegulon function filters the GRN based on the co-occurrence of TF gene expression, RE chromatin accessibility and target gene expression. The addMotifScore function annotates regulons for the presence of motifs. Lastly, the addLogFC function calculates changes in gene expression between conditions, so that only target genes showing differential expression are selected. 5.1 Network pruning Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (\\(TF\\)), regulatory element (\\(RE\\)) and target gene (\\(TG\\)). The thresholds at which the features are considered expressed are defined by the peak_cutoff and exp_cutoff arguments. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is \\(P(TF, RE) \\cdot P(TG)\\), and the number of trials is the total number of cells (or metacells if we set aggregateCells=TRUE), and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also \\(P(TF, RE) \\cdot P(TG)\\). The observed cell count for the active category is the number of cells jointly expressing all three elements (\\(n_{triple}\\)). pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, regulon = regulon, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05) ## pruning network with chi.sq tests using a regulon cutoff of pval&lt;0.05 ## pruning regulons pruned.regulon[,c(&quot;idxATAC&quot;, &quot;target&quot;, &quot;tf&quot;, &quot;corr&quot;, &quot;pval&quot;, &quot;stats&quot;)] ## DataFrame with 2687769 rows and 6 columns ## idxATAC target tf corr pval stats ## &lt;integer&gt; &lt;array&gt; &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 135 TNFRSF18 ADNP 0.754387 1.15983e-04 14.85689 ## 2 266 NADK ADNP 0.801851 2.14101e-07 26.90142 ## 3 991 CA6 ADNP 0.888973 2.09927e-03 9.46065 ## 4 1103 SLC25A33 ADNP -0.712694 1.01188e-03 10.80569 ## 5 1204 KIF1B ADNP 0.742701 3.18769e-21 89.42324 ## ... ... ... ... ... ... ... ## 2687765 155577 SCO2 ZXDC -0.543323 3.06126e-02 4.67456 ## 2687766 155577 TYMP ZXDC -0.544313 4.48926e-04 12.31669 ## 2687767 155577 ODF3B ZXDC -0.546970 6.00511e-03 7.54877 ## 2687768 157674 GCNA ZXDC 0.725899 4.54914e-02 4.00033 ## 2687769 158053 RADX ZXDC 0.689188 3.72567e-06 21.40105 5.1.1 Aggregate cells The pruneRegulon function also supports aggregation of cells into metacells. This can substantially speed up GRN refinement if the dataset is large (&gt;100K cells). Ideally, cell aggregation should also reduce noise while still maintaining the underlying biological signals. Since the data is less sparse after aggregation, users may want to adjust the feature cutoffs to better differentiate between cell aggregates with low and high expression. Setting exp_cutoff and peak_cutoff to NULL allows pruneRegulon to calculate the mean values for each feature and use these as the thresholds. pruned.regulon.aggr &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, regulon = regulon, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05, aggregateCells = TRUE, useDim = &quot;LSI_RNA&quot;, cellNum = 10, exp_cutoff = NULL, peak_cutoff = NULL) 5.2 Annotate with TF motifs So far, the gene regulatory network has been constructed exclusively from TF ChIP-seq data. Some users may want to further annotate regulatory elements with motifs. We provide an option to annotate peaks with motifs from the CIS_BP database. If no motifs are present for a particular factor (e.g., for co-factors or chromatin modifiers), NA is returned. If motifs exist for a factor and the regulatory element contains a motif, 1 is returned; if the regulatory element does not contain a motif, 0 is returned. Users can also provide their own motif annotation through the pwms argument. It is important to note that filtering for the presence of motifs removes a large fraction of the target genes. Motifs are often present in a small subset of the ChIP-seq peaks (can be as low as 10%). Second, indirect TF binding, possibly through its interaction partners, may have a true biological function. pruned.regulon.motif &lt;- addMotifScore(regulon = pruned.regulon, peaks = rowRanges(PeakMatrix), species = &quot;human&quot;, genome = &quot;hg38&quot;) # filter out the rows where TF motif is not found in the peak region pruned.regulon.motif &lt;- pruned.regulon.motif[which(pruned.regulon.motif$motif == 1),] pruned.regulon.motif[,c(&quot;idxATAC&quot;, &quot;target&quot;, &quot;tf&quot;, &quot;corr&quot;, &quot;p_val_peak_gene&quot;, &quot;pval&quot;, &quot;motif&quot;)] ## DataFrame with 204629 rows and 7 columns ## idxATAC target tf corr p_val_peak_gene pval ## &lt;integer&gt; &lt;array&gt; &lt;character&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 199 ACAP3 AHR -0.528286 0.03577411 2.44093e-02 ## 2 723 TNFRSF25 AHR 0.753414 0.02278260 3.79686e-08 ## 3 1100 SLC25A33 AHR -0.652737 0.00883763 2.41562e-08 ## 4 3937 AK2 AHR -0.500420 0.04646013 2.82830e-03 ## 5 3937 RNF19B AHR -0.711628 0.00321543 1.14941e-02 ## ... ... ... ... ... ... ... ## 204625 129706 HOXB2 ZSCAN16 0.653195 0.04945592 0.004321664 ## 204626 137004 MIDN ZSCAN16 0.721823 0.02935730 0.005802058 ## 204627 157055 CFP ZSCAN16 0.840835 0.00942513 0.009152565 ## 204628 33086 GTPBP8 ZSCAN4 0.751812 0.02303227 0.000171032 ## 204629 104541 ZNF84 ZSCAN4 0.711943 0.03174999 0.034884124 ## motif ## &lt;numeric&gt; ## 1 1 ## 2 1 ## 3 1 ## 4 1 ## 5 1 ## ... ... ## 204625 1 ## 204626 1 ## 204627 1 ## 204628 1 ## 204629 1 5.3 Annotate with log fold changes It is sometimes helpful to filter the regulons based on gene expression changes between two conditions. The addLogFC function is a wrapper around scran::findMarkers and adds extra columns of log changes to the regulon DataFrame. Users can specify the reference group in logFC_ref and comparison groups in logFC_condition. If these are not provided, log fold changes are calculated for every condition in the cluster labels against the rest of the conditions. # create logcounts GeneExpressionMatrix &lt;- scuttle::logNormCounts(GeneExpressionMatrix) # add log fold changes which are calculated by taking the difference of the log counts pruned.regulon &lt;- addLogFC(regulon = pruned.regulon, clusters = GeneExpressionMatrix$cell_type, expMatrix = GeneExpressionMatrix, assay.type = &quot;logcounts&quot;, pval.type = &quot;any&quot;, logFC_condition = unique(GeneExpressionMatrix$cell_type)) pruned.regulon[,c(&quot;idxATAC&quot;, &quot;target&quot;, &quot;tf&quot;, &quot;Memory CD8+ T.vs.rest.logFC&quot;, &quot;B.vs.rest.FDR&quot;)] ## DataFrame with 2687769 rows and 5 columns ## idxATAC target tf Memory CD8+ T.vs.rest.logFC ## &lt;integer&gt; &lt;array&gt; &lt;character&gt; &lt;numeric&gt; ## 1 135 TNFRSF18 ADNP -0.0906689 ## 2 266 NADK ADNP -0.3582261 ## 3 991 CA6 ADNP -0.3802831 ## 4 1103 SLC25A33 ADNP -0.2311624 ## 5 1204 KIF1B ADNP -0.3791885 ## ... ... ... ... ... ## 2687765 155577 SCO2 ZXDC -0.6694588 ## 2687766 155577 TYMP ZXDC -2.3157151 ## 2687767 155577 ODF3B ZXDC -0.3380033 ## 2687768 157674 GCNA ZXDC 0.0624762 ## 2687769 158053 RADX ZXDC 0.0456558 ## B.vs.rest.FDR ## &lt;numeric&gt; ## 1 2.12607e-23 ## 2 1.86039e-71 ## 3 2.38300e-91 ## 4 5.77745e-26 ## 5 2.15099e-133 ## ... ... ## 2687765 1.26531e-315 ## 2687766 0.00000e+00 ## 2687767 2.16867e-129 ## 2687768 5.28466e-04 ## 2687769 1.51853e-04 TFs do not necessarily alter the expression of the genes next to where they bind, and thus filtering for target genes that do show differential expression can help refine the regulons. Since we do not have a defined experimental setup in this dataset, we retain target genes that show differential expression in any cell types vs. the rest. FDR &lt;- pruned.regulon[,grep(&quot;rest.FDR&quot;, colnames(pruned.regulon ))] FDR &lt;- as.matrix(FDR) &lt; 0.05 FDR &lt;- apply(FDR,2, as.numeric) logFC &lt;- pruned.regulon[,grep(&quot;rest.logFC&quot;, colnames(pruned.regulon ))] logFC &lt;- abs(as.matrix(logFC)) &gt; 0.3 logFC &lt;- apply(logFC,2, as.numeric) logFC_FDR &lt;- FDR*logFC pruned.regulon.filtered &lt;- pruned.regulon[which(rowSums(logFC_FDR) &gt; 0), ] "],["calculation-of-the-tf-activity.html", "6 Calculation of the TF activity 6.1 Add weights 6.2 Calculate TF activity", " 6 Calculation of the TF activity Once we define the target genes of TFs by constructing the GRN, we can calculate the per cell TF activity by summing up the expression of the individual target genes. While it is reasonable to assume equal contribution from each target genes, epiregulon tries to estimate the weights of each target gene. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. 6.1 Add weights Epiregulon estimates the regulatory potential using one of the three measures: Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs. cells that do not. Correlation between TG and TF, or between TG and the product of TF and RE. Mutual information between TG and TF expression, or between TG and the product of TF and RE. Wilcoxon and correlation methods give both the magnitude and directionality of changes whereas mutual information is always positive. The correlation and mutual information statistics are computed on grouped pseudobulks following user-supplied cluster labels and yield a single weight across all clusters per each TF-RE-target triplet. In contrast, the Wilcoxon method can give a single weight across all cells or give cluster-specific weights if the users provide cluster labels. In general, we recommend computing a single weight across all cells because the data in totality provides the variability of target gene expression necessary for weights estimation. For example, we want to include both untreated and treated cells to gauge the effects of the treatment. Cluster-specific weights can be useful for inferring differential network connectivity (See section on Differential Network Analysis). The choice of weights method can have a profound effect on the estimate of TF activity. When the TF activity is directly correlated with TF expression, all methods tend to work quite well. However, there are scenarios such as drug treatment or CRISPR knockout when TF continues to be expressed despite post-translational inhibition of TF activity. Epiregulon was designed to handle scenarios where TF expression is decoupled from TF activity. In such cases, wilcox is the preferred choice. For a specific use case, see the Section @ref(weights_prostate) on a comparison between \"wilcox\" and \"corr\" methods. Refer to our manuscript for a more in-depth discussion of the biological scenarios compatible with each weight method. regulon.w &lt;- addWeights(regulon = pruned.regulon.filtered, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, method = &quot;wilcox&quot;, clusters = GeneExpressionMatrix$cell_type, useDim = &quot;LSI_RNA&quot;) ## adding weights using wilcoxon... regulon.w ## DataFrame with 1471785 rows and 49 columns ## idxATAC chr start end idxRNA target corr ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; ## 1 266 chr1 1686177 1686677 86 NADK 0.801851 ## 2 991 chr1 8947075 8947575 222 CA6 0.888973 ## 3 1204 chr1 10208525 10209025 248 KIF1B 0.742701 ## 4 1607 chr1 15296927 15297427 351 EFHD2 0.745672 ## 5 1889 chr1 17494138 17494638 418 ARHGEF10L 0.704022 ## ... ... ... ... ... ... ... ... ## 1471781 155369 chr22 49962306 49962806 23685 PIM3 0.715168 ## 1471782 155544 chr22 50524937 50525437 23714 TYMP -0.559642 ## 1471783 155577 chr22 50582163 50582663 23713 SCO2 -0.543323 ## 1471784 155577 chr22 50582163 50582663 23714 TYMP -0.544313 ## 1471785 155577 chr22 50582163 50582663 23715 ODF3B -0.546970 ## p_val_peak_gene FDR_peak_gene distance idxTF tf ## &lt;matrix&gt; &lt;matrix&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 0.0142937 0.488274 91791 1030 ADNP ## 2 0.0044733 0.421536 1207 1030 ADNP ## 3 0.0248840 0.526717 1778 1030 ADNP ## 4 0.0244471 0.526717 112459 1030 ADNP ## 5 0.0337058 0.547711 45058 1030 ADNP ## ... ... ... ... ... ... ## 1471781 0.0310426 0.542175 1534 1558 ZXDC ## 1471782 0.0268017 0.532791 4557 1558 ZXDC ## 1471783 0.0311916 0.542175 56559 1558 ZXDC ## 1471784 0.0309221 0.542175 52167 1558 ZXDC ## 1471785 0.0302867 0.539986 50086 1558 ZXDC ## pval stats qval CD14..Mono.vs.rest.FDR ## &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;numeric&gt; ## 1 2.14101e-07 26.90142 1.00000e+00 1.12227e-273 ## 2 2.09927e-03 9.46065 1.00000e+00 1.07642e-91 ## 3 3.18769e-21 89.42324 2.78453e-14 7.65618e-310 ## 4 4.50461e-03 8.06831 1.00000e+00 0.00000e+00 ## 5 1.17979e-03 10.52173 1.00000e+00 1.59755e-278 ## ... ... ... ... ... ## 1471781 0.000207305 13.76368 1 2.47662e-85 ## 1471782 0.019343447 5.47020 1 0.00000e+00 ## 1471783 0.030612624 4.67456 1 0.00000e+00 ## 1471784 0.000448926 12.31669 1 0.00000e+00 ## 1471785 0.006005115 7.54877 1 2.70505e-207 ## CD14..Mono.vs.rest.p.value CD14..Mono.vs.rest.logFC ## &lt;numeric&gt; &lt;numeric&gt; ## 1 3.58197e-275 0.453974 ## 2 1.13527e-92 -0.381033 ## 3 2.01501e-311 0.575687 ## 4 0.00000e+00 0.579157 ## 5 5.00688e-280 0.461821 ## ... ... ... ## 1471781 2.76970e-86 0.146817 ## 1471782 0.00000e+00 2.369751 ## 1471783 0.00000e+00 0.703607 ## 1471784 0.00000e+00 2.369751 ## 1471785 1.26648e-208 0.355839 ## Memory.CD4..T.vs.rest.FDR Memory.CD4..T.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; ## 1 2.05315e-154 6.44038e-156 ## 2 4.84933e-83 3.37369e-84 ## 3 5.24986e-87 3.43190e-88 ## 4 2.68684e-150 8.80424e-152 ## 5 6.39081e-272 8.43619e-274 ## ... ... ... ## 1471781 1.36783e-29 2.37244e-30 ## 1471782 0.00000e+00 0.00000e+00 ## 1471783 0.00000e+00 0.00000e+00 ## 1471784 0.00000e+00 0.00000e+00 ## 1471785 7.68600e-155 2.39621e-156 ## Memory.CD4..T.vs.rest.logFC B.vs.rest.FDR B.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 -0.375422 1.86039e-71 7.26021e-73 ## 2 -0.366194 2.38300e-91 7.00421e-93 ## 3 -0.374737 2.15099e-133 3.81343e-135 ## 4 -0.431623 4.46147e-126 8.60754e-128 ## 5 -0.458002 3.73172e-236 2.55008e-238 ## ... ... ... ... ## 1471781 0.0961699 3.02010e-09 6.92489e-10 ## 1471782 -2.2468525 0.00000e+00 0.00000e+00 ## 1471783 -0.6697767 1.26531e-315 4.89624e-318 ## 1471784 -2.2468525 0.00000e+00 0.00000e+00 ## 1471785 -0.3236477 2.16867e-129 4.01738e-131 ## B.vs.rest.logFC Monocytes.vs.rest.FDR Monocytes.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 -0.336361 1.61672e-15 1.49878e-16 ## 2 -0.381502 7.44419e-91 4.10638e-93 ## 3 -0.484800 1.52032e-18 1.15574e-19 ## 4 -0.461085 1.51226e-45 3.07532e-47 ## 5 -0.447276 3.34831e-11 4.30507e-12 ## ... ... ... ... ## 1471781 0.0715721 5.67114e-06 1.18378e-06 ## 1471782 -2.1374129 5.62567e-83 3.56642e-85 ## 1471783 -0.6915773 5.05831e-18 3.97441e-19 ## 1471784 -2.1374129 5.62567e-83 3.56642e-85 ## 1471785 -0.3240672 2.75961e-13 3.00060e-14 ## Monocytes.vs.rest.logFC Naive.CD8..T.vs.rest.FDR ## &lt;numeric&gt; &lt;numeric&gt; ## 1 0.310028 1.69311e-155 ## 2 -0.381965 1.88762e-92 ## 3 0.396732 2.67629e-197 ## 4 0.961398 4.65608e-199 ## 5 0.251675 3.66003e-274 ## ... ... ... ## 1471781 0.112528 1.56350e-18 ## 1471782 1.673328 0.00000e+00 ## 1471783 0.434858 0.00000e+00 ## 1471784 1.673328 0.00000e+00 ## 1471785 0.252888 2.29027e-184 ## Naive.CD8..T.vs.rest.p.value Naive.CD8..T.vs.rest.logFC ## &lt;numeric&gt; &lt;numeric&gt; ## 1 4.84635e-157 -0.381930 ## 2 1.02675e-93 0.381965 ## 3 5.40575e-199 -0.502247 ## 4 9.32800e-201 -0.488863 ## 5 4.62049e-276 -0.459590 ## ... ... ... ## 1471781 3.33572e-19 -0.0907983 ## 1471782 0.00000e+00 -2.3697514 ## 1471783 0.00000e+00 -0.6972445 ## 1471784 0.00000e+00 -2.3697514 ## 1471785 5.13517e-186 -0.3431860 ## FCGR3A..Mono.vs.rest.FDR FCGR3A..Mono.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; ## 1 1.28738e-75 3.94290e-77 ## 2 1.85410e-91 4.10631e-93 ## 3 4.51660e-48 2.62284e-49 ## 4 3.23963e-108 5.18334e-110 ## 5 1.60853e-40 1.13848e-41 ## ... ... ... ## 1471781 1.76882e-16 2.82085e-17 ## 1471782 4.02540e-319 4.74303e-322 ## 1471783 1.10843e-54 5.33866e-56 ## 1471784 4.02540e-319 4.74303e-322 ## 1471785 2.39081e-31 2.25381e-32 ## FCGR3A..Mono.vs.rest.logFC DC.vs.rest.FDR DC.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 0.613397 1.48721e-10 1.38321e-11 ## 2 -0.381965 5.36314e-91 4.10647e-93 ## 3 0.464689 1.15367e-05 1.85408e-06 ## 4 0.912985 6.92276e-55 1.00693e-56 ## 5 -0.294942 1.58551e-276 1.00079e-279 ## ... ... ... ... ## 1471781 0.113414 8.93729e-08 1.10692e-08 ## 1471782 2.407016 9.94254e-52 1.54440e-53 ## 1471783 0.529519 3.60704e-33 9.35467e-35 ## 1471784 2.407016 9.94254e-52 1.54440e-53 ## 1471785 0.272149 9.20085e-16 5.72181e-17 ## DC.vs.rest.logFC Naive.CD4..T.vs.rest.FDR Naive.CD4..T.vs.rest.p.value ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 0.467425 4.93457e-177 9.94010e-179 ## 2 -0.381965 1.74410e-35 2.12424e-36 ## 3 0.325063 2.32559e-185 4.42934e-187 ## 4 -1.224596 5.94247e-203 1.00949e-204 ## 5 -0.461821 3.20265e-268 3.76183e-270 ## ... ... ... ... ## 1471781 0.379087 7.08993e-15 1.55446e-15 ## 1471782 -2.022347 0.00000e+00 0.00000e+00 ## 1471783 -0.635970 0.00000e+00 0.00000e+00 ## 1471784 -2.022347 0.00000e+00 0.00000e+00 ## 1471785 -0.281375 9.44166e-179 1.87859e-180 ## Naive.CD4..T.vs.rest.logFC Memory.CD8..T.vs.rest.FDR ## &lt;numeric&gt; &lt;numeric&gt; ## 1 -0.402145 4.83824e-93 ## 2 -0.265716 2.07278e-90 ## 3 -0.499501 5.15609e-58 ## 4 -0.498699 2.89359e-93 ## 5 -0.456728 1.08094e-264 ## ... ... ... ## 1471781 0.0641851 4.05854e-14 ## 1471782 -2.3462477 0.00000e+00 ## 1471783 -0.7036065 1.78609e-274 ## 1471784 -2.3462477 0.00000e+00 ## 1471785 -0.3415591 1.03392e-165 ## Memory.CD8..T.vs.rest.p.value Memory.CD8..T.vs.rest.logFC ## &lt;numeric&gt; &lt;numeric&gt; ## 1 1.51369e-94 -0.358226 ## 2 6.76934e-92 -0.380283 ## 3 2.82016e-59 -0.379189 ## 4 9.00523e-95 0.678123 ## 5 7.20865e-267 -0.456896 ## ... ... ... ## 1471781 7.72992e-15 -0.0922453 ## 1471782 0.00000e+00 -2.3157151 ## 1471783 1.09308e-276 -0.6694588 ## 1471784 0.00000e+00 -2.3157151 ## 1471785 1.46415e-167 -0.3380033 ## NK.vs.rest.FDR NK.vs.rest.p.value NK.vs.rest.logFC NA.vs.rest.FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 1.19826e-65 3.53184e-67 -0.355368 1.34418e-273 ## 2 4.31779e-89 8.81618e-91 -0.379363 4.29660e-92 ## 3 7.20212e-67 2.07735e-68 -0.450352 9.36515e-310 ## 4 2.95876e-118 4.05187e-120 1.421655 0.00000e+00 ## 5 1.02006e-264 3.63929e-267 -0.457695 3.83279e-278 ## ... ... ... ... ... ## 1471781 9.37019e-18 1.10551e-18 -0.110243 2.71442e-85 ## 1471782 2.18585e-267 7.37856e-270 -2.218151 4.85186e-06 ## 1471783 9.48323e-192 5.85577e-194 -0.665203 3.69027e-01 ## 1471784 2.18585e-267 7.37856e-270 -2.218151 4.85186e-06 ## 1471785 1.38920e-89 2.80981e-91 -0.321178 3.12869e-207 ## NA.vs.rest.p.value NA.vs.rest.logFC ## &lt;numeric&gt; &lt;numeric&gt; ## 1 3.58197e-275 -0.453974 ## 2 4.10700e-93 -0.381965 ## 3 2.01501e-311 -0.575687 ## 4 0.00000e+00 -0.579157 ## 5 1.00138e-279 -0.461821 ## ... ... ... ## 1471781 2.76970e-86 -0.146817 ## 1471782 1.65084e-06 -2.121123 ## 1471783 1.89547e-01 -0.531398 ## 1471784 1.65084e-06 -2.121123 ## 1471785 1.26648e-208 -0.355839 ## weight ## &lt;matrix&gt; ## 1 0.0583992: 0.00000000:-0.00307422:... ## 2 0.0311224:-0.00137646:-0.00249145:... ## 3 0.1032210: 0.01156464: 0.03634468:... ## 4 0.0333821: 0.00000000: 0.00137167:... ## 5 0.0340038:-0.01020603: 0.01396996:... ## ... ... ## 1471781 0.0368769: 0.02603271: 0.03120368:... ## 1471782 0.0258094: 0.00679141:-0.00776715:... ## 1471783 0.0262938:-0.01485703: 0.00423260:... ## 1471784 0.0532873:-0.00953433: 0.00931223:... ## 1471785 0.0311489:-0.05049477: 0.00802140:... 6.1.1 Aggregate cells As with the pruneRegulon function, cells can be aggregated into metacells using the aggregateCells argument in addWeights. Use this option only with the Wilcoxon method, since the other two methods already incorporate cell aggregation. By default, the function generates aggregates containing an average of 10 cells. However, the exact number may vary across metacells, depending on how single cells are distributed in the reduced dimensionality space. Refer to the cell aggregation section in Regulation Refinement for additional information (Section @ref(cell_aggregation)). regulon.w.aggr &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, method = &quot;wilcox&quot;, clusters = GeneExpressionMatrix$cell_type, aggregateCells = TRUE, useDim = &quot;LSI_RNA&quot;, exp_cutoff=NULL, peak_cutoff=NULL) 6.1.2 Using chromatin accessibility data The corr and MI methods for calculating weights by default ignore information about chromatin accessibility. However, it is possible to incorporate this modality into the calculations by setting the tf_re.merge argument to TRUE. This adds an additional step to the procedure, in which transcription factor expression is multiplied by chromatin accessibility. Therefore, expression is reduced to zero if the corresponding element is not accessible. The TF-RE product is calculated at the level of aggregated cells, mitigating the effect of sparsity, which affects ATAC-seq data more than gene expression. See the Section @ref(weights_prostate) for an example of using the tf_re.merge argument. 6.2 Calculate TF activity Finally, the activity for a specific TF in each cell is computed by averaging the expression of target genes weighted by the test statistics of choice as explained in the addWeights section. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weights_i\\] where \\(y\\) is the activity of a TF for a cell, \\(n\\) is the total number of targets for a TF, \\(x_i\\) is the log count expression of target \\(i\\) where \\(i\\) in {1,2,…,n} and \\(weights_i\\) is the weight of TF - target \\(i\\) score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, exp_assay = &quot;normalizedCounts&quot;) score.combine[1:5,1:5] ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## PBMC_10k#GGTTGCATCCTGGCTT-1 PBMC_10k#GGTTGCGGTAAACAAG-1 ## ADNP 0.19779780 0.1531687 ## AEBP2 0.07012385 0.1433285 ## AFF1 0.17376423 0.1661146 ## AFF4 0.20355110 0.1979733 ## AGO1 0.16440461 0.1428504 ## PBMC_10k#TGTTCCTCATAAGTTC-1 PBMC_10k#CGACTAAGTAACGGGA-1 ## ADNP 0.1945887 0.1174226 ## AEBP2 0.1422228 0.1678583 ## AFF1 0.2037083 0.1094581 ## AFF4 0.2451325 0.1282145 ## AGO1 0.1625822 0.1039042 ## PBMC_10k#CTGCTCCCAAGGTCCT-1 ## ADNP 0.2076910 ## AEBP2 0.1733083 ## AFF1 0.2112685 ## AFF4 0.2525639 ## AGO1 0.1679543 "],["network-analysis.html", "7 Network analysis 7.1 Differential TF activity 7.2 Visualize TF activities 7.3 Geneset enrichment 7.4 Differential network analysis 7.5 Find interaction partners", " 7 Network analysis The epiregulon.extra package provides tools for downstream analysis of gene regulatory networks (GRNs) and TF activity. It enables users to identify differential TF activity, visualize these differences, construct differential graphs that highlight changes in GRN topology, and discover potential interaction partners by identifying overlapping regulons. 7.1 Differential TF activity We can determine which TFs exhibit differential activities across cell clusters/groups via the findDifferentialActivity function. This function is a wrapper around the findMarkers function from scran package. library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = GeneExpressionMatrix$cell_type, pval.type = &quot;some&quot;, direction = &quot;up&quot;, logvalues = FALSE) markers getSigGenes compiles the group-wise tests into a single dataframe and enables users to select the top differential TFs based on their desired cutoffs. markers.sig &lt;- getSigGenes(markers, topgenes = 5, direction = &quot;up&quot; ) markers.sig 7.2 Visualize TF activities Epiregulon also provides the option for visualizing the inferred TF activities. options(ggrastr.default.dpi=300) tfs_interest &lt;- c( &quot;EBF1&quot;,&quot;TBX21&quot;,&quot;EOMES&quot;,&quot;SPI1&quot;) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP_RNA&quot;, nrow=2, ncol=2, point_size=0.1, label = &quot;cell_type&quot;, rasterise = TRUE) We can compare the activity with gene expression of the same TFs. plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP_RNA&quot;, nrow=2, ncol=2, legend.label = &quot;Gex&quot;, colors = c(&quot;grey&quot;,&quot;blue&quot;), point_size=0.1, rasterise = TRUE) We can also generate violin plots to visualize TF activity. plotActivityViolin(activity_matrix = score.combine, tf = tfs_interest, clusters = GeneExpressionMatrix$cell_type, legend.label = &quot;Gex&quot;, nrow=2, ncol=2, boxplot = TRUE) We generate violin plots to visualize TF gene expression. plotActivityViolin(activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, clusters = GeneExpressionMatrix$cell_type, nrow=2, ncol=2, legend.label = &quot;gene expression&quot;, boxplot=TRUE) We can visualize the different TFs in a bubble plot: plotBubble(activity_matrix = score.combine, tf = tfs_interest, clusters = GeneExpressionMatrix$cell_type, pval.type = &quot;some&quot;, direction = &quot;up&quot;, logvalues = FALSE) We visualize the top differential TFs based on activity. plotBubble(activity_matrix = score.combine, tf = markers.sig$tf, GeneExpressionMatrix$cell_type, pval.type = &quot;some&quot;, direction = &quot;up&quot;, logvalues = FALSE) 7.3 Geneset enrichment Sometimes we are interested in knowing what pathways are enriched in the regulon of a particular TF. We can perform gene set enrichment using the enricher function from clusterProfiler. Here we first download Hallmark and C2 signatures from MSigDB and then perform gene set enrichment of the known lineage factors. As expected, EBF1 shows enrichment for pathways associated with B cells, and TBX21 with T cells, EOMES with NK cells, and SPI1 with myeloid cells. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot; ) C2 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C2&quot;, gene.id.type = &quot;SYMBOL&quot; ) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H, C2) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = tfs_interest, regulon = regulon.w, weight = &quot;weight&quot;, weight_cutoff = 0.1, genesets = gs.list) #plot results enrichPlot(results = enrichresults, ncol=2) 7.4 Differential network analysis A second approach to investigate differential TF activity is to compare the weights of the target genes between groups. In this example, we are interested to compare the networks of B cells and CD4 memory T cells. We build an edge subtracted graph and calculate the degree centrality of the subtracted graph. We normalize centrality using the default square root function. The top 5 most positive TFs represent lineage factors more active in B cells whereas the bottom 5 TFs present lineage factors enriched in CD4+ memory T cells. We successfully identified the B factors EBF1, PAX5 and IRF4. The putative CD4 memory T cells factors are less understood and remain to be validated. # construct a graph of the CD4.M and NK cells respectively CD4.M_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;Memory CD4+ T&quot;) B_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;B&quot;) # construct a difference graph diff_graph &lt;- buildDiffGraph(B_network,CD4.M_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table, 10), tail(rank_table, 10)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5, max.overlaps = Inf) + theme_classic() + ggtitle (&quot;differential TFs (B-CD4.M) ranked by degree centrality&quot;) 7.5 Find interaction partners Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of regulons and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to EBF1, and we successfully identify PAX5 as the most similar TF. Both PAX5 and EBF1 are important factors for B cell development (https://www.nature.com/articles/ni.2641). library(ggplot2) # construct a graph of the preB cells B_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;B&quot;) ## Building graph using weight as edge weights # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(B_network) # Focus on EBF1 similarity_score_EBF1 &lt;- similarity_score[, &quot;EBF1&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_EBF1, decreasing = TRUE),20), TF = names(head(sort(similarity_score_EBF1, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;EBF1 similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by the average edge weights of the permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(B_network, &quot;EBF1&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_EBF1),] diff_matrix &lt;- similarity_score_EBF1-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted EBF1 similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_EBF1})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## PAX5 BCL11A POU2F2 RELB MTA3 TCF3 TCF4 KMT2D EED MEF2A BCLAF1 ## 0 0 0 0 0 0 0 0 0 0 0 ## NBN ETV6 ATF7 NFATC3 NFIC SKIL BCOR FOXO1 NIPBL ## 0 0 0 0 0 0 0 0 0 "],["archr-workflow-and-different-weight-methods.html", "8 ArchR workflow and different weight methods 8.1 Prepare data 8.2 Load ArchR project 8.3 Retrieve matrices from ArchR project 8.4 Retrieve bulk TF ChIP-seq binding sites 8.5 Link ATAC-seq peaks to target genes 8.6 Add TF motif binding to peaks 8.7 Generate regulons 8.8 (Optional) Annotate with TF motifs 8.9 Prune network 8.10 Add Weights 8.11 Calculate TF activity 8.12 Perform differential activity 8.13 Visualize the results 8.14 Geneset enrichment 8.15 Differential network analysis {diff_network}", " 8 ArchR workflow and different weight methods In this chapter, we illustrate the epiregulon workflow starting from an ArchR project and compare the different weight estimation methods. The dataset consists of unpaired scATACseq/scRNAseq of parental LNCaP cells treated with DMSO, Enzalutamide and Enza resistant cells. The dataset was taken from Taavitsainen et al GSE168667 and GSE168668. 8.1 Prepare data Please refer to the full ArchR manual for instructions Before running Epiregulon, the following analyses need to be completed: Obtain a peak matrix on scATACseq by using addGroupCoverages &gt; addReproduciblePeakSet &gt; addPeakMatrix. See chapter 10 from ArchR manual RNA-seq integration. For unpaired scATAC-seq, use addGeneIntegrationMatrix. See chapter 8 from ArchR manual For multiome data, use addGeneExpressionMatrix. See multiome tutorial Perform dimensionality reduction from with either single modalities or joint scRNAseq and scATACseq using addCombinedDims 8.2 Load ArchR project The data processed in ArchR is available at as compressed file containing ArchR project. library(ArchR) temp_path &lt;- tempdir() download.file(&quot;http://research-pub.gene.com/oncbx/yaox/Epiregulon/GSE168667.tar.gz&quot;, file.path(temp_path, &quot;GSE168667.tar.gz&quot;)) untar(tarfile=file.path(temp_path, &quot;GSE168667.tar.gz&quot;), exdir = temp_path) archR_project_path &lt;- file.path(temp_path, &quot;multiome&quot;) proj &lt;- loadArchRProject(path = archR_project_path, showLogo = FALSE) We will use the joint reducedDims - “LSI_Combined” and joint embeddings - “UMAP_Combined” head(getReducedDims(proj, reducedDims = &quot;iLSI_Combined&quot;)[,1:5]) ## LSI1 LSI2 LSI3 LSI4 ## SRR13927735#TTATGTCTCCAGGTAT-1 -2.713935 -0.3677949 -0.4484238 -0.30645138 ## SRR13927735#TATTGCTCATCAGAAA-1 -2.642781 -0.2767556 -0.9142714 -0.19675812 ## SRR13927735#TTCGATTGTAGGGTTG-1 -2.322865 -0.1543080 -1.4106049 -0.08891276 ## SRR13927735#CATTCATTCGGATGTT-1 -2.572976 -0.1917188 -1.0464294 -0.12660121 ## SRR13927735#ACGTTAGGTCAACTGT-1 -2.478552 -0.1776639 -1.1037295 -0.22976613 ## SRR13927735#AAATGCCCAGCAATGG-1 -2.595352 -0.3803464 -0.7770309 -0.52431765 ## LSI5 ## SRR13927735#TTATGTCTCCAGGTAT-1 -0.046845365 ## SRR13927735#TATTGCTCATCAGAAA-1 0.075746940 ## SRR13927735#TTCGATTGTAGGGTTG-1 0.019873276 ## SRR13927735#CATTCATTCGGATGTT-1 0.009947438 ## SRR13927735#ACGTTAGGTCAACTGT-1 -0.150097539 ## SRR13927735#AAATGCCCAGCAATGG-1 -0.243074591 head(getEmbedding(proj, embedding = &quot;UMAP_Combined&quot;)) ## iLSI_Combined#UMAP_Dimension_1 ## SRR13927735#TTATGTCTCCAGGTAT-1 -9.622903 ## SRR13927735#TATTGCTCATCAGAAA-1 -9.360211 ## SRR13927735#TTCGATTGTAGGGTTG-1 -8.617347 ## SRR13927735#CATTCATTCGGATGTT-1 -9.285448 ## SRR13927735#ACGTTAGGTCAACTGT-1 -8.809260 ## SRR13927735#AAATGCCCAGCAATGG-1 -9.261216 ## iLSI_Combined#UMAP_Dimension_2 ## SRR13927735#TTATGTCTCCAGGTAT-1 -0.2908237 ## SRR13927735#TATTGCTCATCAGAAA-1 -0.2892935 ## SRR13927735#TTCGATTGTAGGGTTG-1 -0.2154103 ## SRR13927735#CATTCATTCGGATGTT-1 -0.3267481 ## SRR13927735#ACGTTAGGTCAACTGT-1 -0.2168703 ## SRR13927735#AAATGCCCAGCAATGG-1 0.3200356 8.3 Retrieve matrices from ArchR project Retrieve gene expression and peak matrix from the ArchR project GeneExpressionMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;GeneIntegrationMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) PeakMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;PeakMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) If we extract the gene expression from matrix, it will be in the form of RangedSummarizedExperiment. We can make use of ArchRMatrix2SCE to convert gene expression matrix to a SingleCellExperiment object. It’s also important to note that gene expression from ArchR is library size normalized (not logged). library(epiregulon.archr) GeneExpressionMatrix &lt;- ArchRMatrix2SCE(GeneExpressionMatrix, rename = &quot;normalizedCounts&quot;) rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name We rename the assay name of the PeakMatrix as counts. PeakMatrix &lt;- ArchRMatrix2SCE(PeakMatrix, rename = &quot;counts&quot;) Transfer embeddings from ArchR project to SingleCellExperiment for visualization reducedDim(GeneExpressionMatrix, &quot;UMAP_Combined&quot;) &lt;- getEmbedding(ArchRProj = proj, embedding = &quot;UMAP_Combined&quot;, returnDF = TRUE)[colnames(GeneExpressionMatrix),] # add cell label GeneExpressionMatrix$label &lt;- GeneExpressionMatrix$Cells GeneExpressionMatrix$label[GeneExpressionMatrix$Treatment == &quot;enzalutamide 48h&quot;] &lt;- &quot;LNCaP–ENZ48&quot; GeneExpressionMatrix$label &lt;- factor(GeneExpressionMatrix$label, levels = c(&quot;LNCaP&quot;, &quot;LNCaP–ENZ48&quot;, &quot;LNCaP RES-A&quot;, &quot;LNCaP RES-B&quot;)) Visualize singleCellExperiment by UMAP scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_Combined&quot;, text_by = &quot;label&quot;, colour_by = &quot;label&quot;) 8.4 Retrieve bulk TF ChIP-seq binding sites First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq. Currently, human genomes hg19 and hg38 and mouse mm10 are available. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 8.5 Link ATAC-seq peaks to target genes Next, we compute peak to gene correlations using the addPeak2GeneLinks function from the ArchR package. The user would need to supply a path to an ArchR project already containing peak and gene matrices, as well as Latent semantic indexing (LSI) dimensionality reduction. p2g &lt;- calculateP2G(ArchR_path = archR_project_path, useDim = &quot;iLSI_Combined&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, threads = 1) ## Using ArchR to compute peak to gene links... p2g ## DataFrame with 16883 rows and 8 columns ## idxATAC chr start end idxRNA target ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 15 chr1 912762 913262 7 NOC2L ## 2 25 chr1 920261 920761 7 NOC2L ## 3 25 chr1 920261 920761 8 KLHL17 ## 4 32 chr1 927728 928228 7 NOC2L ## 5 32 chr1 927728 928228 8 KLHL17 ## ... ... ... ... ... ... ... ## 16879 210643 chrX 154542721 154543221 23496 CH17-340M24.3 ## 16880 210643 chrX 154542721 154543221 23501 LAGE3 ## 16881 210643 chrX 154542721 154543221 23506 IKBKG ## 16882 210643 chrX 154542721 154543221 23509 DKC1 ## 16883 210665 chrX 154815200 154815700 23515 F8 ## Correlation distance ## &lt;numeric&gt; &lt;numeric&gt; ## 1 0.543478 46297 ## 2 0.602633 38798 ## 3 0.597510 40076 ## 4 0.660584 31331 ## 5 0.532240 32609 ## ... ... ... ## 16879 0.540888 114492 ## 16880 0.708942 63714 ## 16881 0.517261 1716 ## 16882 0.557412 219771 ## 16883 0.554537 211490 8.6 Add TF motif binding to peaks The next step is to add the TF motif binding information by overlapping the regions of the peak matrix with the bulk chip-seq database. The user can supply an ArchR project path and this function will retrieve the peak matrix, or a peakMatrix in the form of a Granges object or RangedSummarizedExperiment. overlap &lt;- addTFMotifInfo(archR_project_path = archR_project_path, grl = grl, p2g = p2g) ## Successfully loaded ArchRProject! ## Computing overlap... ## Success! 8.7 Generate regulons A long format data frame, representing the inferred regulons, is then generated. Three columns are important: transcription factors (tf) target genes (target) peak to gene correlation between tf and target gene (corr) regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 2612934 rows and 10 columns ## idxATAC chr start end idxRNA target corr ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;numeric&gt; ## 1 15 chr1 912762 913262 7 NOC2L 0.543478 ## 2 15 chr1 912762 913262 7 NOC2L 0.543478 ## 3 15 chr1 912762 913262 7 NOC2L 0.543478 ## 4 15 chr1 912762 913262 7 NOC2L 0.543478 ## 5 15 chr1 912762 913262 7 NOC2L 0.543478 ## ... ... ... ... ... ... ... ... ## 2612930 210665 chrX 154815200 154815700 23515 F8 0.554537 ## 2612931 210665 chrX 154815200 154815700 23515 F8 0.554537 ## 2612932 210665 chrX 154815200 154815700 23515 F8 0.554537 ## 2612933 210665 chrX 154815200 154815700 23515 F8 0.554537 ## 2612934 210665 chrX 154815200 154815700 23515 F8 0.554537 ## distance idxTF tf ## &lt;numeric&gt; &lt;integer&gt; &lt;character&gt; ## 1 46297 4 AGO1 ## 2 46297 11 ARID4B ## 3 46297 12 ARID5B ## 4 46297 30 BCOR ## 5 46297 36 BRD4 ## ... ... ... ... ## 2612930 211490 1146 NFRKB ## 2612931 211490 1175 POLR2H ## 2612932 211490 1273 ZBTB8A ## 2612933 211490 1456 ZNF589 ## 2612934 211490 1457 ZNF592 8.8 (Optional) Annotate with TF motifs In this example, we will filter the regulon for the presence of transcription factor motifs in a peak (see Section @ref(motif_score)) and continue the workflow with the regulon.motif object. However, if the user prefers to retain all target genes, including REs without motifs, they may proceed with regulon. regulon.motif &lt;- addMotifScore(regulon = regulon, ArchProj = proj ) ## retrieving motif information from ArchR project # retain only TF-RE-TG triplets with motifs regulon.motif &lt;- regulon.motif[which(regulon.motif$motif ==1),] 8.9 Prune network We will use pruneRegulon function to restict the downstream analysis to more reliable GRN connections. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section @ref(diff_network) to learn more on the differential networks. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon = regulon.motif, clusters = GeneExpressionMatrix$label, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05) 8.10 Add Weights Before we calculate AR activity, we will first visualize its expression and show that enzalutamide does not decrease AR expression. library(epiregulon.extra) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix), tf = &quot;AR&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;gene expression&quot;) Then we extract the chromVarMatrix from ArchR project and then visualize the chromatin accessibility at AR bound sites. We can see that 48 hour of enzalutamide treatment reduced chromatin accessibility at AR bound sites chromVarMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;MotifMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1 ) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(chromVarMatrix, &quot;z&quot;), tf = &quot;AR_689&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;chromVar&quot;) Next, we are going to compare 3 different weight methods. In the first method, the wilcoxon test compares target gene expression in cells meeting both the TF expression and accessibility cutoffs vs cells failing either the TF expression or/and accessibility cutoffs. Next, we try out the correlation method which comes in two flavors. When tf_re.merge = FALSE, weight is computed on the correlation of target gene expression vs TF gene expression. When tf_re.merge = TRUE, weight is computed on the correlation of target gene expression vs the product of TF expression and chromatin accessibility at TF-bound regulatory elements. regulon.w.wilcox &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;wilcoxon&quot;) ## adding weights using wilcoxon... regulon.w.corr &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;) ## adding weights using corr... ## calculating average expression across clusters... ## computing weights... regulon.w.corr.re &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;, tf_re.merge = TRUE) ## adding weights using corr... ## calculating average expression across clusters... ## computing weights... 8.11 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging the weighted expressions of target genes linked to the TF. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weight_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,…,n} \\(weight_i\\) is the weight of TF and target i We calculate three different activities corresponding to the different weighted regulons score.combine.wilcox &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, regulon = regulon.w.wilcox, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = ## &quot;normalizedCounts&quot;, : Argument &#39;method&#39; to calculateActivity was deprecated as ## of epiregulon version 2.0.0 ## calculating TF activity from regulon using weightedMean ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, : The weight column contains multiple subcolumns but no cluster information was provided. ## Using first column to compute activity... ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... score.combine.corr &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, regulon = regulon.w.corr, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = ## &quot;normalizedCounts&quot;, : Argument &#39;method&#39; to calculateActivity was deprecated as ## of epiregulon version 2.0.0 ## calculating TF activity from regulon using weightedMean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... score.combine.corr.re &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, regulon = regulon.w.corr.re, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = ## &quot;normalizedCounts&quot;, : Argument &#39;method&#39; to calculateActivity was deprecated as ## of epiregulon version 2.0.0 ## calculating TF activity from regulon using weightedMean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... We visualize the different activities side by side. library(epiregulon.extra) plotActivityViolin(activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by wilcoxon&quot;) plotActivityViolin(activity_matrix = score.combine.corr, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF vs TG&quot;) plotActivityViolin(activity_matrix = score.combine.corr.re, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF*RE vs TG&quot;) In this case, activity calculated from correlation based on TF and TG expression is clearly wrong because we see increased AR activity after Enzalutamide treatment despite it being an AR antagonist. Therefore, for drug treatment which often decouples TF gene expression and its activity, it is important to take into consideration both TF gene expression and RE chromatin accessibility; the latter may be a better indicator of TF function if the TF has an effect on the chromatin accessibility. In this case, the recommended methods are either wilcox or corr with tf_re.merge = TRUE. The astute users could however detect a difference in the prediction of the AR activity in the resistant clones “RES-A” and “RES-B” with respect to the parental “LNCaP” between the two methods. For example, the corr with tf_re.merge = TRUE shows increased AR activity in “RES-B” compared to “LNCaP” because “RES-B” shows increased AR expression. In contrast, the wilcoxon method did not predict an increase in AR activity in “RES-B” because “RES-B” still shows reduced chromatin accessibility compared to “LNCaP”. Since wilcoxon takes into account the co-occurrence of both TF gene expression and RE chromatin accessibility, this method does not predict an overall increase in AR activity. In the absence of the ground truth, it is difficult to judge which method is superior. Therefore, it is always crucial to validate key findings with additional empirical evidence. The most important disclaimer we wish to make is that all predictions by epiregulon should be robustly tested experimentally. 8.12 Perform differential activity For the remaining steps, we continue with activity derived from the wilcoxon method. markers &lt;- findDifferentialActivity(activity_matrix = score.combine.wilcox, clusters = GeneExpressionMatrix$label, pval.type = &quot;some&quot;, direction = &quot;any&quot;, test.type = &quot;t&quot;, logvalues = FALSE ) markers ## List of length 4 ## names(4): LNCaP LNCaP–ENZ48 LNCaP RES-A LNCaP RES-B Take the top differential TFs. Summary represents comparison of cells in the indicated class vs all the remaining cells. markers.sig &lt;- getSigGenes(markers, direction = &quot;any&quot;, topgenes = 2 ) ## Using a cutoff of 0.046 for class LNCaP for direction equal to any ## Using a cutoff of 0.031 for class LNCaP–ENZ48 for direction equal to any ## Using a cutoff of 0.04 for class LNCaP RES-A for direction equal to any ## Using a cutoff of 0.04 for class LNCaP RES-B for direction equal to any markers.sig ## p.value FDR summary.diff class tf ## 1 0 0 0.06499576 LNCaP HES4 ## 3 0 0 0.05017633 LNCaP SPDEF ## 11 0 0 0.05137746 LNCaP–ENZ48 HES4 ## 31 0 0 -0.03602301 LNCaP–ENZ48 NR2F6 ## 12 0 0 0.07346485 LNCaP RES-A ATF5 ## 2 0 0 -0.04162267 LNCaP RES-A ETV1 ## 21 0 0 0.04793834 LNCaP RES-B JUN ## 32 0 0 0.04482560 LNCaP RES-B NR2F2 8.13 Visualize the results First visualize the known differential TFs by bubble plot plotBubble(activity_matrix = score.combine.wilcox, tf = c(&quot;AR&quot;,&quot;FOXA1&quot;, &quot;MYC&quot;,&quot;JUN&quot;), pval.type = &quot;some&quot;, direction = &quot;up&quot;, clusters = GeneExpressionMatrix$label, logvalues = FALSE) Then visualize the most differential TFs by clusters plotBubble(activity_matrix = score.combine.wilcox, tf = unique(markers.sig$tf), pval.type = &quot;some&quot;, direction = &quot;any&quot;, clusters = GeneExpressionMatrix$label, logvalues = FALSE) Visualize the known differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize the newly discovered differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = markers.sig$tf[1:4], dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize regulons by heatmap rowData(GeneExpressionMatrix) &lt;- NULL plotHeatmapRegulon(sce=GeneExpressionMatrix, tfs= c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon=regulon.w.wilcox, regulon_cutoff=0.1, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;normalizedCounts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) plotHeatmapActivity(activity=score.combine.wilcox, sce=GeneExpressionMatrix, tfs=rownames(score.combine.wilcox), downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name = &quot;transcription factor activity&quot;, column_title_rot = 45) 8.14 Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H,C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = c(&quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## AR ## FOXA1 ## MYC ## JUN #plot results enrichPlot(results = enrichresults, ncol = 2) We can visualize the genesets of known factors as a network plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) We can visualize the genesets of differential factors as a network enrichresults &lt;- regulonEnrich(TF = markers.sig$tf, regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## HES4 ## SPDEF ## HES4 ## NR2F6 ## ATF5 ## ETV1 ## JUN ## NR2F2 plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) 8.15 Differential network analysis {diff_network} In addition to looking at the summed TF activity, a second approach to investigate differential TF activity is to compare and contrast target genes or network topology. In this example, we know that AR is downregulated in the Enzalutamide treated cells compared to parental LNCaP. plotDiffNetwork(regulon.w.wilcox, cutoff = 0, tf = c(&quot;AR&quot;), weight = &quot;weight&quot;, clusters = c(&quot;LNCaP&quot;,&quot;LNCaP–ENZ48&quot;), layout = &quot;stress&quot;) ## Building graph using weight as edge weights We perform edge subtracted graph between two conditions and rank TFs by degree centrality. In this example, positive centrality indicates higher activity in parental LNCaP and negative centrality indicates higher activity in Enzalutamide treated cells. # construct a graph of the parental and enzalutamide treated cells respectively LNCaP_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaP&quot;) ## Building graph using weight as edge weights ENZ_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaP–ENZ48&quot;) ## Building graph using weight as edge weights # construct a difference graph diff_graph &lt;- buildDiffGraph(LNCaP_network, ENZ_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table,5), tail(rank_table,5)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5) + theme_classic() + ggtitle (&quot;differential TFs (LNCaP-ENZ) ranked by degree centrality&quot;) Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of the targets genes for all the TFs and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to AR. library(igraph) diff_graph_filter &lt;- subgraph.edges(diff_graph, E(diff_graph)[E(diff_graph)$weight&gt;0], del=TRUE) # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(diff_graph_filter) # Focus on AR similarity_score_AR &lt;- similarity_score[, &quot;AR&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_AR, decreasing = TRUE),20), TF = names(head(sort(similarity_score_AR, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to SPI1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;AR similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(diff_graph_filter, &quot;AR&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_AR),] diff_matrix &lt;- similarity_score_AR-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to AR topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted AR similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_AR})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## JUND MYC FOXA1 HOXB13 NFIC CEBPB MAZ XBP1 CEBPG GATA2 REST ## 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.01 0.00 0.00 0.01 ## CTCF FOXP1 NFIX ATF4 ZNF148 NFIB EHF ETV1 YY1 ## 0.00 0.01 0.00 0.03 0.02 0.00 0.00 0.00 0.00 "],["single-modality-scrna-seq-only.html", "9 Single modality: scRNA-seq only 9.1 Load regulon 9.2 Load scRNA-seq data 9.3 Calculate activity 9.4 Perform differential activity 9.5 Visualize activity 9.6 Pathway enrichment", " 9 Single modality: scRNA-seq only Epiregulon also supports transcription factor activity inference when users only have scRNA-seq. After all, multiome or scATAC-seq data is still relatively rare. To enable TF activity inference on scRNA-seq, users can supply a pre-constructed gene regulatory network. Dorothea provides both human and mouse pre-constructed gene regulatory networks based on curated experimental and computational data. In this vignette, we bypass the regulon construction step and go straight to calculate TF activity from a Dorothea GRN. 9.1 Load regulon Dorothea assigns confidence level to its regulons with A being the most confident (i.e. supported by multiple lines of evidence) and E being the least confident. library(dorothea) data(dorothea_mm, package = &quot;dorothea&quot;) regulon &lt;- dorothea_mm #known tfs genes_to_plot &lt;- c(&quot;Foxa1&quot;, &quot;Neurod1&quot;,&quot;Pdx1&quot;,&quot;Arx&quot;) 9.2 Load scRNA-seq data We download the raw counts of a mouse pancreas data set from scRNAseq. We add normalized logcounts, perform dimension reduction and visualize the embeddings using scater. library(scRNAseq) library(scater) sce &lt;- BaronPancreasData(&#39;mouse&#39;) sce &lt;- logNormCounts(sce) sce &lt;- runPCA(sce) sce &lt;- runUMAP(sce) plotUMAP(sce, colour_by = &quot;label&quot;, text_by = &quot;label&quot;) 9.3 Calculate activity Even though Dorothea provides weights under the mor column, we can achieve superior performance if we recompute the weights based on the correlation between tf and target gene expression based on our own data. We performed 2 steps, the first step is to add weights to the Dorothea regulons and the second step is to estimate the TF activity by taking the weighted average of the target gene expression. library(epiregulon) #Add weights to regulon. Default method (wilcoxon) cannot be used regulon.ms &lt;- addWeights(regulon = regulon, expMatrix = sce, clusters = sce$label, BPPARAM = BiocParallel::MulticoreParam(), method=&quot;corr&quot;) #Calculate activity score.combine &lt;- calculateActivity(sce, regulon = regulon.ms, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) 9.4 Perform differential activity library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = sce$label, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) Take the top TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) 9.5 Visualize activity Finally we visualize the TF activity by either UMAP, violin plots or bubble plots. We confirm the activity of known lineage factors Pdx1 and Neurod1 in beta cells, Arx in alpha cells and Foxa1 in ductal cells. # plot umap plotActivityDim(sce = sce, activity_matrix = score.combine, tf = genes_to_plot, legend.label = &quot;score&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2) # plot violin plot plotActivityViolin(score.combine, tf = genes_to_plot, clusters = sce$label) # plot bubble plot plotBubble(score.combine, tf = genes_to_plot, clusters = sce$label) Plot bubble plot of differential TFs plotBubble(score.combine, tf = markers.sig$tf, clusters = sce$label) We can adapt the epiregulon package to plot gene expression. When compared against TF activity, gene expression of Foxa1 and Arx has noisy signals and high dropout rates. Epiregulon enhances the signal to noise ratio of TF activity and better resolves lineage differences. # plot umap plotActivityDim(sce = sce, activity_matrix = logcounts(sce), tf = genes_to_plot, legend.label = &quot;gex&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2, colors = c(&quot;gray&quot;,&quot;blue&quot;), limit = c(0,2)) # plot violin plot plotActivityViolin(logcounts(sce), tf = genes_to_plot, clusters = sce$label, legend.label = &quot;gex&quot;) # plot Bubble plot plotBubble(logcounts(sce), tf = markers.sig$tf, clusters = sce$label, legend.label = &quot;gex&quot;) We can visualize the target genes for transcription factors of interest plotHeatmapRegulon(sce=sce, tfs=genes_to_plot, regulon=regulon.ms, regulon_cutoff=0.5, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;logcounts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) ## Found more than one class &quot;package_version&quot; in cache; using the first, from namespace &#39;SeuratObject&#39; ## Also defined by &#39;alabaster.base&#39; plotHeatmapActivity(activity_matrix = score.combine, sce=sce, tfs=genes_to_plot, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) ## Found more than one class &quot;package_version&quot; in cache; using the first, from namespace &#39;SeuratObject&#39; ## Also defined by &#39;alabaster.base&#39; 9.6 Pathway enrichment Sometimes it is useful to understand what pathways are enriched in the regulons. We take the highly correlated target genes of a regulon and perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets MH &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;MH&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) M7 &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;M7&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(MH,M7) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs = x, genes = gs[[x]])})) enrichresults &lt;- regulonEnrich(genes_to_plot, regulon = regulon.ms, weight = &quot;weight&quot;, weight_cutoff = 0.5, genesets = gs.list) ## Foxa1 ## Neurod1 ## Pdx1 ## Arx #plot results enrichPlot(results = enrichresults, ncol = 1) "],["session-info.html", "10 Session Info", " 10 Session Info sessionInfo() ## R version 4.5.2 (2025-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Red Hat Enterprise Linux 8.10 (Ootpa) ## ## Matrix products: default ## BLAS/LAPACK: FlexiBLAS OPENBLAS; LAPACK version 3.12.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/Los_Angeles ## tzcode source: system (glibc) ## ## attached base packages: ## [1] grid stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] org.Mm.eg.db_3.22.0 scater_1.38.0 ## [3] scuttle_1.20.0 scRNAseq_2.24.0 ## [5] dorothea_1.22.0 igraph_2.2.1 ## [7] nabor_0.5.0 org.Hs.eg.db_3.22.0 ## [9] msigdbr_25.1.1 epiregulon.extra_1.6.0 ## [11] DropletUtils_1.30.0 zellkonverter_1.20.0 ## [13] ensembldb_2.34.0 AnnotationFilter_1.34.0 ## [15] GenomicFeatures_1.62.0 AnnotationDbi_1.72.0 ## [17] pbmcMultiome.SeuratData_0.1.4 SeuratData_0.2.2.9002 ## [19] Signac_1.16.0 Seurat_5.3.1 ## [21] SeuratObject_5.2.0 sp_2.2-0 ## [23] epiregulon.archr_0.99.7 rhdf5_2.54.1 ## [25] RcppArmadillo_15.2.2-1 Rcpp_1.1.0 ## [27] sparseMatrixStats_1.22.0 data.table_1.17.8 ## [29] stringr_1.6.0 plyr_1.8.9 ## [31] magrittr_2.0.4 ggplot2_4.0.1 ## [33] gtable_0.3.6 gtools_3.9.5 ## [35] gridExtra_2.3 devtools_2.4.6 ## [37] usethis_3.2.1 ArchR_1.0.3.1 ## [39] Matrix_1.7-4 BSgenome.Hsapiens.UCSC.hg38_1.4.5 ## [41] BSgenome_1.78.0 rtracklayer_1.70.0 ## [43] BiocIO_1.20.0 Biostrings_2.78.0 ## [45] XVector_0.50.0 GenomeInfoDb_1.46.2 ## [47] epiregulon_2.1.2 scMultiome_1.10.0 ## [49] SingleCellExperiment_1.32.0 MultiAssayExperiment_1.36.1 ## [51] SummarizedExperiment_1.40.0 Biobase_2.70.0 ## [53] GenomicRanges_1.62.0 Seqinfo_1.0.0 ## [55] IRanges_2.44.0 S4Vectors_0.48.0 ## [57] MatrixGenerics_1.22.0 matrixStats_1.5.0 ## [59] ExperimentHub_3.0.0 AnnotationHub_4.0.0 ## [61] BiocFileCache_3.0.0 dbplyr_2.5.1 ## [63] BiocGenerics_0.56.0 generics_0.1.4 ## [65] BiocStyle_2.38.0 ## ## loaded via a namespace (and not attached): ## [1] graph_1.88.0 ica_1.0-3 ## [3] plotly_4.11.0 BiocBaseUtils_1.12.0 ## [5] doParallel_1.0.17 tidyselect_1.2.1 ## [7] bit_4.6.0 clue_0.3-66 ## [9] lattice_0.22-7 rjson_0.2.23 ## [11] blob_1.2.4 S4Arrays_1.10.1 ## [13] parallel_4.5.2 dichromat_2.0-0.1 ## [15] seqLogo_1.76.0 png_0.1-8 ## [17] cli_3.6.5 ggplotify_0.1.3 ## [19] ProtGenerics_1.42.0 goftest_1.2-3 ## [21] bluster_1.20.0 purrr_1.2.0 ## [23] EnrichmentBrowser_2.40.0 BiocNeighbors_2.4.0 ## [25] uwot_0.2.4 curl_7.0.0 ## [27] mime_0.13 evaluate_1.0.5 ## [29] tidytree_0.4.6 ComplexHeatmap_2.26.0 ## [31] stringi_1.8.7 backports_1.5.0 ## [33] XML_3.99-0.20 httpuv_1.6.16 ## [35] clusterProfiler_4.18.2 rappdirs_0.3.3 ## [37] splines_4.5.2 RcppRoll_0.3.1 ## [39] ggraph_2.2.2 bcellViper_1.46.0 ## [41] dplyr_1.1.4 sctransform_0.4.2 ## [43] ggbeeswarm_0.7.3 sessioninfo_1.2.3 ## [45] DBI_1.2.3 HDF5Array_1.38.0 ## [47] jquerylib_0.1.4 withr_3.0.2 ## [49] systemfonts_1.3.1 enrichplot_1.30.4 ## [51] lmtest_0.9-40 ggnewscale_0.5.2 ## [53] GSEABase_1.72.0 tidygraph_1.3.1 ## [55] BiocManager_1.30.27 htmlwidgets_1.6.4 ## [57] fs_1.6.6 ggrepel_0.9.6 ## [59] labeling_0.4.3 SparseArray_1.10.6 ## [61] h5mread_1.2.1 annotate_1.88.0 ## [63] reticulate_1.44.1 zoo_1.8-14 ## [65] knitr_1.50 TFBSTools_1.48.0 ## [67] UCSC.utils_1.6.0 TFMPvalue_0.0.9 ## [69] foreach_1.5.2 patchwork_1.3.2 ## [71] caTools_1.18.3 ggtree_4.0.1 ## [73] pwalign_1.6.0 R.oo_1.27.1 ## [75] ggiraph_0.9.2 RSpectra_0.16-2 ## [77] irlba_2.3.5.1 ggrastr_1.0.2 ## [79] alabaster.schemas_1.10.0 fastDummies_1.7.5 ## [81] gridGraphics_0.5-1 ellipsis_0.3.2 ## [83] lazyeval_0.2.2 yaml_2.3.12 ## [85] survival_3.8-3 scattermore_1.2 ## [87] BiocVersion_3.22.0 crayon_1.5.3 ## [89] RcppAnnoy_0.0.22 RColorBrewer_1.1-3 ## [91] tidyr_1.3.1 progressr_0.18.0 ## [93] tweenr_2.0.3 later_1.4.4 ## [95] Rgraphviz_2.54.0 GlobalOptions_0.1.3 ## [97] ggridges_0.5.7 codetools_0.2-20 ## [99] KEGGREST_1.50.0 shape_1.4.6.1 ## [101] Rtsne_0.17 limma_3.66.0 ## [103] gdtools_0.4.4 Rsamtools_2.26.0 ## [105] filelock_1.0.3 pkgconfig_2.0.3 ## [107] KEGGgraph_1.70.0 spatstat.univar_3.1-5 ## [109] GenomicAlignments_1.46.0 aplot_0.2.9 ## [111] alabaster.base_1.10.0 spatstat.sparse_3.1-0 ## [113] ape_5.8-1 viridisLite_0.4.2 ## [115] xtable_1.8-4 httr_1.4.7 ## [117] tools_4.5.2 globals_0.18.0 ## [119] pkgbuild_1.4.8 beeswarm_0.4.0 ## [121] checkmate_2.3.3 nlme_3.1-168 ## [123] assertthat_0.2.1 digest_0.6.39 ## [125] bookdown_0.46 dir.expiry_1.18.0 ## [127] farver_2.1.2 reshape2_1.4.5 ## [129] yulab.utils_0.2.2 viridis_0.6.5 ## [131] DirichletMultinomial_1.52.0 glue_1.8.0 ## [133] cachem_1.1.0 polyclip_1.10-7 ## [135] parallelly_1.45.1 pkgload_1.4.1 ## [137] statmod_1.5.1 RcppHNSW_0.6.0 ## [139] ScaledMatrix_1.18.0 fontBitstreamVera_0.1.1 ## [141] pbapply_1.7-4 httr2_1.2.2 ## [143] spam_2.11-1 gson_0.1.0 ## [145] dqrng_0.4.1 basilisk_1.22.0 ## [147] graphlayouts_1.2.2 alabaster.se_1.10.0 ## [149] shiny_1.12.1 tidydr_0.0.6 ## [151] scrapper_1.4.0 R.utils_2.13.0 ## [153] rhdf5filters_1.22.0 RCurl_1.98-1.17 ## [155] alabaster.sce_1.10.0 memoise_2.0.1 ## [157] rmarkdown_2.30 scales_1.4.0 ## [159] R.methodsS3_1.8.2 gypsum_1.6.0 ## [161] future_1.68.0 chromote_0.5.1 ## [163] fontLiberation_0.1.0 RANN_2.6.2 ## [165] Cairo_1.7-0 spatstat.data_3.1-9 ## [167] rstudioapi_0.17.1 cluster_2.1.8.1 ## [169] spatstat.utils_3.2-0 fitdistrplus_1.2-4 ## [171] cowplot_1.2.0 colorspace_2.1-2 ## [173] FNN_1.1.4.1 rlang_1.1.6 ## [175] BSgenome.Hsapiens.UCSC.hg19_1.4.3 DelayedMatrixStats_1.32.0 ## [177] dotCall64_1.2 circlize_0.4.17 ## [179] ggforce_0.5.0 ggtangle_0.0.9 ## [181] xfun_0.54 alabaster.matrix_1.10.0 ## [183] iterators_1.0.14 remotes_2.5.0 ## [185] abind_1.4-8 GOSemSim_2.36.0 ## [187] tibble_3.3.0 treeio_1.34.0 ## [189] Rhdf5lib_1.32.0 motifmatchr_1.32.0 ## [191] bitops_1.0-9 ps_1.9.1 ## [193] promises_1.5.0 scatterpie_0.2.6 ## [195] RSQLite_2.4.5 qvalue_2.42.0 ## [197] fgsea_1.36.0 DelayedArray_0.36.0 ## [199] GO.db_3.22.0 compiler_4.5.2 ## [201] alabaster.ranges_1.10.0 beachmat_2.26.0 ## [203] listenv_0.10.0 fontquiver_0.2.1 ## [205] edgeR_4.8.0 BiocSingular_1.26.1 ## [207] tensor_1.5.1 MASS_7.3-65 ## [209] BiocParallel_1.44.0 babelgene_22.9 ## [211] spatstat.random_3.4-3 R6_2.6.1 ## [213] fastmap_1.2.0 fastmatch_1.1-6 ## [215] vipor_0.4.7 ROCR_1.0-11 ## [217] websocket_1.4.4 rsvd_1.0.5 ## [219] KernSmooth_2.23-26 miniUI_0.1.2 ## [221] deldir_2.0-4 htmltools_0.5.9 ## [223] bit64_4.6.0-1 spatstat.explore_3.6-0 ## [225] lifecycle_1.0.4 S7_0.2.1 ## [227] processx_3.8.6 restfulr_0.0.16 ## [229] sass_0.4.10 vctrs_0.6.5 ## [231] spatstat.geom_3.6-1 DOSE_4.4.0 ## [233] scran_1.38.0 ggfun_0.2.0 ## [235] future.apply_1.20.1 bslib_0.9.0 ## [237] pillar_1.11.1 magick_2.9.0 ## [239] metapod_1.18.0 locfit_1.5-9.12 ## [241] otel_0.2.0 jsonlite_2.0.0 ## [243] GetoptLong_1.1.0 cigarillo_1.0.0 "],["contact.html", "11 Contact", " 11 Contact The issues related to epiregulon suite of packages can be reported on the package GitHub repository page. epiregulon epiregulon.extra epiregulon.archr If you need more information on the package usage you can contact authors directly: Xiaosai Yao, yao.xiaosai@gene.com Tomasz Włodarczy, tomwlo@gmail.com "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
