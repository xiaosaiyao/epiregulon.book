[["index.html", "Epiregulon documentation Introduction", " Epiregulon documentation Xiaosai Yao, Tomasz Włodarczyk 2024-03-19 Introduction Gene regulatory networks model the underlying gene regulation hierarchies that drive gene expression and cell states. The main function of the epiregulon package is to construct gene regulatory networks and infer transcription factor (TF) activity in single cells by integration of scATAC-seq and scRNA-seq data and incorporation of public bulk TF ChIP-seq data. Epiregulon assigns regulatory elements (REs) to their putative target genes (TGs) if the chromatin accessibility and gene expressions are highly correlated across cell clusters. Each regulatory element is then interrogated for TF occupancy based on a compilation of public TF ChIP-seq binding sites from ChIP-Atlas and ENCODE TF ChIP-seq data. This maps out the preliminary TF-RE-TG regulatory relationships. Further pruning of the gene regulatory network is necessary to remove spurious gene regulatory relationships not supported by the data, especially because the public ChIP-seq data was most certainly obtained in different cell lines or treatment conditions. In this case, we want to identify the most likely TF-RE-TG triplets. Here we apply tests of independence (binomial or chi-square tests) which identify TF-RE-TG triplets jointly occurring at probabilities deviating from the expected probabilities if these three events occur independently. In other words, we assume that a TF-RE-TG regulatory relationship holds true if expression of the TG, chromatin accessibility at RE and expression of the TG tend to co-exist in the same cells. While we recognize that there could be time delays between chromatin accessibility and the expression of target genes in true RE-TG relationships, we want to be conservative in our inference and rule out unsubstantiated TF-RE-TG relationships. After network pruning, we would like to further estimate the strength of regulation. This can be achieved using one of the three methods: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, and 3) effect size of the Wilcoxon test between target gene expression in cells jointly expressing all 3 elements vs cells that do not. The activity of transcription factor is the weighted sum of all its target genes in which the weights correspond to the strength of regulation. The target genes of TFs can be queried against known pathways to predict the functions of TFs. We can also perform differential TF activity using two approaches: 1) differential total activity or 2) differential network topology. The first approach compares differences in the sum of the target genes. The second approach involves edge subtraction between two networks and the TFs are ranked by the degree centrality of the differential graphs. Epiregulon also allows identification of interaction partners by the degree of overlaps in the target genes between two TFs. Current prerequisites for running epiregulon include pre-computed peak matrix, gene expression matrix and dimensionality reduction. Epiregulon offers seamless integration with ArchR. Alternately, users can analyze their data using their favorite analysis tools and package their matrices into MultiAssayExperiment (See scMultiome package). The scATAC-seq experiment can be either paired or unpaired with the scRNA-seq dataset as long as they were already integrated. The final output of epiregulon is a matrix of TF activities where rows are individual TFs and columns are single cell indexes. "],["installation.html", "1 Installation", " 1 Installation All the epiregulon components are available on github. There are three separate epiregulon packages. The core epiregulon package supports input in the form of SingleCellExperiment objects. If the users would like to start from ArchR projects, they may choose to use epiregulon.archr package, which allows for the seamless integration with ArchR package through accepting its output to be used in the downstream workflow. # install devtools if(!require(devtools)) install.packages(&quot;devtools&quot;) # install basic epiregulon package devtools::install_github(repo=&#39;xiaosaiyao/epiregulon&#39;) # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.archr&#39;) Moreover, we provide a suite of tools for the enrichment analysis, visualization, and network analysis which can be run on the epireglon or epiregulon.archr output. # install extended version of epiregulon devtools::install_github(repo=&#39;xiaosaiyao/epiregulon.extra&#39;) "],["basic-workflow-with-multiassayexperiment.html", "2 Basic workflow with MultiAssayExperiment 2.1 Data preparation 2.2 Quick start 2.3 Session Info", " 2 Basic workflow with MultiAssayExperiment In this chapter, we illustrate the epiregulon workflow starting from data in the form of SingleCellExperiment objects using the correlation weight estimation method. This tutorial demonstrates the basic functions of epiregulon, using the reprogram-seq dataset which can be downloaded from the scMultiome package. In this example, prostate cancer cells (LNCaP) were infected in separate wells with viruses encoding 4 transcription factors (NKX2-1, GATA6, FOXA1 and FOXA2) and a positive control (mNeonGreen) before pooling. The identity of the infected transcription factors was tracked through cell hashing (available in the field hash_assignment of the colData) and serves as the ground truth. 2.1 Data preparation Prior to using epiregulon, single cell preprocessing needs to performed by user’s favorite methods. The following components are required: 1. Peak matrix from scATAC-seq containing the chromatin accessibility information 2. Gene expression matrix from either paired or unpaired scRNA-seq. RNA-seq integration needs to be performed for unpaired dataset. 3. Dimensionality reduction matrix from with either single modalities or joint scRNA-seq and scATAC-seq # load the MAE object library(scMultiome) ## Loading required package: AnnotationHub ## Loading required package: BiocFileCache ## Loading required package: dbplyr ## ## Attaching package: &#39;AnnotationHub&#39; ## The following object is masked from &#39;package:Biobase&#39;: ## ## cache ## Loading required package: ExperimentHub ## Loading required package: MultiAssayExperiment ## Loading required package: SingleCellExperiment library(epiregulon) mae &lt;- scMultiome::reprogramSeq() ## snapshotDate(): 2024-03-11 ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## Warning: Corrupt Cache: resource path ## See AnnotationHub&#39;s TroubleshootingTheHubs vignette section on corrupt cache ## cache: /gstore/home/wlodarct/.cache/R/ExperimentHub ## potential duplicate files: ## 5e9d57d2f82f_7843 ## 72c310f8bfcd_7843 ## Continuing with first found cached file ## loading from cache ## Warning: Corrupt Cache: resource path ## See AnnotationHub&#39;s TroubleshootingTheHubs vignette section on corrupt cache ## cache: /gstore/home/wlodarct/.cache/R/ExperimentHub ## potential duplicate files: ## 5e9d57d2f82f_7843 ## 72c310f8bfcd_7843 ## Continuing with first found cached file # extract peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # extract expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneExpressionMatrix&quot;]] rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name # define the order of hash_assigment GeneExpressionMatrix$hash_assignment &lt;- factor(as.character(GeneExpressionMatrix$hash_assignment), levels = c(&quot;HTO10_GATA6_UTR&quot;, &quot;HTO2_GATA6_v2&quot;, &quot;HTO8_NKX2.1_UTR&quot;, &quot;HTO3_NKX2.1_v2&quot;, &quot;HTO1_FOXA2_v2&quot;, &quot;HTO4_mFOXA1_v2&quot;, &quot;HTO6_hFOXA1_UTR&quot;, &quot;HTO5_NeonG_v2&quot;)) # extract dimensional reduction matrix reducedDimMatrix &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;LSI_ATAC&quot;) # transfer UMAP_combined from TileMatrix to GeneExpressionMatrix reducedDim(GeneExpressionMatrix, &quot;UMAP_Combined&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;UMAP_Combined&quot;) Visualize singleCellExperiment by UMAP scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_Combined&quot;, text_by = &quot;Clusters&quot;, colour_by = &quot;Clusters&quot;) 2.2 Quick start 2.2.1 Retrieve bulk TF ChIP-seq binding sites First, we retrieve a GRangesList object containing the binding sites of all the transcription factors and co-regulators. These binding sites are derived from bulk ChIP-seq data in the ChIP-Atlas and ENCODE databases. For the same transcription factor, multiple ChIP-seq files from different cell lines or tissues are merged. For further information on how these peaks are derived, please refer to ?epiregulon::getTFMotifInfo. Currently, human genomes hg19 and hg38 and mouse mm10 are supported. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) ## snapshotDate(): 2024-03-11 ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 2.2.2 Link ATAC-seq peaks to target genes Next, we try to link ATAC-seq peaks to their putative target genes. We assign a peak to a gene within a size window (default ±250kb) if the chromatin accessibility of the peak and expression of the target genes are highly correlated (default threshold 0.5). To compute correlations, we first create cell aggregates by performing k-means clustering on the reduced dimensionality matrix. Then we aggregate the counts of the gene expression and peak matrix and average across the number of cells. Correlations are computed on the averaged gene expression and chromatin accessibility. If cluster labels are provided, peak-to-gene correlations are computed on all the cells and for each cluster. Peak-to-gene links are retained as long as any of the correlations pass the threshold; the longer list of peak-to-gene links capture both inter- and intra-cluster variations. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, reducedDim = reducedDimMatrix, exp_assay = &quot;normalizedCounts&quot;, peak_assay = &quot;counts&quot;) ## Using epiregulon to compute peak to gene links... ## performing k means clustering to form metacells ## Computing correlation p2g ## DataFrame with 11342 rows and 8 columns ## idxATAC chr start end idxRNA target Correlation distance ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;integer&gt; ## 1 12 chr1 924540 925040 27 PLEKHN1 0.514480 39440 ## 2 18 chr1 943046 943546 19 FAM41C 0.634958 72646 ## 3 19 chr1 944445 944945 26 KLHL17 0.527835 13637 ## 4 22 chr1 960317 960817 33 AGRN 0.683067 57301 ## 5 25 chr1 976232 976732 27 PLEKHN1 0.714727 9551 ## ... ... ... ... ... ... ... ... ... ## 11338 126565 chrX 154516796 154517296 36406 G6PD 0.531183 27548 ## 11339 126566 chrX 154524810 154525310 36395 TAZ 0.528253 113072 ## 11340 126571 chrX 154542392 154542892 36401 LAGE3 0.522857 62936 ## 11341 126574 chrX 154607299 154607799 36406 G6PD 0.520784 60254 ## 11342 126583 chrX 155026775 155027275 36423 BRCC3 0.605565 42143 2.2.3 Add TF motif binding to peaks The next step is to add the TF binding information by overlapping regions of the peak matrix with the bulk chip-seq database. The output is a data frame object with three columns: idxATAC - index of the peak in the peak matrix idxTF - index in the gene expression matrix corresponding to the transcription factor tf - name of the transcription factor overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) ## Computing overlap... ## Success! head(overlap) ## idxATAC idxTF tf ## 2312 12 3 AFF4 ## 2313 12 8 ARID2 ## 2314 12 13 ARNT ## 2315 12 18 ATF3 ## 2316 12 23 BACH1 ## 2317 12 25 BCL11A 2.2.4 Generate regulons A DataFrame, representing the inferred regulons, is then generated. The DataFrame consists of ten columns: idxATAC - index of the peak in the peak matrix chr - chromosome number start - start position of the peak end - end position of the peak idxRNA - index in the gene expression matrix corresponding to the target gene target - name of the target gene distance - distance between the transcription start site of the target gene and the middle of the peak idxTF - index in the gene expression matrix corresponding to the transcription factor tf - name of the transcription factor corr - correlation between target gene expression and the chromatin accessibility at the peak. if cluster labels are provided, this field is a matrix with columns names corresponding to correlation across all cells and for each of the clusters. regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 1664198 rows and 10 columns ## idxATAC chr start end idxRNA target distance idxTF tf corr ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 12 chr1 924540 925040 27 PLEKHN1 39440 3 AFF4 0.51448 ## 2 12 chr1 924540 925040 27 PLEKHN1 39440 8 ARID2 0.51448 ## 3 12 chr1 924540 925040 27 PLEKHN1 39440 13 ARNT 0.51448 ## 4 12 chr1 924540 925040 27 PLEKHN1 39440 18 ATF3 0.51448 ## 5 12 chr1 924540 925040 27 PLEKHN1 39440 23 BACH1 0.51448 ## ... ... ... ... ... ... ... ... ... ... ... ## 1664194 126583 chrX 155026775 155027275 36423 BRCC3 42143 1540 ZNF883 0.605565 ## 1664195 126583 chrX 155026775 155027275 36423 BRCC3 42143 1541 ZNF891 0.605565 ## 1664196 126583 chrX 155026775 155027275 36423 BRCC3 42143 1551 ZSCAN31 0.605565 ## 1664197 126583 chrX 155026775 155027275 36423 BRCC3 42143 1557 ZXDB 0.605565 ## 1664198 126583 chrX 155026775 155027275 36423 BRCC3 42143 1558 ZXDC 0.605565 2.2.5 Network pruning (highly recommended) Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. The users can choose between two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the category of “active TF” is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon[regulon$tf %in% c(&quot;NKX2-1&quot;,&quot;GATA6&quot;,&quot;FOXA1&quot;,&quot;FOXA2&quot;, &quot;AR&quot;),], clusters = GeneExpressionMatrix$Clusters, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05 ) pruned.regulon 2.2.6 Add Weights While the pruneRegulon function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the three measures: 1) correlation between TF and target gene expression, 2) mutual information between the TF and target gene expression and 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Two of the measures (correlation and Wilcoxon statistics) give both the magnitude and directionality of changes whereas mutual information is always positive. The correlation and mutual information statistics are computed on pseudobulks aggregated by user-supplied cluster labels, whereas the Wilcoxon method groups cells into two categories: 1) the active category of cells jointly expressing TF, RE and TG and 2) the inactive category consisting of the remaining cells. We calculate cluster-specific weights if users supply cluster labels. regulon.w &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$Clusters, method = &quot;wilcox&quot;) regulon.w 2.2.7 (Optional) Annotate with TF motifs So far the gene regulatory network was constructed from TF ChIP-seq exclusively. Some users would prefer to further annotate regulatory elements with the presence of motifs. We provide an option to annotate peaks with motifs from the Cisbp database. If no motifs are present for this particular factor (as in the case of co-factors or chromatin modifiers), we return NA. If motifs are available for a factor and the RE contains a motif, we return 1. If motifs are available and the RE does not contain a motif, we return 0. regulon.w.motif &lt;- addMotifScore(regulon = regulon.w, peaks = rowRanges(PeakMatrix), species = &quot;human&quot;, genome = &quot;hg38&quot;) ## annotating peaks with motifs ## snapshotDate(): 2024-03-11 ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache ## ## ## Attaching package: &#39;XVector&#39; ## The following object is masked from &#39;package:plyr&#39;: ## ## compact ## ## Attaching package: &#39;Biostrings&#39; ## The following object is masked from &#39;package:grid&#39;: ## ## pattern ## The following object is masked from &#39;package:base&#39;: ## ## strsplit ## ## Attaching package: &#39;rtracklayer&#39; ## The following object is masked from &#39;package:BiocIO&#39;: ## ## FileForFormat ## The following object is masked from &#39;package:AnnotationHub&#39;: ## ## hubUrl # if desired, set weight to 0 if no motif is found regulon.w.motif$weight[regulon.w.motif$motif == 0] &lt;- 0 regulon.w.motif ## DataFrame with 5183 rows and 15 columns ## idxATAC chr start end idxRNA target distance idxTF tf corr ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 12 chr1 924540 925040 27 PLEKHN1 39440 490 AR 0.514480 ## 2 22 chr1 960317 960817 33 AGRN 57301 490 AR 0.683067 ## 3 25 chr1 976232 976732 27 PLEKHN1 9551 490 AR 0.714727 ## 4 28 chr1 999317 999817 27 PLEKHN1 32636 490 AR 0.666428 ## 5 36 chr1 1019834 1020334 37 C1orf159 69838 490 AR 0.507988 ## ... ... ... ... ... ... ... ... ... ... ... ## 5179 121777 chr9 97632816 97633316 34691 XPA 62039 807 NKX2-1 0.512977 ## 5180 122254 chr9 108991440 108991940 34784 CTNNAL1 27686 807 NKX2-1 0.535211 ## 5181 122461 chr9 113174265 113174765 34825 SLC31A1 44777 807 NKX2-1 0.693885 ## 5182 122486 chr9 113410132 113410632 34829 WDR31 69664 807 NKX2-1 0.687963 ## 5183 125664 chrX 103373520 103374020 35972 TCEAL8 118166 807 NKX2-1 0.636336 ## pval stats qval weight motif ## &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;numeric&gt; ## 1 0.1100599:0.000116038:1:... 2.55336:14.856005:0:... 1:1:1:... 0:0:0:... 0 ## 2 0.0442620:0.507661630:1:... 4.04654: 0.438884:0:... 1:1:1:... 0:0:0:... 0 ## 3 0.1684463:0.018871908:1:... 1.89672: 5.513346:0:... 1:1:1:... 0:0:0:... 0 ## 4 0.0171580:0.015354703:1:... 5.68014: 5.875306:0:... 1:1:1:... 0:0:0:... 0 ## 5 0.0111761:0.105168717:1:... 6.43710: 2.625359:0:... 1:1:1:... 0:0:0:... 0 ## ... ... ... ... ... ... ## 5179 8.54038e-02:1:1:... 2.95894:0:0:... 1.000000000:1:1:... 0:0:0:... 0 ## 5180 1.30998e-02:1:1:... 6.15558:0:0:... 1.000000000:1:1:... 0:0:0:... 0 ## 5181 4.51202e-02:1:1:... 4.01414:0:0:... 1.000000000:1:1:... 0:0:0:... 0 ## 5182 8.35430e-09:1:1:... 33.19084:0:0:... 0.000220721:1:1:... 0:0:0:... 0 ## 5183 5.64410e-06:1:1:... 20.60525:0:0:... 0.147960211:1:1:... 0:0:0:... 0 2.2.8 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging expressions of target genes linked to the TF weighted by the test statistics of choice, chosen from either correlation, mutual information or the Wilcoxon test statistics. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weights_i\\] where \\(y\\) is the activity of a TF for a cell, \\(n\\) is the total number of targets for a TF, \\(x_i\\) is the log count expression of target \\(i\\) where \\(i\\) in {1,2,…,n} and \\(weights_i\\) is the weight of TF - target \\(i\\) score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;, exp_assay = &quot;normalizedCounts&quot;, normalize = FALSE) ## calculating TF activity from regulon using weightedmean ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, : The weight column contains multiple ## subcolumns but no cluster information was provided. Using first column to compute activity... ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by the number of targets... score.combine[1:5,1:5] ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## reprogram#TTAGGAACAAGGTACG-1 reprogram#GAGCGGTCAACCTGGT-1 reprogram#TTATAGCCACCCTCAC-1 reprogram#TGGTGATTCCTGTTCA-1 ## AR 0.02437416 0.03482558 0.01920813 0.021308518 ## FOXA1 0.01989094 0.02416234 0.01231442 0.012557325 ## FOXA2 0.01003670 0.02380898 0.01132239 0.016970189 ## GATA6 0.02399254 0.11312831 0.01405688 0.018020495 ## NKX2-1 0.04739232 0.03213549 0.01199183 0.009208308 ## reprogram#TCGGTTCTCACTAGGT-1 ## AR 0.02496032 ## FOXA1 0.02073854 ## FOXA2 0.01383926 ## GATA6 0.02046804 ## NKX2-1 0.04729744 2.3 Session Info sessionInfo() ## R Under development (unstable) (2023-12-04 r85659) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 18.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/local/lib/R/lib/libRblas.so ## LAPACK: /usr/local/lib/R/lib/libRlapack.so; LAPACK version 3.11.0 ## ## Random number generation: ## RNG: L&#39;Ecuyer-CMRG ## Normal: Inversion ## Sample: Rejection ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] parallel stats4 grid stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.71.2 rtracklayer_1.63.1 ## [4] BiocIO_1.13.0 Biostrings_2.71.4 XVector_0.43.1 ## [7] epiregulon_0.99.5 scMultiome_1.3.0 SingleCellExperiment_1.25.0 ## [10] MultiAssayExperiment_1.29.1 ExperimentHub_2.11.1 AnnotationHub_3.11.1 ## [13] BiocFileCache_2.11.1 dbplyr_2.4.0 BiocStyle_2.31.0 ## [16] rhdf5_2.47.6 SummarizedExperiment_1.33.3 Biobase_2.63.0 ## [19] RcppArmadillo_0.12.8.1.0 Rcpp_1.0.12 Matrix_1.6-4 ## [22] GenomicRanges_1.55.3 GenomeInfoDb_1.39.9 IRanges_2.37.1 ## [25] S4Vectors_0.41.4 BiocGenerics_0.49.1 sparseMatrixStats_1.15.0 ## [28] MatrixGenerics_1.15.0 matrixStats_1.2.0 data.table_1.15.2 ## [31] stringr_1.5.1 plyr_1.8.9 magrittr_2.0.3 ## [34] ggplot2_3.5.0 gtable_0.3.4 gtools_3.9.5 ## [37] gridExtra_2.3 devtools_2.4.5 usethis_2.2.3 ## [40] ArchR_1.0.3 ## ## loaded via a namespace (and not attached): ## [1] later_1.3.2 bitops_1.0-7 filelock_1.0.3 R.oo_1.26.0 ## [5] tibble_3.2.1 graph_1.81.0 DirichletMultinomial_1.45.0 XML_3.99-0.16.1 ## [9] lifecycle_1.0.4 edgeR_4.1.18 lattice_0.22-5 backports_1.4.1 ## [13] limma_3.59.6 sass_0.4.9 rmarkdown_2.26 jquerylib_0.1.4 ## [17] yaml_2.3.8 remotes_2.5.0 metapod_1.11.1 httpuv_1.6.14 ## [21] sessioninfo_1.2.2 pkgbuild_1.4.4 CNEr_1.39.0 cowplot_1.1.3 ## [25] DBI_1.2.2 abind_1.4-5 pkgload_1.3.4 zlibbioc_1.49.3 ## [29] R.utils_2.12.3 purrr_1.0.2 RCurl_1.98-1.14 pracma_2.4.4 ## [33] rappdirs_0.3.3 GenomeInfoDbData_1.2.11 ggrepel_0.9.5 irlba_2.3.5.1 ## [37] seqLogo_1.69.0 annotate_1.81.2 dqrng_0.3.2 DelayedMatrixStats_1.25.1 ## [41] codetools_0.2-19 DelayedArray_0.29.9 scuttle_1.13.1 tidyselect_1.2.1 ## [45] farver_2.1.1 ScaledMatrix_1.11.1 viridis_0.6.5 GenomicAlignments_1.39.4 ## [49] jsonlite_1.8.8 BiocNeighbors_1.21.2 ellipsis_0.3.2 motifmatchr_1.25.0 ## [53] scater_1.31.2 tools_4.4.0 TFMPvalue_0.0.9 glue_1.7.0 ## [57] SparseArray_1.3.4 xfun_0.42 dplyr_1.1.4 HDF5Array_1.31.6 ## [61] withr_3.0.0 BiocManager_1.30.22 fastmap_1.1.1 rhdf5filters_1.15.4 ## [65] bluster_1.13.0 fansi_1.0.6 caTools_1.18.2 digest_0.6.35 ## [69] rsvd_1.0.5 R6_2.5.1 mime_0.12 colorspace_2.1-0 ## [73] GO.db_3.18.0 Cairo_1.6-2 poweRlaw_0.80.0 RSQLite_2.3.5 ## [77] R.methodsS3_1.8.2 utf8_1.2.4 generics_0.1.3 httr_1.4.7 ## [81] htmlwidgets_1.6.4 S4Arrays_1.3.6 TFBSTools_1.41.0 pkgconfig_2.0.3 ## [85] blob_1.2.4 htmltools_0.5.7 profvis_0.3.8 bookdown_0.38 ## [89] GSEABase_1.65.1 scales_1.3.0 png_0.1-8 scran_1.31.3 ## [93] knitr_1.45 rstudioapi_0.15.0 reshape2_1.4.4 tzdb_0.4.0 ## [97] rjson_0.2.21 checkmate_2.3.1 curl_5.2.1 cachem_1.0.8 ## [101] BiocVersion_3.19.1 miniUI_0.1.1.1 vipor_0.4.7 AnnotationDbi_1.65.2 ## [105] restfulr_0.0.15 pillar_1.9.0 vctrs_0.6.5 urlchecker_1.0.1 ## [109] promises_1.2.1 BiocSingular_1.19.0 beachmat_2.19.1 xtable_1.8-4 ## [113] cluster_2.1.6 beeswarm_0.4.0 Rgraphviz_2.47.0 evaluate_0.23 ## [117] KEGGgraph_1.63.0 readr_2.1.5 Rsamtools_2.19.3 locfit_1.5-9.9 ## [121] cli_3.6.2 compiler_4.4.0 rlang_1.1.3 crayon_1.5.2 ## [125] labeling_0.4.3 fs_1.6.3 ggbeeswarm_0.7.2 stringi_1.8.3 ## [129] viridisLite_0.4.2 BiocParallel_1.37.1 munsell_0.5.0 hms_1.1.3 ## [133] bit64_4.0.5 Rhdf5lib_1.25.1 statmod_1.5.0 KEGGREST_1.43.0 ## [137] shiny_1.8.0 highr_0.10 igraph_2.0.3 memoise_2.0.1 ## [141] bslib_0.6.1 bit_4.0.5 EnrichmentBrowser_2.33.1 "],["advanced-workflow-with-multiassayexperiment.html", "3 Advanced workflow with MultiAssayExperiment 3.1 Data preparation 3.2 Retrieve bulk TF ChIP-seq binding sites 3.3 Link ATACseq peaks to target genes 3.4 Add TF motif binding to peaks 3.5 Generate regulons 3.6 Prune network 3.7 Add Weights 3.8 Calculate TF activity 3.9 Differential TF activity test 3.10 Visualizing TF activities 3.11 Geneset enrichment 3.12 Differential Network analysis 3.13 Session Info", " 3 Advanced workflow with MultiAssayExperiment In this chapter, we illustrate the epiregulon workflow starting from data in the form of SingleCellExperiment objects using the Wilcoxon weight estimation method. This is a dataset of hematopoiesis from the ArchR tutorial. Prior to using epiregulon, this dataset has been fully preprocessed in ArchR, and converted to a MultiAssayExperiment using epireglon.archr::archr2MAE. The MAE object was uploaded to scMultiome for full reproducibility. In this dataset, scRNAseq and scATACseq were unpaired and integrated by the ArchR::addGeneIntegrationMatrix function. 3.1 Data preparation Download the example dataset from scMultiome package mae &lt;- scMultiome::hematopoiesis() # Load peak matrix PeakMatrix &lt;- mae[[&quot;PeakMatrix&quot;]] # Load expression matrix GeneExpressionMatrix &lt;- mae[[&quot;GeneIntegrationMatrix&quot;]] # Add gene symbols to rownames rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name # Transfer dimensionality reduction matrix to GeneExpression reducedDim(GeneExpressionMatrix, &quot;IterativeLSI&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;IterativeLSI&quot;) reducedDim(GeneExpressionMatrix, &quot;UMAP&quot;) &lt;- reducedDim(mae[[&#39;TileMatrix500&#39;]], &quot;UMAP&quot;) Visualize the data scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP&quot;, text_by = &quot;Clusters2&quot;, colour_by = &quot;Clusters2&quot;, point_size = 0.3, point_alpha = 0.3) 3.2 Retrieve bulk TF ChIP-seq binding sites First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq. Currently, human genomes hg19 and hg38 and mouse genome mm10 are available library(epiregulon) grl &lt;- getTFMotifInfo(genome = &quot;hg19&quot;) ## snapshotDate(): 2024-03-11 ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2761 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 10001-10446 * ## [2] chr1 877485-877780 * ## [3] chr1 919866-920161 * ## [4] chr1 2985496-2985846 * ## [5] chr1 2985975-2986514 * ## ... ... ... ... ## [2757] chrY 8333302-8333771 * ## [2758] chrY 13842450-13842966 * ## [2759] chrY 13868154-13868670 * ## [2760] chrY 21464547-21465020 * ## [2761] chrY 22147548-22147868 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 3.3 Link ATACseq peaks to target genes Next, we compute peak to gene correlations using a custom algorithm that has similar performance to ArchR’s P2G function. Wherever possible, use a multidimensional dimensionality reduction matrix such as LSI or PCA instead of UMAP or TSNE since the former provides a more accurate estimate of cell similarity. set.seed(1010) p2g &lt;- calculateP2G(peakMatrix = PeakMatrix, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, reducedDim = reducedDim(GeneExpressionMatrix, &quot;IterativeLSI&quot;)) ## Using epiregulon to compute peak to gene links... ## performing k means clustering to form metacells ## Computing correlation p2g ## DataFrame with 11694 rows and 8 columns ## idxATAC chr start end idxRNA target Correlation distance ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;array&gt; &lt;matrix&gt; &lt;integer&gt; ## 1 7 chr1 801002 801502 2 LINC00115 0.627327 36099 ## 2 24 chr1 894453 894953 6 KLHL17 0.617991 0 ## 3 25 chr1 894960 895460 6 KLHL17 0.564360 0 ## 4 25 chr1 894960 895460 9 ISG15 0.524174 51386 ## 5 37 chr1 935289 935789 8 HES4 0.509850 0 ## ... ... ... ... ... ... ... ... ... ## 11690 146390 chr22 50980758 50981258 12088 MAPK8IP2 0.600164 55872 ## 11691 146393 chr22 50983942 50984442 12079 NCAPH2 0.532094 37097 ## 11692 146403 chr22 51021154 51021654 12078 LMF2 0.502373 73018 ## 11693 146403 chr22 51021154 51021654 12089 ARSA 0.577122 44747 ## 11694 146412 chr22 51110826 51111326 12090 SHANK3 0.532273 0 3.4 Add TF motif binding to peaks The next step is to add the TF motif binding information by overlapping the regions of the peak matrix with the bulk chip-seq database. overlap &lt;- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix) ## Computing overlap... ## Success! head(overlap) ## idxATAC idxTF tf ## 1013 7 13 ARNT ## 1014 7 17 ATF2 ## 1015 7 21 ATF7 ## 1016 7 28 BCL6 ## 1017 7 30 BCOR ## 1018 7 32 BHLHE40 3.5 Generate regulons A long format dataframe, representing the inferred regulons, is then generated. The dataframe consists of three columns: tf (transcription factor) target gene peak to gene correlation between tf and target gene regulon &lt;- getRegulon(p2g, overlap, aggregate=FALSE) regulon ## DataFrame with 1712540 rows and 10 columns ## idxATAC chr start end idxRNA target distance idxTF tf corr ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 7 chr1 801002 801502 2 LINC00115 36099 13 ARNT 0.627327 ## 2 7 chr1 801002 801502 2 LINC00115 36099 17 ATF2 0.627327 ## 3 7 chr1 801002 801502 2 LINC00115 36099 21 ATF7 0.627327 ## 4 7 chr1 801002 801502 2 LINC00115 36099 28 BCL6 0.627327 ## 5 7 chr1 801002 801502 2 LINC00115 36099 30 BCOR 0.627327 ## ... ... ... ... ... ... ... ... ... ... ... ## 1712536 146412 chr22 51110826 51111326 12090 SHANK3 0 1172 POLR2AphosphoS5 0.532273 ## 1712537 146412 chr22 51110826 51111326 12090 SHANK3 0 1312 ZNF16 0.532273 ## 1712538 146412 chr22 51110826 51111326 12090 SHANK3 0 1461 ZNF600 0.532273 ## 1712539 146412 chr22 51110826 51111326 12090 SHANK3 0 1490 ZNF687 0.532273 ## 1712540 146412 chr22 51110826 51111326 12090 SHANK3 0 1520 ZNF777 0.532273 3.6 Prune network Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the active category is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section on differential networks. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, regulon = regulon, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05, clusters = GeneExpressionMatrix$Clusters2) ## pruning network with chi.sq tests using a regulon cutoff of pval&lt;0.05 ## pruning regulons 3.7 Add Weights While the pruneRegulon function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the three measures: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, or 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Two measures (correlation and Wilcoxon) give both the magnitude and directionality of changes whereas mutational information is always positive. The correlation and mutual information statistics are computed on grouped pseudobulks by user-supplied cluster labels and yield a single weight across all clusters per each TF-RE-target triplet. In contrast, the Wilcoxon method group cells based on the joint expression of TF, RE and TG in each single cell or in cell aggregates. If cell labels are provided, we calculate cluster-specific weights in addition to estimating weights from all the cells. Cell aggregation uses a default value of 10 cells and can help overcome sparsity and speed up computation. If cluster labels are provided, we can obtain weights of individual clusters and all cells combined. In this example, we apply Wilcoxon test on cell aggregates of 10 cells. We use the Wilcoxon weight method because we are interested in computing cell type-specific weights. set.seed(1010) regulon.w &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;normalizedCounts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$Clusters2, aggregateCells = TRUE, method = &quot;wilcox&quot;, useDim = &quot;IterativeLSI&quot;) ## adding weights using wilcoxon... ## performing pseudobulk using an average of 10 cells regulon.w ## DataFrame with 343577 rows and 14 columns ## idxATAC chr start end idxRNA target distance idxTF tf corr ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; ## 1 891 chr1 9223922 9224422 107 H6PD 68440 1030 ADNP 0.566311 ## 2 1154 chr1 11724524 11725024 135 FBXO6 174 1030 ADNP 0.505591 ## 3 1476 chr1 16003338 16003838 181 DDI2 59185 1030 ADNP 0.672807 ## 4 2329 chr1 25237599 25238099 295 RUNX3 53313 1030 ADNP 0.865375 ## 5 2333 chr1 25241815 25242315 295 RUNX3 49097 1030 ADNP 0.751697 ## ... ... ... ... ... ... ... ... ... ... ... ## 343573 131524 chr19 12895246 12895746 8765 KLF1 102071 473 ZSCAN29 0.734430 ## 343574 134071 chr19 41768840 41769340 9199 TGFB1 90291 473 ZSCAN29 0.635403 ## 343575 135998 chr19 54711800 54712300 9580 MBOAT7 16066 473 ZSCAN29 0.793423 ## 343576 144131 chr22 30838237 30838737 11838 SF3A1 83323 473 ZSCAN29 0.502352 ## 343577 144587 chr22 37297198 37297698 11901 CSF2RB 9976 473 ZSCAN29 0.672100 ## pval stats qval weight ## &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; &lt;matrix&gt; ## 1 2.42572e-53:1:1.00000:... 236.3764:0:0.00000000:... 3.77430e-47:1:1:... 0.352108:-0.0572865:0.218160:... ## 2 1.70871e-07:1:0.96773:... 27.3374:0:0.00163667:... 2.42454e-01:1:1:... 0.163694: 0.1313720:0.236942:... ## 3 2.50344e-04:1:1.00000:... 13.4096:0:0.00000000:... 1.00000e+00:1:1:... 0.177100: 0.0000000:0.000000:... ## 4 7.39278e-14:1:1.00000:... 55.9609:0:0.00000000:... 1.08689e-07:1:1:... 0.427978: 0.0000000:0.281650:... ## 5 2.20925e-10:1:1.00000:... 40.2722:0:0.00000000:... 3.19614e-04:1:1:... 0.313465: 0.0000000:0.229459:... ## ... ... ... ... ... ## 343573 5.96086e-04:1:1:... 11.788160:0:0:... 1:1:1:... 0.174968:-0.0612248: 0.0000000:... ## 343574 7.23903e-01:1:1:... 0.124784:0:0:... 1:1:1:... 0.157035: 0.1168639:-0.1527121:... ## 343575 4.26510e-02:1:1:... 4.109182:0:0:... 1:1:1:... 0.227676:-0.0954814: 0.0000000:... ## 343576 2.76179e-05:1:1:... 17.575117:0:0:... 1:1:1:... 0.255186:-0.0791276:-0.0727201:... ## 343577 1.12773e-03:1:1:... 10.605155:0:0:... 1:1:1:... 0.253897:-0.1591292: 0.0000000:... 3.8 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging the weighted expressions of target genes linked to the TF weighted. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weight_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,…,n} \\(weight_i\\) is the weight of TF and target i score.combine &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;, exp_assay = &quot;normalizedCounts&quot;) ## calculating TF activity from regulon using weightedmean ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, regulon = regulon.w, : The weight column contains multiple ## subcolumns but no cluster information was provided. Using first column to compute activity... ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by the number of targets... head(score.combine[1:5,1:5]) ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 ## ADNP 0.1441244 0.2181751 0.1829715 ## AFF1 0.1812722 0.1908101 0.5706316 ## AFF4 0.1226549 0.3673765 0.1364362 ## AGO1 0.1818927 0.2179344 0.1032600 ## AGO2 0.0791438 0.4689620 0.1131031 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 ## ADNP 0.1636268 0.15758333 ## AFF1 0.1928402 0.19996029 ## AFF4 0.2080821 0.13736470 ## AGO1 0.1678979 0.22520235 ## AGO2 0.2267187 0.06771202 3.9 Differential TF activity test We can next determine which TFs exhibit differential activities across cell clusters/groups via the findDifferentialActivity function. This function depends on findMarkers function from scran package. library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = GeneExpressionMatrix$Clusters2, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) getSigGenes compiles the different test results into a single dataframe and enables user to supply their desired cutoffs for significance and variable to order by. markers.sig &lt;- getSigGenes(markers, topgenes = 3 ) ## Using a logFC cutoff of 0.2 for class B for direction equal to any ## Using a logFC cutoff of 0.5 for class CD4.M for direction equal to any ## Using a logFC cutoff of 0.4 for class CD4.N for direction equal to any ## Using a logFC cutoff of 0.3 for class CLP for direction equal to any ## Using a logFC cutoff of 0.4 for class Erythroid for direction equal to any ## Using a logFC cutoff of 0.2 for class GMP for direction equal to any ## Using a logFC cutoff of 0.9 for class Mono for direction equal to any ## Using a logFC cutoff of 0.5 for class NK for direction equal to any ## Using a logFC cutoff of 0.2 for class pDC for direction equal to any ## Using a logFC cutoff of 0.3 for class PreB for direction equal to any ## Using a logFC cutoff of 0.2 for class Progenitor for direction equal to any 3.10 Visualizing TF activities Epiregulon also provides multiple options for visualizing the inferred TF activities by reduced dimensional space tSNE or UMAP plots: options(ggrastr.default.dpi=300) tfs_interest &lt;- c(&quot;EBF1&quot;,&quot;PAX5&quot;, &quot;GATA3&quot;,&quot;SPI1&quot;) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP&quot;, nrow=2, ncol=2, point_size=0.1, rasterise = TRUE) We can compare the activity with gene expression of the same TFs. plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, dimtype = &quot;UMAP&quot;, nrow=2, ncol=2, legend.label = &quot;Gex&quot;, colors = c(&quot;grey&quot;,&quot;blue&quot;), point_size=0.1, rasterise = TRUE) We can also plot violin plot to visualize TF activity. plotActivityViolin(activity_matrix = score.combine, tf = tfs_interest, clusters = GeneExpressionMatrix$Clusters2, legend.label = &quot;Gex&quot;, nrow=2, ncol=2) We plot violin plot to visualize TF gene expression. plotActivityViolin(activity_matrix = assay(GeneExpressionMatrix, &quot;normalizedCounts&quot;)[tfs_interest,], tf = tfs_interest, clusters = GeneExpressionMatrix$Clusters2, nrow=2, ncol=2, legend.label = &quot;gene expression&quot;) We can visualize the different TFs in a bubble plot: plotBubble(activity_matrix = score.combine, tf = tfs_interest, GeneExpressionMatrix$Clusters2, bubblesize = &quot;FDR&quot;) We visualize the top differential TFs based on activity. plotBubble(activity_matrix = score.combine, tf = markers.sig$tf, GeneExpressionMatrix$Clusters2, bubblesize = &quot;FDR&quot;) 3.11 Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. Here we first download Hallmark and C2 signatures from hallmark and then perform gene set enrichment of the known lineage factors. As expected, EBF1 is consistent with a B cell lineage factor, GATA3 and RUNX3 with lymphoid lineage and SPI1 with myeloid lineage. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot; ) ## Using cached version from 2024-03-19 13:20:14 C2 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C2&quot;, gene.id.type = &quot;SYMBOL&quot; ) ## Using cached version from 2024-03-19 11:49:25 #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H, C2) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = tfs_interest, regulon = regulon.w, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## EBF1 ## PAX5 ## GATA3 ## SPI1 #plot results enrichPlot(results = enrichresults, ncol=2) 3.12 Differential Network analysis In addition to looking at the summed TF activity, a second approach to investigate differential TF activity is to compare and contrast target genes or network topology. In this example, we know that EBF1 is a B cell lineage factor. If we plot the differential network of EBF1 using the regulon with cluster-specific weights, we can see that EBF1 has many more targets in PreB cells than it has in CD4 memory T cells. plotDiffNetwork(regulon.w, cutoff = 0, tf = c(&quot;EBF1&quot;), weight = &quot;weight&quot;, clusters = c(&quot;PreB&quot;,&quot;CD4.M&quot;), layout = &quot;stress&quot;) ## Replacement of na values for weights with 0 ## Building graph using weight as edge weights Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of the targets genes for all the TFs and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to EBF1, and we successfully identify PAX5 as the most similar TF. Both PAX5 and EBF1 are important factors for B cell development (https://www.nature.com/articles/ni.2641). library(ggplot2) # construct a graph of the preB cells preB_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;PreB&quot;) ## Building graph using weight as edge weights # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(preB_network) # Focus on EBF1 similarity_score_EBF1 &lt;- similarity_score[, &quot;EBF1&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_EBF1, decreasing = TRUE),20), TF = names(head(sort(similarity_score_EBF1, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;EBF1 similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(preB_network, &quot;EBF1&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_EBF1),] diff_matrix &lt;- similarity_score_EBF1-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to EBF1 topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted EBF1 similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_EBF1})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## PAX5 IRF4 TCF3 TCF12 RAG2 NIPBL POU2F2 TCF4 RAG1 RB1 MYB TRIM22 EZH2 EP300 MEF2A CDK9 ERG ## 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## FOXP1 CREBBP BCL11A ## 0 0 0 Next, we are interested to compare the networks of two cell types, in this case, CD4 memory T cells (CD4.M) vs Monocytes (mono) cells. We build an edge subtracted graph and then calculate the degree centrality of the subtracted graph. We normalize centrality using the default square root function. The top 5 most positive TFs represent lineage factors more active in NK cells whereas the bottom 5 TFs present lineage factors enriched in CD4. We successfully identified the myeloid factor SPI1 to be associated with monocytes and Th1 factor TBX21 to be associated with CD4 T cells. #regulon.w.2 &lt;- regulon.w #regulon.w &lt;- readRDS(&quot;/gstore/project/lineage/manuscript/epiregulon/OUTPUT/regulon.w.rds&quot;) # construct a graph of the CD4.M and NK cells respectively CD4.M_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;CD4.M&quot;) ## Building graph using weight as edge weights Mono_network &lt;- buildGraph(regulon.w, weights = &quot;weight&quot;, cluster=&quot;Mono&quot;) ## Building graph using weight as edge weights # construct a difference graph diff_graph &lt;- buildDiffGraph(Mono_network,CD4.M_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table, 10), tail(rank_table, 10)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5, max.overlaps = Inf) + theme_classic() + ggtitle (&quot;differential TFs (Mono-CD4.M) ranked by degree centrality&quot;) We can further explore interacting factors with the myeloid factor SPI1 using the same Jaccard similarity approach. We found CEBPA as the most similar TF as SPI1. SPI1 and CEBPA are known to be important for differentiation into myeloid cells (https://www.cell.com/cell-reports/pdfExtended/S2211-1247(18)30745-9). library(igraph) diff_graph_filter &lt;- subgraph.edges(diff_graph, E(diff_graph)[E(diff_graph)$weight&gt;0], del=TRUE) # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(diff_graph_filter) # Focus on SPI1 similarity_score_SPI1 &lt;- similarity_score[, &quot;SPI1&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_SPI1, decreasing = TRUE),20), TF = names(head(sort(similarity_score_SPI1, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to SPI1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;SPI1 similarity&quot;) + theme_classic() print(topTFplot) 3.13 Session Info sessionInfo() ## R Under development (unstable) (2023-12-04 r85659) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 18.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/local/lib/R/lib/libRblas.so ## LAPACK: /usr/local/lib/R/lib/libRlapack.so; LAPACK version 3.11.0 ## ## Random number generation: ## RNG: L&#39;Ecuyer-CMRG ## Normal: Inversion ## Sample: Rejection ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] parallel stats4 grid stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] igraph_2.0.3 msigdbr_7.5.1 epiregulon.extra_0.99.5 ## [4] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.71.2 rtracklayer_1.63.1 ## [7] BiocIO_1.13.0 Biostrings_2.71.4 XVector_0.43.1 ## [10] epiregulon_0.99.5 scMultiome_1.3.0 SingleCellExperiment_1.25.0 ## [13] MultiAssayExperiment_1.29.1 ExperimentHub_2.11.1 AnnotationHub_3.11.1 ## [16] BiocFileCache_2.11.1 dbplyr_2.4.0 BiocStyle_2.31.0 ## [19] rhdf5_2.47.6 SummarizedExperiment_1.33.3 Biobase_2.63.0 ## [22] RcppArmadillo_0.12.8.1.0 Rcpp_1.0.12 Matrix_1.6-4 ## [25] GenomicRanges_1.55.3 GenomeInfoDb_1.39.9 IRanges_2.37.1 ## [28] S4Vectors_0.41.4 BiocGenerics_0.49.1 sparseMatrixStats_1.15.0 ## [31] MatrixGenerics_1.15.0 matrixStats_1.2.0 data.table_1.15.2 ## [34] stringr_1.5.1 plyr_1.8.9 magrittr_2.0.3 ## [37] ggplot2_3.5.0 gtable_0.3.4 gtools_3.9.5 ## [40] gridExtra_2.3 devtools_2.4.5 usethis_2.2.3 ## [43] ArchR_1.0.3 ## ## loaded via a namespace (and not attached): ## [1] fs_1.6.3 bitops_1.0-7 enrichplot_1.23.1 DirichletMultinomial_1.45.0 ## [5] TFBSTools_1.41.0 RColorBrewer_1.1-3 HDO.db_0.99.1 httr_1.4.7 ## [9] Rgraphviz_2.47.0 profvis_0.3.8 tools_4.4.0 backports_1.4.1 ## [13] utf8_1.2.4 R6_2.5.1 HDF5Array_1.31.6 lazyeval_0.2.2 ## [17] rhdf5filters_1.15.4 urlchecker_1.0.1 withr_3.0.0 cli_3.6.2 ## [21] Cairo_1.6-2 scatterpie_0.2.1 labeling_0.4.3 sass_0.4.9 ## [25] KEGGgraph_1.63.0 readr_2.1.5 yulab.utils_0.1.4 Rsamtools_2.19.3 ## [29] gson_0.1.0 DOSE_3.29.2 R.utils_2.12.3 scater_1.31.2 ## [33] sessioninfo_1.2.2 limma_3.59.6 rstudioapi_0.15.0 RSQLite_2.3.5 ## [37] gridGraphics_0.5-1 generics_0.1.3 dplyr_1.1.4 GO.db_3.18.0 ## [41] ggbeeswarm_0.7.2 fansi_1.0.6 abind_1.4-5 R.methodsS3_1.8.2 ## [45] lifecycle_1.0.4 yaml_2.3.8 edgeR_4.1.18 qvalue_2.35.0 ## [49] SparseArray_1.3.4 blob_1.2.4 promises_1.2.1 dqrng_0.3.2 ## [53] crayon_1.5.2 miniUI_0.1.1.1 lattice_0.22-5 beachmat_2.19.1 ## [57] cowplot_1.1.3 annotate_1.81.2 KEGGREST_1.43.0 pillar_1.9.0 ## [61] knitr_1.45 metapod_1.11.1 fgsea_1.29.0 rjson_0.2.21 ## [65] codetools_0.2-19 fastmatch_1.1-4 glue_1.7.0 ggfun_0.1.4 ## [69] remotes_2.5.0 treeio_1.27.0 vctrs_0.6.5 png_0.1-8 ## [73] poweRlaw_0.80.0 cachem_1.0.8 xfun_0.42 S4Arrays_1.3.6 ## [77] mime_0.12 tidygraph_1.3.1 pracma_2.4.4 statmod_1.5.0 ## [81] bluster_1.13.0 ellipsis_0.3.2 nlme_3.1-164 ggtree_3.11.1 ## [85] bit64_4.0.5 filelock_1.0.3 bslib_0.6.1 irlba_2.3.5.1 ## [89] vipor_0.4.7 colorspace_2.1-0 seqLogo_1.69.0 DBI_1.2.2 ## [93] ggrastr_1.0.2 tidyselect_1.2.1 bit_4.0.5 compiler_4.4.0 ## [97] curl_5.2.1 graph_1.81.0 BiocNeighbors_1.21.2 DelayedArray_0.29.9 ## [101] shadowtext_0.1.3 bookdown_0.38 checkmate_2.3.1 scales_1.3.0 ## [105] caTools_1.18.2 rappdirs_0.3.3 digest_0.6.35 motifmatchr_1.25.0 ## [109] rmarkdown_2.26 htmltools_0.5.7 pkgconfig_2.0.3 highr_0.10 ## [113] fastmap_1.1.1 rlang_1.1.3 htmlwidgets_1.6.4 shiny_1.8.0 ## [117] DelayedMatrixStats_1.25.1 farver_2.1.1 jquerylib_0.1.4 jsonlite_1.8.8 ## [121] BiocParallel_1.37.1 GOSemSim_2.29.1 R.oo_1.26.0 BiocSingular_1.19.0 ## [125] RCurl_1.98-1.14 ggplotify_0.1.2 scuttle_1.13.1 GenomeInfoDbData_1.2.11 ## [129] patchwork_1.2.0 Rhdf5lib_1.25.1 munsell_0.5.0 ape_5.7-1 ## [133] babelgene_22.9 viridis_0.6.5 EnrichmentBrowser_2.33.1 stringi_1.8.3 ## [137] ggraph_2.2.1 MASS_7.3-60.1 zlibbioc_1.49.3 pkgbuild_1.4.4 ## [141] ggrepel_0.9.5 CNEr_1.39.0 graphlayouts_1.1.1 splines_4.4.0 ## [145] hms_1.1.3 locfit_1.5-9.9 reshape2_1.4.4 ScaledMatrix_1.11.1 ## [149] pkgload_1.3.4 TFMPvalue_0.0.9 BiocVersion_3.19.1 XML_3.99-0.16.1 ## [153] evaluate_0.23 scran_1.31.3 BiocManager_1.30.22 tweenr_2.0.3 ## [157] tzdb_0.4.0 httpuv_1.6.14 polyclip_1.10-6 tidyr_1.3.1 ## [161] purrr_1.0.2 ggforce_0.4.2 rsvd_1.0.5 xtable_1.8-4 ## [165] restfulr_0.0.15 tidytree_0.4.6 later_1.3.2 viridisLite_0.4.2 ## [169] tibble_3.2.1 aplot_0.2.2 clusterProfiler_4.11.0 memoise_2.0.1 ## [173] beeswarm_0.4.0 AnnotationDbi_1.65.2 GenomicAlignments_1.39.4 cluster_2.1.6 ## [177] GSEABase_1.65.1 "],["archr-workflow-and-different-weight-methods.html", "4 ArchR workflow and different weight methods 4.1 Data preparation 4.2 Load ArchR project 4.3 Retrieve matrices from ArchR project 4.4 Retrieve bulk TF ChIP-seq binding sites 4.5 Link ATAC-seq peaks to target genes 4.6 Add TF motif binding to peaks 4.7 Generate regulons 4.8 (Optional) Annotate with TF motifs 4.9 Prune network 4.10 Add Weights 4.11 Calculate TF activity 4.12 Perform differential activity 4.13 Visualize the results 4.14 Differential network analysis 4.15 Session Info", " 4 ArchR workflow and different weight methods In this chapter, we illustrate the epiregulon workflow starting from an ArchR project and compare the different weight estimation methods. The dataset consists of unpaired scATACseq/scRNAseq of parental LNCaP cells treated with DMSO, Enzalutamide and Enza resistant cells. The dataset was taken from Taavitsainen et al GSE168667 and GSE168668. 4.1 Data preparation Please refer to the full ArchR manual for instructions Before running Epiregulon, the following analyses need to be completed: Obtain a peak matrix on scATACseq by using addGroupCoverages &gt; addReproduciblePeakSet &gt; addPeakMatrix. See chapter 10 from ArchR manual RNA-seq integration. For unpaired scATAC-seq, use addGeneIntegrationMatrix. See chapter 8 from ArchR manual For multiome data, use addGeneExpressionMatrix. See multiome tutorial Perform dimensionality reduction from with either single modalities or joint scRNAseq and scATACseq using addCombinedDims 4.2 Load ArchR project library(ArchR) archR_project_path &lt;- &quot;/gstore/project/lineage/prostate/GSE168667/OUTPUT/multiome/&quot; proj &lt;- loadArchRProject(path = archR_project_path, showLogo = FALSE) We verify that “GeneExpressionMatrix” and “PeakMatrix” are present for this tutorial. getAvailableMatrices(proj) ## [1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;MotifMatrix&quot; &quot;PeakMatrix&quot; &quot;TileMatrix&quot; We will use the joint reducedDims - “LSI_Combined” and joint embeddings - “UMAP_Combined” head(getReducedDims(proj, reducedDims = &quot;iLSI_Combined&quot;)[,1:5]) ## LSI1 LSI2 LSI3 LSI4 LSI5 ## SRR13927735#TTATGTCTCCAGGTAT-1 -2.713935 -0.3677949 -0.4484238 -0.30645138 -0.046845365 ## SRR13927735#TATTGCTCATCAGAAA-1 -2.642781 -0.2767556 -0.9142714 -0.19675812 0.075746940 ## SRR13927735#TTCGATTGTAGGGTTG-1 -2.322865 -0.1543080 -1.4106049 -0.08891276 0.019873276 ## SRR13927735#CATTCATTCGGATGTT-1 -2.572976 -0.1917188 -1.0464294 -0.12660121 0.009947438 ## SRR13927735#ACGTTAGGTCAACTGT-1 -2.478552 -0.1776639 -1.1037295 -0.22976613 -0.150097539 ## SRR13927735#AAATGCCCAGCAATGG-1 -2.595352 -0.3803464 -0.7770309 -0.52431765 -0.243074591 head(getEmbedding(proj, embedding = &quot;UMAP_Combined&quot;)) ## iLSI_Combined#UMAP_Dimension_1 iLSI_Combined#UMAP_Dimension_2 ## SRR13927735#TTATGTCTCCAGGTAT-1 -9.622903 -0.2908237 ## SRR13927735#TATTGCTCATCAGAAA-1 -9.360211 -0.2892935 ## SRR13927735#TTCGATTGTAGGGTTG-1 -8.617347 -0.2154103 ## SRR13927735#CATTCATTCGGATGTT-1 -9.285448 -0.3267481 ## SRR13927735#ACGTTAGGTCAACTGT-1 -8.809260 -0.2168703 ## SRR13927735#AAATGCCCAGCAATGG-1 -9.261216 0.3200356 4.3 Retrieve matrices from ArchR project Retrieve gene expression and peak matrix from the ArchR project GeneExpressionMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;GeneIntegrationMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) ## 2024-03-19 08:01:18.238282 : Organizing colData, 1.926 mins elapsed. ## 2024-03-19 08:01:18.424896 : Organizing rowData, 1.93 mins elapsed. ## 2024-03-19 08:01:18.429259 : Organizing rowRanges, 1.93 mins elapsed. ## 2024-03-19 08:01:18.436044 : Organizing Assays (1 of 1), 1.93 mins elapsed. ## 2024-03-19 08:01:28.057361 : Constructing SummarizedExperiment, 2.09 mins elapsed. ## 2024-03-19 08:01:31.062914 : Finished Matrix Creation, 2.14 mins elapsed. PeakMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;PeakMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1, logFile = &quot;x&quot; ) ## 2024-03-19 08:03:00.665676 : Organizing colData, 1.486 mins elapsed. ## 2024-03-19 08:03:01.440789 : Organizing rowData, 1.498 mins elapsed. ## 2024-03-19 08:03:01.450369 : Organizing rowRanges, 1.499 mins elapsed. ## 2024-03-19 08:03:01.462803 : Organizing Assays (1 of 1), 1.499 mins elapsed. ## 2024-03-19 08:03:04.8355 : Constructing SummarizedExperiment, 1.555 mins elapsed. ## 2024-03-19 08:03:27.161162 : Finished Matrix Creation, 1.927 mins elapsed. If we extract the gene expression from matrix, it will be in the form of RangedSummarizedExperiment. We can make use of ArchRMatrix2SCE to convert gene expression matrix to SingleCellExperiment object. It’s also important to note that gene expression from ArchR is library size normalized (not logged) library(epiregulon.archr) ## ## Attaching package: &#39;epiregulon.archr&#39; ## The following objects are masked from &#39;package:epiregulon&#39;: ## ## addMotifScore, addTFMotifInfo, calculateP2G, getTFMotifInfo GeneExpressionMatrix &lt;- ArchRMatrix2SCE(GeneExpressionMatrix) rownames(GeneExpressionMatrix) &lt;- rowData(GeneExpressionMatrix)$name We rename the assay name of the PeakMatrix as counts assayNames(PeakMatrix) &lt;- &quot;counts&quot; Transfer embeddings from ArchR project to singleCellExperiment for visualization reducedDim(GeneExpressionMatrix, &quot;UMAP_Combined&quot;) &lt;- getEmbedding(ArchRProj = proj, embedding = &quot;UMAP_Combined&quot;, returnDF = TRUE)[colnames(GeneExpressionMatrix),] # add cell label GeneExpressionMatrix$label &lt;- GeneExpressionMatrix$Cells GeneExpressionMatrix$label[GeneExpressionMatrix$Treatment == &quot;enzalutamide 48h&quot;] &lt;- &quot;LNCaP–ENZ48&quot; GeneExpressionMatrix$label &lt;- factor(GeneExpressionMatrix$label, levels = c(&quot;LNCaP&quot;, &quot;LNCaP–ENZ48&quot;, &quot;LNCaP RES-A&quot;, &quot;LNCaP RES-B&quot;)) Visualize singleCellExperiment by UMAP scater::plotReducedDim(GeneExpressionMatrix, dimred = &quot;UMAP_Combined&quot;, text_by = &quot;label&quot;, colour_by = &quot;label&quot;) 4.4 Retrieve bulk TF ChIP-seq binding sites First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq. Currently, human genomes HG19 and HG38 and mouse mm10 are available. grl &lt;- getTFMotifInfo(genome = &quot;hg38&quot;) ## snapshotDate(): 2024-03-11 ## see ?scMultiome and browseVignettes(&#39;scMultiome&#39;) for documentation ## loading from cache grl ## GRangesList object of length 1558: ## $AEBP2 ## GRanges object with 2700 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 9792-10446 * ## [2] chr1 942105-942400 * ## [3] chr1 984486-984781 * ## [4] chr1 3068932-3069282 * ## [5] chr1 3069411-3069950 * ## ... ... ... ... ## [2696] chrY 8465261-8465730 * ## [2697] chrY 11721744-11722260 * ## [2698] chrY 11747448-11747964 * ## [2699] chrY 19302661-19303134 * ## [2700] chrY 19985662-19985982 * ## ------- ## seqinfo: 25 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;1557 more elements&gt; 4.5 Link ATAC-seq peaks to target genes Next, we compute peak to gene correlations using the addPeak2GeneLinks function from the ArchR package. The user would need to supply a path to an ArchR project already containing peak and gene matrices, as well as Latent semantic indexing (LSI) dimensionality reduction. # path to ArchR project p2g &lt;- calculateP2G(ArchR_path = archR_project_path, useDim = &quot;iLSI_Combined&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, threads = 1) ## Setting ArchRLogging = FALSE ## Using ArchR to compute peak to gene links... ## 2024-03-19 08:03:55.593464 : Getting Available Matrices, 0 mins elapsed. ## 2024-03-19 08:04:04.379045 : Filtered Low Prediction Score Cells (0 of 15522, 0), 0.015 mins elapsed. ## 2024-03-19 08:04:05.042742 : Computing KNN, 0.026 mins elapsed. ## 2024-03-19 08:04:06.92312 : Identifying Non-Overlapping KNN pairs, 0.058 mins elapsed. ## 2024-03-19 08:04:09.163414 : Identified 498 Groupings!, 0.095 mins elapsed. ## 2024-03-19 08:04:09.226792 : Getting Group RNA Matrix, 0.096 mins elapsed. ## 2024-03-19 08:12:28.639651 : Getting Group ATAC Matrix, 8.419 mins elapsed. ## 2024-03-19 08:17:42.039764 : Normalizing Group Matrices, 13.643 mins elapsed. ## 2024-03-19 08:17:51.716899 : Finding Peak Gene Pairings, 13.804 mins elapsed. ## 2024-03-19 08:17:52.303141 : Computing Correlations, 13.814 mins elapsed. ## 2024-03-19 08:18:01.20975 : Completed Peak2Gene Correlations!, 13.962 mins elapsed. p2g ## DataFrame with 17979 rows and 8 columns ## idxATAC chr start end idxRNA target Correlation distance ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 15 chr1 912762 913262 7 NOC2L 0.546722 46297 ## 2 15 chr1 912762 913262 8 KLHL17 0.516539 47575 ## 3 25 chr1 920261 920761 7 NOC2L 0.649425 38798 ## 4 25 chr1 920261 920761 8 KLHL17 0.637711 40076 ## 5 32 chr1 927728 928228 7 NOC2L 0.610240 31331 ## ... ... ... ... ... ... ... ... ... ## 17975 210643 chrX 154542721 154543221 23496 CH17-340M24.3 0.611273 114492 ## 17976 210643 chrX 154542721 154543221 23501 LAGE3 0.698033 63714 ## 17977 210643 chrX 154542721 154543221 23506 IKBKG 0.518586 1716 ## 17978 210643 chrX 154542721 154543221 23509 DKC1 0.526624 219771 ## 17979 210665 chrX 154815200 154815700 23515 F8 0.547783 211490 4.6 Add TF motif binding to peaks The next step is to add the TF motif binding information by overlapping the regions of the peak matrix with the bulk chip-seq database. The user can supply an archR project path and this function will retrieve the peak matrix, or a peakMatrix in the form of a Granges object or RangedSummarizedExperiment. overlap &lt;- addTFMotifInfo(archR_project_path = archR_project_path, grl = grl, p2g = p2g) ## Successfully loaded ArchRProject! ## Computing overlap... ## Success! 4.7 Generate regulons A long format data frame, representing the inferred regulons, is then generated. The data frame consists of three columns: tf (transcription factor) target gene peak to gene correlation between tf and target gene regulon &lt;- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE) regulon ## DataFrame with 2776926 rows and 10 columns ## idxATAC chr start end idxRNA target corr distance idxTF tf ## &lt;integer&gt; &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;matrix&gt; &lt;numeric&gt; &lt;integer&gt; &lt;character&gt; ## 1 15 chr1 912762 913262 7 NOC2L 46297 4 AGO1 ## 2 15 chr1 912762 913262 7 NOC2L 46297 11 ARID4B ## 3 15 chr1 912762 913262 7 NOC2L 46297 12 ARID5B ## 4 15 chr1 912762 913262 7 NOC2L 46297 30 BCOR ## 5 15 chr1 912762 913262 7 NOC2L 46297 36 BRD4 ## ... ... ... ... ... ... ... ... ... ... ... ## 2776922 210665 chrX 154815200 154815700 23515 F8 211490 1146 NFRKB ## 2776923 210665 chrX 154815200 154815700 23515 F8 211490 1175 POLR2H ## 2776924 210665 chrX 154815200 154815700 23515 F8 211490 1273 ZBTB8A ## 2776925 210665 chrX 154815200 154815700 23515 F8 211490 1456 ZNF589 ## 2776926 210665 chrX 154815200 154815700 23515 F8 211490 1457 ZNF592 4.8 (Optional) Annotate with TF motifs So far the gene regulatory network was constructed from TF ChIP-seq exclusively. Some users would prefer to further annotate the regulatory elements with the presence of motifs. If motif annotation has been previously performed by ArchR, addMotifScore can retrieve this annotation from the ArchR project. If motifs are available for a factor and the RE contains a motif, we return 1. If motifs are available and the RE does not contain a motif, we return 0. If no motifs are known for this particular factor (as in the case of co-factors or chromatin modifiers), we return NA. If the user has not performed motif annotation with ArchR, we can also annotate the peaks with motifs using the Cisbp database (default) or user-provided PWMS. See ?addMotifScore It is important to note that filtering for the presence of motifs removes a large fraction of the target genes. Motifs are often present in a small subset of the ChIP-seq peaks (can be as low as 10%). Second, indirect TF binding, possibly through its interaction partners, may have a true biological function. In this example, we continue with regulons containing the motifs, regulon.motif. However, if the user prefers to retain all target genes including REs without the motifs, they should proceed with regulon. regulon.motif &lt;- addMotifScore(regulon = regulon, ArchProj = proj ) ## retrieving motif information from ArchR project # retain only TF-RE-TG triplets with motifs regulon.motif &lt;- regulon.motif[which(regulon.motif$motif ==1),] 4.9 Prune network Epiregulon prunes the network by performing tests of independence on the observed number of cells jointly expressing transcription factor (TF), regulatory element (RE) and target gene (TG) vs the expected number of cells if TF/RE and TG are independently expressed. We implement two tests, the binomial test and the chi-square test. In the binomial test, the expected probability is P(TF, RE) * P(TG), and the number of trials is the total number of cells, and the observed successes is the number of cells jointly expressing all three elements. In the chi-square test, the expected probability for having all 3 elements active is also P(TF, RE) * P(TG) and the probability otherwise is 1- P(TF, RE) * P(TG). The observed cell count for the active category is the number of cells jointly expressing all three elements, and the cell count for the inactive category is n - n_triple. We calculate cluster-specific p-values if users supply cluster labels. This is useful if we are interested in cluster-specific networks. The pruned regulons can then be used to visualize differential networks for transcription factors of interest. See section on differential networks. pruned.regulon &lt;- pruneRegulon(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, test = &quot;chi.sq&quot;, regulon = regulon.motif, clusters = GeneExpressionMatrix$label, prune_value = &quot;pval&quot;, regulon_cutoff = 0.05) 4.10 Add Weights While the `pruneRegulon’ function provides statistics on the joint occurrence of TF-RE-TG, we would like to further estimate the strength of regulation. Biologically, this can be interpreted as the magnitude of gene expression changes induced by transcription factor activity. Epiregulon estimates the regulatory potential using one of the three measures: 1) correlation between TG and TF or between TG and the product of TF and RE, 2) mutual information between TG and TF expression or between TG and the product of TF and RE, or 3) Wilcoxon test statistics of target gene expression in cells jointly expressing all 3 elements vs cells that do not. Two measures (correlation and Wilcoxon) give both the magnitude and directionality of changes whereas mutational information is always positive. The correlation and mutual information statistics are computed on grouped pseudobulks by user-supplied cluster labels and yield a single weight across all clusters per each TF-RE-target triplet. In contrast, the Wilcoxon method group cells based on the joint expression of TF, RE and TG in each single cell or in cell aggregates. If cell labels are provided, we calculate cluster-specific weights in addition to estimating weights from all the cells. Cell aggregation uses a default value of 10 cells and can help overcome sparsity and speed up computation. If cluster labels are provided, we can obtain weights of individual clusters and all cells combined. In the case of drug treatment, however, the activity of TF is suppressed often not by downregulation of the TF gene expression, but by direct interference of the TF protein function. In this dataset, the drug enzalutamide blocks the ligand binding domain of the androgen receptor and prevents it from binding to the chromatin. As a result, while the AR gene expression stays the same, the chromatin accessibility of AR, as computed by chromVar in the ArchR package, is greatly reduced by 48 hour treatment of enzalutamide. First, we visualize the AR expression and show that enzalutamide does not decrease AR expression. library(epiregulon.extra) plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(GeneExpressionMatrix), tf = &quot;AR&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;gene expression&quot;) Then we extract the chromVarMatrix from ArchR project and then visualize the chromatin accessibility at AR bound sites. We can see that 48 hour of enzalutamide treatment reduced chromatin accessibility at AR bound sites chromVarMatrix &lt;- getMatrixFromProject( ArchRProj = proj, useMatrix = &quot;MotifMatrix&quot;, useSeqnames = NULL, verbose = TRUE, binarize = FALSE, threads = 1 ) ## 2024-03-19 08:20:45.565593 : Organizing colData, 0.512 mins elapsed. ## 2024-03-19 08:20:45.73947 : Organizing rowData, 0.515 mins elapsed. ## 2024-03-19 08:20:45.742636 : Organizing rowRanges, 0.515 mins elapsed. ## 2024-03-19 08:20:45.748942 : Organizing Assays (1 of 2), 0.515 mins elapsed. ## 2024-03-19 08:20:45.847062 : Organizing Assays (2 of 2), 0.517 mins elapsed. ## 2024-03-19 08:20:45.943753 : Constructing SummarizedExperiment, 0.519 mins elapsed. ## 2024-03-19 08:20:49.662956 : Finished Matrix Creation, 0.581 mins elapsed. plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = assay(chromVarMatrix, &quot;z&quot;), tf = &quot;AR_689&quot;, dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, legend.label = &quot;chromVar&quot;) Next, we are going to compare 3 different weight methods. In the first method, the wilcoxon test compares target gene expression in cells meeting both the TF expression and accessibility cutoffs vs cells failing either the TF expression or/and accessibility cutoffs. Next, we try out the correlation method which comes in two flavors. When tf_re.merge = FALSE, weight is computed on the correlation of target gene expression vs TF gene expression. When tf_re.merge = TRUE, weight is computed on the correlation of target gene expression vs the product of TF expression and chromatin accessibility at TF-bound regulatory elements. regulon.w.wilcox &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;wilcoxon&quot;) ## adding weights using wilcoxon... regulon.w.corr &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;) ## adding weights using corr... ## calculating average expression across clusters... ## computing weights... regulon.w.corr.re &lt;- addWeights(regulon = pruned.regulon, expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, peakMatrix = PeakMatrix, peak_assay = &quot;counts&quot;, clusters = GeneExpressionMatrix$label, method = &quot;corr&quot;, tf_re.merge = TRUE) ## adding weights using corr... ## calculating average expression across clusters... ## computing weights... 4.11 Calculate TF activity Finally, the activities for a specific TF in each cell are computed by averaging the weighted expressions of target genes linked to the TF. \\[y=\\frac{1}{n}\\sum_{i=1}^{n} x_i * weight_i\\] where \\(y\\) is the activity of a TF for a cell \\(n\\) is the total number of targets for a TF \\(x_i\\) is the log count expression of target i where i in {1,2,…,n} \\(weight_i\\) is the weight of TF and target i We calculate three different activities corresponding to the different weighted regulons score.combine.wilcox &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, regulon = regulon.w.wilcox, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## calculating TF activity from regulon using weightedmean ## Warning in calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, : The weight column contains multiple ## subcolumns but no cluster information was provided. Using first column to compute activity... ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... score.combine.corr &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, regulon = regulon.w.corr, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## calculating TF activity from regulon using weightedmean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... score.combine.corr.re &lt;- calculateActivity(expMatrix = GeneExpressionMatrix, exp_assay = &quot;counts&quot;, regulon = regulon.w.corr.re, normalize = TRUE, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) ## calculating TF activity from regulon using weightedmean ## aggregating regulons... ## creating weight matrix... ## calculating activity scores... ## normalize by mean... ## normalize by the number of targets... We visualize the different activities side by side. library(epiregulon.extra) plotActivityViolin(activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by wilcoxon&quot;) plotActivityViolin(activity_matrix = score.combine.corr, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF vs TG&quot;) plotActivityViolin(activity_matrix = score.combine.corr.re, tf = c( &quot;AR&quot;), clusters = GeneExpressionMatrix$label) + ggtitle (&quot;AR activity by corr TF*RE vs TG&quot;) In this case, activity calculated from correlation based on TF and TG expression is clearly wrong because we see increased AR activity after Enzalutamide treatment despite it being an AR antagonist. Therefore, for drug treatment which often decouples TF gene expression and its activity, it is important to take into consideration both TF gene expression and RE chromatin accessibility; the latter may be a better indicator of TF function if the TF has an effect on the chromatin accessibility. In this case, the recommended methods are either wilcox or corr with tf_re.merge = TRUE. The astute users could however detect a difference in the prediction of the AR activity in the resistant clones “RES-A” and “RES-B” with respect to the parental “LNCaP” between the two methods. For example, the corr with tf_re.merge = TRUE shows increased AR activity in “RES-B” compared to “LNCaP” because “RES-B” shows increased AR expression. In contrast, the wilcoxon method did not predict an increase in AR activity in “RES-B” because “RES-B” still shows reduced chromatin accessibility compared to “LNCaP”. Since wilcoxon takes into account the co-occurrence of both TF gene expression and RE chromatin accessibility, this method does not predict an overall increase in AR activity. In the absence of the ground truth, it is difficult to judge which method is superior. Therefore, it is always crucial to validate key findings with additional empirical evidence. The most important disclaimer we wish to make is that all predictions by epiregulon should be robustly tested experimentally. 4.12 Perform differential activity For the remaining steps, we continue with activity derived from the wilcoxon method. markers &lt;- findDifferentialActivity(activity_matrix = score.combine.wilcox, clusters = GeneExpressionMatrix$label, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) Take the top differential TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) ## Using a logFC cutoff of 0.1 for class LNCaP for direction equal to any ## Using a logFC cutoff of 0 for class LNCaP–ENZ48 for direction equal to any ## Using a logFC cutoff of 0 for class LNCaP RES-A for direction equal to any ## Using a logFC cutoff of 0 for class LNCaP RES-B for direction equal to any 4.13 Visualize the results First visualize the known differential TFs by bubble plot plotBubble(activity_matrix = score.combine.wilcox, tf = c(&quot;AR&quot;,&quot;FOXA1&quot;, &quot;MYC&quot;,&quot;JUN&quot;), clusters = GeneExpressionMatrix$label) Then visualize the most differential TFs by clusters plotBubble(activity_matrix = score.combine.wilcox, tf = markers.sig$tf, clusters = GeneExpressionMatrix$label) ## Warning in max(logpval[is.finite(logpval)]): no non-missing arguments to max; returning -Inf ## Warning: Removed 52 rows containing missing values or values outside the scale range (`geom_point()`). Visualize the known differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize the newly discovered differential TFs by UMAP plotActivityDim(sce = GeneExpressionMatrix, activity_matrix = score.combine.wilcox, tf = c(&quot;SPDEF&quot;,&quot;HES4&quot;,&quot;ATF5&quot;,&quot;NR2F2&quot;), dimtype = &quot;UMAP_Combined&quot;, label = &quot;label&quot;, point_size = 1, ncol = 2, nrow = 2) Visualize regulons by heatmap rowData(GeneExpressionMatrix) &lt;- NULL plotHeatmapRegulon(sce=GeneExpressionMatrix, tfs= c( &quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon=regulon.w.wilcox, regulon_cutoff=0.1, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;counts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) plotHeatmapActivity(activity=score.combine.wilcox, sce=GeneExpressionMatrix, tfs=rownames(score.combine.wilcox), downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name = &quot;transcription factor activity&quot;, column_title_rot = 45) ## Geneset enrichment Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;hsa&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H,C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])})) enrichresults &lt;- regulonEnrich(TF = c(&quot;AR&quot;, &quot;FOXA1&quot;, &quot;MYC&quot;, &quot;JUN&quot;), regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## AR ## FOXA1 ## MYC ## JUN #plot results enrichPlot(results = enrichresults, ncol = 2) We can visualize the genesets of known factors as a network plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) We can visualize the genesets of differential factors as a network enrichresults &lt;- regulonEnrich(TF = markers.sig$tf, regulon = regulon.w.wilcox, weight = &quot;weight&quot;, weight_cutoff = 0, genesets = gs.list) ## HES4 ## NFIB ## SPDEF ## NFYB ## CEBPG ## ATF5 ## BPTF ## SREBF1 ## REST ## JUN ## JUN ## NR2F2 ## SMARCC1 ## NR2F6 ## ATF5 plotGseaNetwork(tf = names(enrichresults), enrichresults = enrichresults, p.adj_cutoff = 0.1, ntop_pathways = 10) 4.14 Differential network analysis In addition to looking at the summed TF activity, a second approach to investigate differential TF activity is to compare and contrast target genes or network topology. In this example, we know that AR is downregulated in the Enzalutamide treated cells compared to parental LNCaP. plotDiffNetwork(regulon.w.wilcox, cutoff = 0, tf = c(&quot;AR&quot;), weight = &quot;weight&quot;, clusters = c(&quot;LNCaP&quot;,&quot;LNCaP–ENZ48&quot;), layout = &quot;stress&quot;) ## Building graph using weight as edge weights We perform edge subtracted graph between two conditions and rank TFs by degree centrality. In this example, positive centrality indicates higher activity in parental LNCaP and negative centrality indicates higher activity in Enzalutamide treated cells. # construct a graph of the parental and enzalutamide treated cells respectively LNCaP_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaP&quot;) ## Building graph using weight as edge weights ENZ_network &lt;- buildGraph(regulon.w.wilcox, weights = &quot;weight&quot;, cluster=&quot;LNCaP–ENZ48&quot;) ## Building graph using weight as edge weights # construct a difference graph diff_graph &lt;- buildDiffGraph(LNCaP_network, ENZ_network, abs_diff = FALSE) diff_graph &lt;- addCentrality(diff_graph) diff_graph &lt;- normalizeCentrality(diff_graph) rank_table &lt;- rankTfs(diff_graph) library(ggplot2) ggplot(rank_table, aes(x = rank, y = centrality)) + geom_point() + ggrepel::geom_text_repel(data = rbind(head(rank_table,5), tail(rank_table,5)), aes(label = tf), nudge_x = 0, nudge_y = 0, box.padding = 0.5) + theme_classic() + ggtitle (&quot;differential TFs (LNCaP-ENZ) ranked by degree centrality&quot;) Sometimes, we are interested to identify interaction partners of the TFs of interest. This can be achieved by comparing the overlap of the targets genes for all the TFs and identify the most similar TFs by Jaccard similarity. To illustrate this function, we take a look at the top most similar 20 TFs to AR. library(igraph) diff_graph_filter &lt;- subgraph.edges(diff_graph, E(diff_graph)[E(diff_graph)$weight&gt;0], del=TRUE) # compute a similarity matrix of all TFs similarity_score &lt;- calculateJaccardSimilarity(diff_graph_filter) # Focus on AR similarity_score_AR &lt;- similarity_score[, &quot;AR&quot;] similarity_df &lt;- data.frame(similarity = head(sort(similarity_score_AR, decreasing = TRUE),20), TF = names(head(sort(similarity_score_AR, decreasing = TRUE),20))) similarity_df$TF &lt;- factor(similarity_df$TF, levels = rev(unique(similarity_df$TF))) # plot top TFs most similar to SPI1 topTFplot &lt;- ggplot(similarity_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;AR similarity&quot;) + theme_classic() print(topTFplot) In order to convince ourselves that our differential network is statistically significant, we permute the edges and obtain a background graph from averaging many iterations. Here, we plot the differential network graph subtracted by permuted graphs. # create a permuted graph by rewiring the edges 100 times permute_matrix &lt;- permuteGraph(diff_graph_filter, &quot;AR&quot;, 100, p=1) permute_matrix &lt;- permute_matrix[names(similarity_score_AR),] diff_matrix &lt;- similarity_score_AR-rowMeans(permute_matrix) diff_matrix_df &lt;- data.frame(similarity = head(sort(diff_matrix, decreasing = TRUE),20), TF = names(head(sort(diff_matrix, decreasing = TRUE),20))) diff_matrix_df$TF &lt;- factor(diff_matrix_df$TF, levels = rev(unique(diff_matrix_df$TF))) # plot top TFs most similar to AR topTFplot &lt;- ggplot(diff_matrix_df, aes(x=TF, y=similarity)) + geom_bar(stat=&quot;identity&quot;) + coord_flip() + ggtitle(&quot;background subtracted AR similarity &quot;) + theme_classic() print(topTFplot) # obtain empirical p-values p_matrix &lt;- rowMeans(apply(permute_matrix, 2, function(x) {x &gt; similarity_score_AR})) p_matrix[names(head(sort(diff_matrix,decreasing = TRUE),20))] ## JUND MYC HOXB13 FOXA1 NFIC CEBPB XBP1 MAZ ATF4 CTCF REST GATA2 ETV1 FOXP1 CEBPG JUN YY1 ## 0.00 0.00 0.00 0.01 0.03 0.01 0.00 0.03 0.01 0.00 0.01 0.01 0.03 0.01 0.01 0.03 0.00 ## NFIB ZNF148 USF2 ## 0.00 0.00 0.01 4.15 Session Info sessionInfo() ## R Under development (unstable) (2023-12-04 r85659) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 18.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/local/lib/R/lib/libRblas.so ## LAPACK: /usr/local/lib/R/lib/libRlapack.so; LAPACK version 3.11.0 ## ## Random number generation: ## RNG: L&#39;Ecuyer-CMRG ## Normal: Inversion ## Sample: Rejection ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] parallel stats4 grid stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] org.Hs.eg.db_3.18.0 AnnotationDbi_1.65.2 nabor_0.5.0 ## [4] epiregulon.archr_0.99.2 igraph_2.0.3 msigdbr_7.5.1 ## [7] epiregulon.extra_0.99.5 BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.71.2 ## [10] rtracklayer_1.63.1 BiocIO_1.13.0 Biostrings_2.71.4 ## [13] XVector_0.43.1 epiregulon_0.99.5 scMultiome_1.3.0 ## [16] SingleCellExperiment_1.25.0 MultiAssayExperiment_1.29.1 ExperimentHub_2.11.1 ## [19] AnnotationHub_3.11.1 BiocFileCache_2.11.1 dbplyr_2.4.0 ## [22] BiocStyle_2.31.0 rhdf5_2.47.6 SummarizedExperiment_1.33.3 ## [25] Biobase_2.63.0 RcppArmadillo_0.12.8.1.0 Rcpp_1.0.12 ## [28] Matrix_1.6-4 GenomicRanges_1.55.3 GenomeInfoDb_1.39.9 ## [31] IRanges_2.37.1 S4Vectors_0.41.4 BiocGenerics_0.49.1 ## [34] sparseMatrixStats_1.15.0 MatrixGenerics_1.15.0 matrixStats_1.2.0 ## [37] data.table_1.15.2 stringr_1.5.1 plyr_1.8.9 ## [40] magrittr_2.0.3 ggplot2_3.5.0 gtable_0.3.4 ## [43] gtools_3.9.5 gridExtra_2.3 devtools_2.4.5 ## [46] usethis_2.2.3 ArchR_1.0.3 ## ## loaded via a namespace (and not attached): ## [1] fs_1.6.3 bitops_1.0-7 enrichplot_1.23.1 DirichletMultinomial_1.45.0 ## [5] TFBSTools_1.41.0 doParallel_1.0.17 RColorBrewer_1.1-3 HDO.db_0.99.1 ## [9] httr_1.4.7 Rgraphviz_2.47.0 profvis_0.3.8 tools_4.4.0 ## [13] backports_1.4.1 utf8_1.2.4 R6_2.5.1 HDF5Array_1.31.6 ## [17] lazyeval_0.2.2 GetoptLong_1.0.5 rhdf5filters_1.15.4 urlchecker_1.0.1 ## [21] withr_3.0.0 cli_3.6.2 Cairo_1.6-2 scatterpie_0.2.1 ## [25] labeling_0.4.3 sass_0.4.9 KEGGgraph_1.63.0 readr_2.1.5 ## [29] yulab.utils_0.1.4 Rsamtools_2.19.3 gson_0.1.0 DOSE_3.29.2 ## [33] R.utils_2.12.3 scater_1.31.2 sessioninfo_1.2.2 limma_3.59.6 ## [37] rstudioapi_0.15.0 RSQLite_2.3.5 shape_1.4.6.1 gridGraphics_0.5-1 ## [41] generics_0.1.3 dplyr_1.1.4 GO.db_3.18.0 ggbeeswarm_0.7.2 ## [45] fansi_1.0.6 abind_1.4-5 R.methodsS3_1.8.2 lifecycle_1.0.4 ## [49] yaml_2.3.8 edgeR_4.1.18 qvalue_2.35.0 SparseArray_1.3.4 ## [53] blob_1.2.4 promises_1.2.1 dqrng_0.3.2 crayon_1.5.2 ## [57] miniUI_0.1.1.1 lattice_0.22-5 beachmat_2.19.1 cowplot_1.1.3 ## [61] annotate_1.81.2 KEGGREST_1.43.0 magick_2.8.3 ComplexHeatmap_2.19.0 ## [65] pillar_1.9.0 knitr_1.45 metapod_1.11.1 fgsea_1.29.0 ## [69] rjson_0.2.21 codetools_0.2-19 fastmatch_1.1-4 glue_1.7.0 ## [73] ggfun_0.1.4 remotes_2.5.0 treeio_1.27.0 vctrs_0.6.5 ## [77] png_0.1-8 poweRlaw_0.80.0 cachem_1.0.8 xfun_0.42 ## [81] S4Arrays_1.3.6 mime_0.12 tidygraph_1.3.1 pracma_2.4.4 ## [85] iterators_1.0.14 statmod_1.5.0 bluster_1.13.0 ellipsis_0.3.2 ## [89] nlme_3.1-164 ggtree_3.11.1 bit64_4.0.5 filelock_1.0.3 ## [93] bslib_0.6.1 irlba_2.3.5.1 vipor_0.4.7 colorspace_2.1-0 ## [97] seqLogo_1.69.0 DBI_1.2.2 ggrastr_1.0.2 tidyselect_1.2.1 ## [101] bit_4.0.5 compiler_4.4.0 curl_5.2.1 graph_1.81.0 ## [105] BiocNeighbors_1.21.2 DelayedArray_0.29.9 shadowtext_0.1.3 bookdown_0.38 ## [109] checkmate_2.3.1 scales_1.3.0 caTools_1.18.2 rappdirs_0.3.3 ## [113] digest_0.6.35 motifmatchr_1.25.0 rmarkdown_2.26 htmltools_0.5.7 ## [117] pkgconfig_2.0.3 highr_0.10 fastmap_1.1.1 GlobalOptions_0.1.2 ## [121] rlang_1.1.3 htmlwidgets_1.6.4 shiny_1.8.0 DelayedMatrixStats_1.25.1 ## [125] farver_2.1.1 jquerylib_0.1.4 jsonlite_1.8.8 BiocParallel_1.37.1 ## [129] GOSemSim_2.29.1 R.oo_1.26.0 BiocSingular_1.19.0 RCurl_1.98-1.14 ## [133] ggplotify_0.1.2 scuttle_1.13.1 GenomeInfoDbData_1.2.11 patchwork_1.2.0 ## [137] Rhdf5lib_1.25.1 munsell_0.5.0 ape_5.7-1 babelgene_22.9 ## [141] viridis_0.6.5 EnrichmentBrowser_2.33.1 stringi_1.8.3 ggraph_2.2.1 ## [145] MASS_7.3-60.1 zlibbioc_1.49.3 pkgbuild_1.4.4 ggrepel_0.9.5 ## [149] CNEr_1.39.0 graphlayouts_1.1.1 splines_4.4.0 circlize_0.4.16 ## [153] hms_1.1.3 locfit_1.5-9.9 reshape2_1.4.4 ScaledMatrix_1.11.1 ## [157] pkgload_1.3.4 TFMPvalue_0.0.9 BiocVersion_3.19.1 XML_3.99-0.16.1 ## [161] evaluate_0.23 scran_1.31.3 BiocManager_1.30.22 foreach_1.5.2 ## [165] tweenr_2.0.3 tzdb_0.4.0 httpuv_1.6.14 polyclip_1.10-6 ## [169] tidyr_1.3.1 purrr_1.0.2 clue_0.3-65 ggforce_0.4.2 ## [173] rsvd_1.0.5 xtable_1.8-4 restfulr_0.0.15 tidytree_0.4.6 ## [177] later_1.3.2 viridisLite_0.4.2 tibble_3.2.1 aplot_0.2.2 ## [181] clusterProfiler_4.11.0 memoise_2.0.1 beeswarm_0.4.0 GenomicAlignments_1.39.4 ## [185] cluster_2.1.6 GSEABase_1.65.1 "],["single-modality-scrna-seq-only.html", "5 Single modality: scRNA-seq only 5.1 Load regulon 5.2 Load scRNA-seq data 5.3 Calculate activity 5.4 Perform differential activity 5.5 Visualize activity 5.6 Pathway enrichment 5.7 Session Info", " 5 Single modality: scRNA-seq only Epiregulon also supports transcription factor activity inference when users only have scRNA-seq. After all, multiome or scATAC-seq data is still relatively rare. To enable TF activity inference on scRNA-seq, users can supply a pre-constructed gene regulatory network. Dorothea provides both human and mouse pre-constructed gene regulatory networks based on curated experimental and computational data. In this vignette, we bypass the regulon construction step and go straight to calculate TF activity from a Dorothea GRN. 5.1 Load regulon Dorothea assigns confidence level to its regulons with A being the most confident (i.e. supported by multiple lines of evidence) and E being the least confident. library(dorothea) data(dorothea_mm, package = &quot;dorothea&quot;) regulon &lt;- dorothea_mm #known tfs genes_to_plot &lt;- c(&quot;Foxa1&quot;, &quot;Neurod1&quot;,&quot;Pdx1&quot;,&quot;Arx&quot;) 5.2 Load scRNA-seq data We download the raw counts of a mouse pancreas data set from scRNAseq. We add normalized logcounts, perform dimension reduction and visualize the embeddings using scater. library(scRNAseq) library(scater) sce &lt;- BaronPancreasData(&#39;mouse&#39;) sce &lt;- logNormCounts(sce) sce &lt;- runPCA(sce) sce &lt;- runUMAP(sce) plotUMAP(sce, colour_by = &quot;label&quot;, text_by = &quot;label&quot;) 5.3 Calculate activity Even though Dorothea provides weights under the mor column, we can achieve superior performance if we recompute the weights based on the correlation between tf and target gene expression based on our own data. We performed 2 steps, the first step is to add weights to the Dorothea regulons and the second step is to estimate the TF activity by taking the weighted average of the target gene expression. library(epiregulon) #Add weights to regulon. Default method (wilcoxon) cannot be used regulon.ms &lt;- addWeights(regulon = regulon, expMatrix = sce, clusters = sce$label, BPPARAM = BiocParallel::MulticoreParam(), method=&quot;corr&quot;) #Calculate activity score.combine &lt;- calculateActivity(sce, regulon = regulon.ms, mode = &quot;weight&quot;, method = &quot;weightedMean&quot;) 5.4 Perform differential activity library(epiregulon.extra) markers &lt;- findDifferentialActivity(activity_matrix = score.combine, clusters = sce$label, pval.type = &quot;some&quot;, direction = &quot;up&quot;, test.type = &quot;t&quot;) Take the top TFs markers.sig &lt;- getSigGenes(markers, topgenes = 5 ) 5.5 Visualize activity Finally we visualize the TF activity by either UMAP, violin plots or bubble plots. We confirm the activity of known lineage factors Pdx1 and Neurod1 in beta cells, Arx in alpha cells and Foxa1 in ductal cells. # plot umap plotActivityDim(sce = sce, activity_matrix = score.combine, tf = genes_to_plot, legend.label = &quot;score&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2) # plot violin plot plotActivityViolin(score.combine, tf = genes_to_plot, clusters = sce$label) # plot bubble plot plotBubble(score.combine, tf = genes_to_plot, clusters = sce$label) Plot bubble plot of differential TFs plotBubble(score.combine, tf = markers.sig$tf, clusters = sce$label) We can adapt the epiregulon package to plot gene expression. When compared against TF activity, gene expression of Foxa1 and Arx has noisy signals and high dropout rates. Epiregulon enhances the signal to noise ratio of TF activity and better resolves lineage differences. # plot umap plotActivityDim(sce = sce, activity_matrix = logcounts(sce), tf = genes_to_plot, legend.label = &quot;gex&quot;, point_size = 0.1, dimtype = &quot;UMAP&quot;, label = &quot;label&quot;, combine = TRUE, text_size = 2, colors = c(&quot;gray&quot;,&quot;blue&quot;), limit = c(0,2)) # plot violin plot plotActivityViolin(logcounts(sce), tf = genes_to_plot, clusters = sce$label, legend.label = &quot;gex&quot;) # plot Bubble plot plotBubble(logcounts(sce), tf = markers.sig$tf, clusters = sce$label, legend.label = &quot;gex&quot;) We can visualize the target genes for transcription factors of interest plotHeatmapRegulon(sce=sce, tfs=genes_to_plot, regulon=regulon.ms, regulon_cutoff=0.5, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, exprs_values=&quot;logcounts&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) plotHeatmapActivity(activity_matrix = score.combine, sce=sce, tfs=genes_to_plot, downsample=1000, cell_attributes=&quot;label&quot;, col_gap=&quot;label&quot;, name=&quot;regulon heatmap&quot;, column_title_rot = 45) 5.6 Pathway enrichment Sometimes it is useful to understand what pathways are enriched in the regulons. We take the highly correlated target genes of a regulon and perform geneset enrichment using the enricher function from clusterProfiler. #retrieve genesets H &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;H&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) C6 &lt;- EnrichmentBrowser::getGenesets(org = &quot;mmu&quot;, db = &quot;msigdb&quot;, cat = &quot;C6&quot;, gene.id.type = &quot;SYMBOL&quot;, cache = FALSE) #combine genesets and convert genesets to be compatible with enricher gs &lt;- c(H,C6) gs.list &lt;- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs = x, genes = gs[[x]])})) enrichresults &lt;- regulonEnrich(genes_to_plot, regulon = regulon.ms, weight = &quot;weight&quot;, weight_cutoff = 0.5, genesets = gs.list) ## Foxa1 ## Neurod1 ## Pdx1 ## Arx #plot results enrichPlot(results = enrichresults, ncol = 1) 5.7 Session Info sessionInfo() ## R Under development (unstable) (2023-12-04 r85659) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 18.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/local/lib/R/lib/libRblas.so ## LAPACK: /usr/local/lib/R/lib/libRlapack.so; LAPACK version 3.11.0 ## ## Random number generation: ## RNG: L&#39;Ecuyer-CMRG ## Normal: Inversion ## Sample: Rejection ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] parallel stats4 grid stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] org.Mm.eg.db_3.18.0 scater_1.31.2 scuttle_1.13.1 ## [4] scRNAseq_2.17.5 dorothea_1.15.1 org.Hs.eg.db_3.18.0 ## [7] AnnotationDbi_1.65.2 nabor_0.5.0 epiregulon.archr_0.99.2 ## [10] igraph_2.0.3 msigdbr_7.5.1 epiregulon.extra_0.99.5 ## [13] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.71.2 rtracklayer_1.63.1 ## [16] BiocIO_1.13.0 Biostrings_2.71.4 XVector_0.43.1 ## [19] epiregulon_0.99.5 scMultiome_1.3.0 SingleCellExperiment_1.25.0 ## [22] MultiAssayExperiment_1.29.1 ExperimentHub_2.11.1 AnnotationHub_3.11.1 ## [25] BiocFileCache_2.11.1 dbplyr_2.4.0 BiocStyle_2.31.0 ## [28] rhdf5_2.47.6 SummarizedExperiment_1.33.3 Biobase_2.63.0 ## [31] RcppArmadillo_0.12.8.1.0 Rcpp_1.0.12 Matrix_1.6-4 ## [34] GenomicRanges_1.55.3 GenomeInfoDb_1.39.9 IRanges_2.37.1 ## [37] S4Vectors_0.41.4 BiocGenerics_0.49.1 sparseMatrixStats_1.15.0 ## [40] MatrixGenerics_1.15.0 matrixStats_1.2.0 data.table_1.15.2 ## [43] stringr_1.5.1 plyr_1.8.9 magrittr_2.0.3 ## [46] ggplot2_3.5.0 gtable_0.3.4 gtools_3.9.5 ## [49] gridExtra_2.3 devtools_2.4.5 usethis_2.2.3 ## [52] ArchR_1.0.3 ## ## loaded via a namespace (and not attached): ## [1] R.methodsS3_1.8.2 GSEABase_1.65.1 progress_1.2.3 urlchecker_1.0.1 ## [5] poweRlaw_0.80.0 HDF5Array_1.31.6 vctrs_0.6.5 digest_0.6.35 ## [9] png_0.1-8 shape_1.4.6.1 aws.signature_0.6.0 gypsum_0.99.15 ## [13] ggrepel_0.9.5 alabaster.sce_1.3.3 bcellViper_1.39.0 magick_2.8.3 ## [17] MASS_7.3-60.1 reshape2_1.4.4 httpuv_1.6.14 foreach_1.5.2 ## [21] qvalue_2.35.0 withr_3.0.0 ggrastr_1.0.2 aws.s3_0.3.21 ## [25] xfun_0.42 ggfun_0.1.4 ellipsis_0.3.2 memoise_2.0.1 ## [29] ggbeeswarm_0.7.2 clusterProfiler_4.11.0 gson_0.1.0 profvis_0.3.8 ## [33] tidytree_0.4.6 GlobalOptions_0.1.2 KEGGgraph_1.63.0 R.oo_1.26.0 ## [37] prettyunits_1.2.0 KEGGREST_1.43.0 promises_1.2.1 httr_1.4.7 ## [41] aws.ec2metadata_0.2.0 restfulr_0.0.15 rhdf5filters_1.15.4 rstudioapi_0.15.0 ## [45] miniUI_0.1.1.1 generics_0.1.3 DOSE_3.29.2 base64enc_0.1-3 ## [49] babelgene_22.9 curl_5.2.1 zlibbioc_1.49.3 ScaledMatrix_1.11.1 ## [53] ggraph_2.2.1 polyclip_1.10-6 GenomeInfoDbData_1.2.11 SparseArray_1.3.4 ## [57] xtable_1.8-4 pracma_2.4.4 doParallel_1.0.17 evaluate_0.23 ## [61] S4Arrays_1.3.6 hms_1.1.3 bookdown_0.38 irlba_2.3.5.1 ## [65] colorspace_2.1-0 filelock_1.0.3 readr_2.1.5 Rgraphviz_2.47.0 ## [69] later_1.3.2 viridis_0.6.5 ggtree_3.11.1 lattice_0.22-5 ## [73] XML_3.99-0.16.1 shadowtext_0.1.3 cowplot_1.1.3 pillar_1.9.0 ## [77] nlme_3.1-164 iterators_1.0.14 caTools_1.18.2 compiler_4.4.0 ## [81] beachmat_2.19.1 stringi_1.8.3 GenomicAlignments_1.39.4 crayon_1.5.2 ## [85] abind_1.4-5 gridGraphics_0.5-1 locfit_1.5-9.9 graphlayouts_1.1.1 ## [89] bit_4.0.5 dplyr_1.1.4 fastmatch_1.1-4 codetools_0.2-19 ## [93] BiocSingular_1.19.0 bslib_0.6.1 alabaster.ranges_1.3.3 GetoptLong_1.0.5 ## [97] mime_0.12 splines_4.4.0 circlize_0.4.16 HDO.db_0.99.1 ## [101] EnrichmentBrowser_2.33.1 knitr_1.45 blob_1.2.4 utf8_1.2.4 ## [105] clue_0.3-65 BiocVersion_3.19.1 seqLogo_1.69.0 AnnotationFilter_1.27.0 ## [109] fs_1.6.3 checkmate_2.3.1 DelayedMatrixStats_1.25.1 pkgbuild_1.4.4 ## [113] ggplotify_0.1.2 tibble_3.2.1 statmod_1.5.0 tzdb_0.4.0 ## [117] tweenr_2.0.3 pkgconfig_2.0.3 tools_4.4.0 cachem_1.0.8 ## [121] RSQLite_2.3.5 viridisLite_0.4.2 DBI_1.2.2 fastmap_1.1.1 ## [125] rmarkdown_2.26 scales_1.3.0 Rsamtools_2.19.3 sass_0.4.9 ## [129] FNN_1.1.4 patchwork_1.2.0 BiocManager_1.30.22 graph_1.81.0 ## [133] alabaster.schemas_1.3.1 farver_2.1.1 tidygraph_1.3.1 scatterpie_0.2.1 ## [137] yaml_2.3.8 cli_3.6.2 purrr_1.0.2 motifmatchr_1.25.0 ## [141] lifecycle_1.0.4 uwot_0.1.16 bluster_1.13.0 sessioninfo_1.2.2 ## [145] backports_1.4.1 BiocParallel_1.37.1 annotate_1.81.2 rjson_0.2.21 ## [149] ape_5.7-1 limma_3.59.6 jsonlite_1.8.8 edgeR_4.1.18 ## [153] TFBSTools_1.41.0 bitops_1.0-7 bit64_4.0.5 yulab.utils_0.1.4 ## [157] alabaster.matrix_1.3.13 BiocNeighbors_1.21.2 CNEr_1.39.0 alabaster.se_1.3.4 ## [161] jquerylib_0.1.4 highr_0.10 metapod_1.11.1 GOSemSim_2.29.1 ## [165] dqrng_0.3.2 R.utils_2.12.3 alabaster.base_1.3.23 lazyeval_0.2.2 ## [169] shiny_1.8.0 htmltools_0.5.7 enrichplot_1.23.1 GO.db_3.18.0 ## [173] rappdirs_0.3.3 ensembldb_2.27.1 glue_1.7.0 TFMPvalue_0.0.9 ## [177] httr2_1.0.0 RCurl_1.98-1.14 treeio_1.27.0 scran_1.31.3 ## [181] R6_2.5.1 tidyr_1.3.1 labeling_0.4.3 GenomicFeatures_1.55.4 ## [185] cluster_2.1.6 pkgload_1.3.4 Rhdf5lib_1.25.1 aplot_0.2.2 ## [189] DirichletMultinomial_1.45.0 ProtGenerics_1.35.4 DelayedArray_0.29.9 tidyselect_1.2.1 ## [193] vipor_0.4.7 xml2_1.3.6 ggforce_0.4.2 rsvd_1.0.5 ## [197] munsell_0.5.0 htmlwidgets_1.6.4 fgsea_1.29.0 ComplexHeatmap_2.19.0 ## [201] RColorBrewer_1.1-3 biomaRt_2.59.1 rlang_1.1.3 remotes_2.5.0 ## [205] fansi_1.0.6 Cairo_1.6-2 beeswarm_0.4.0 "],["contact.html", "6 Contact", " 6 Contact The issues related to epiregulon suite of packages can be reported on the package GitHub repository page. epiregulon epiregulon.extra epiregulon.archr If you need more information on the package usage you can contact authors directly: Xiaosai Yao, yaox19@gene.com Tomasz Włodarczy, tomwlo@gmail.com "]]
